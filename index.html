<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RT-FIELDGEN // DIV-C 2025-26</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Base Colors */
            --bg-dark: #0a0e14;
            --bg-surface: #151a21;
            --border: #2d3640;
            --text-primary: #e6e6e6;
            --text-secondary: #8a919d;
            --text-tertiary: #5c6370;

            /* Accent Colors */
            --success: #73d47a;
            --warning: #ffcc66;
            --error: #ff6b6b;
            --info: #5ccfe6;
            --link: #73d0ff;

            /* Field Elements - increased saturation for better visibility */
            --start-color: #73d47a;
            --target-color: #ff9940;
            --gate-a: #ff7eb3;
            --gate-b: #6ad8f0;
            --gate-c: #d18cff;
            --gate-d: #ffd480;
            --gate-e: #8ce077;
            --gate-f: #ffac5c;
            --obstacle-color: #525a6a;
            --bottle-color: #6ad8f0;
            --grid-color: #2d3640;
            --boundary-color: #8a919d;

            /* Typography */
            --font-primary: 'IBM Plex Mono', 'SF Mono', 'Consolas', monospace;
            --font-data: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;

            /* Spacing */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 24px;
            --space-6: 32px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-primary);
            font-size: 14px;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
            overflow: hidden;
        }

        /* HEADER */
        .header {
            height: 44px;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--border);
            padding: 0 var(--space-4);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .header-logo {
            height: 26px;
            width: auto;
            opacity: 0.9;
        }

        .header-brand-text {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .header-school {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .header-author {
            font-size: 10px;
            font-weight: 400;
            color: var(--text-tertiary);
            letter-spacing: 0.3px;
        }

        .header-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .header-title span {
            color: var(--text-tertiary);
        }

        .header-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 var(--space-3);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .status-badge {
            font-size: 10px;
            font-family: var(--font-data);
            padding: 2px 8px;
            border: 1px solid var(--success);
            color: var(--success);
            background: transparent;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .status-badge.warning {
            border-color: var(--warning);
            color: var(--warning);
        }

        .status-badge.error {
            border-color: var(--error);
            color: var(--error);
        }

        .status-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: currentColor;
        }

        /* BUTTONS */
        .btn {
            font-family: var(--font-primary);
            font-size: 11px;
            padding: var(--space-1) var(--space-3);
            background: transparent;
            border: 1px solid var(--info);
            color: var(--info);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.15s ease;
        }

        .btn:hover {
            background: rgba(92, 207, 230, 0.1);
            border-color: var(--link);
            color: var(--link);
        }

        .btn:active {
            background: rgba(92, 207, 230, 0.2);
        }

        .btn.btn-success {
            border-color: var(--success);
            color: var(--success);
        }

        .btn.btn-success:hover {
            background: rgba(127, 217, 98, 0.1);
        }

        .btn.btn-warning {
            border-color: var(--warning);
            color: var(--warning);
        }

        .btn.btn-warning:hover {
            background: rgba(255, 204, 102, 0.1);
        }

        .btn.btn-error {
            border-color: var(--error);
            color: var(--error);
        }

        .btn.btn-error:hover {
            background: rgba(255, 107, 107, 0.1);
        }

        .btn.active {
            background: rgba(92, 207, 230, 0.15);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* DROPDOWN */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            min-width: 180px;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: var(--font-primary);
            font-size: 12px;
            text-align: left;
            cursor: pointer;
            transition: all 0.15s;
        }

        .dropdown-item:hover {
            background: rgba(92, 207, 230, 0.1);
            color: var(--info);
        }

        /* MAIN LAYOUT */
        .main-container {
            display: flex;
            height: calc(100vh - 44px);
            position: relative;
        }

        /* PANEL TOGGLE BUTTONS */
        .panel-toggle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 60px;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .panel-toggle:hover {
            background: var(--bg-dark);
            color: var(--info);
            border-color: var(--info);
        }

        .panel-toggle.left {
            left: 0;
            border-left: none;
            border-radius: 0 4px 4px 0;
        }

        .panel-toggle.right {
            right: 0;
            border-right: none;
            border-radius: 4px 0 0 4px;
        }

        .main-container.left-collapsed .panel-toggle.left {
            left: 0;
        }

        .main-container:not(.left-collapsed) .panel-toggle.left {
            left: 280px;
        }

        .main-container.right-collapsed .panel-toggle.right {
            right: 0;
        }

        .main-container:not(.right-collapsed) .panel-toggle.right {
            right: 260px;
        }

        /* LEFT PANEL */
        .left-panel {
            width: 280px;
            min-width: 280px;
            background: var(--bg-dark);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: width 0.2s ease, min-width 0.2s ease, margin-left 0.2s ease;
        }

        .main-container.left-collapsed .left-panel {
            width: 0;
            min-width: 0;
            margin-left: -280px;
            overflow: hidden;
        }

        .panel-section {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: var(--space-3);
            padding-bottom: var(--space-2);
            border-bottom: 1px solid var(--border);
        }

        /* FORM CONTROLS */
        .form-group {
            margin-bottom: var(--space-3);
        }

        .form-group label {
            display: block;
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-1);
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-surface);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-family: var(--font-primary);
            font-size: 13px;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: var(--info);
            box-shadow: 0 0 0 2px rgba(92, 207, 230, 0.1);
        }

        .form-row {
            display: flex;
            gap: var(--space-2);
        }

        .form-row .form-group {
            flex: 1;
        }

        /* INFO BLOCKS */
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-2);
        }

        .info-block {
            background: var(--bg-surface);
            padding: var(--space-2) var(--space-3);
            border: 1px solid var(--border);
        }

        .info-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-family: var(--font-data);
            font-size: 14px;
            color: var(--text-primary);
            margin-top: 2px;
        }

        .info-value.success { color: var(--success); }
        .info-value.warning { color: var(--warning); }
        .info-value.error { color: var(--error); }

        /* SENSOR TELEMETRY */
        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-1);
        }

        .sensor-reading {
            background: var(--bg-surface);
            padding: var(--space-1) var(--space-2);
            border: 1px solid var(--border);
            text-align: center;
        }

        .sensor-label {
            display: block;
            font-size: 9px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sensor-value {
            display: block;
            font-family: var(--font-data);
            font-size: 11px;
            color: var(--text-primary);
            margin-top: 1px;
        }

        .sensor-value.close { color: var(--error); }
        .sensor-value.medium { color: var(--warning); }
        .sensor-value.far { color: var(--success); }
        .sensor-value.invalid { color: var(--text-tertiary); }

        /* TOOL BUTTONS */
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-2);
            margin-bottom: var(--space-3);
        }

        .tool-btn {
            font-family: var(--font-primary);
            font-size: 11px;
            padding: var(--space-2) var(--space-1);
            background: var(--bg-surface);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.15s ease;
            text-align: center;
        }

        .tool-btn:hover {
            border-color: var(--text-secondary);
            color: var(--text-primary);
        }

        .tool-btn.active {
            border-color: var(--info);
            color: var(--info);
            background: rgba(92, 207, 230, 0.1);
        }

        .tool-btn.tool-start.active { border-color: var(--start-color); color: var(--start-color); }
        .tool-btn.tool-target.active { border-color: var(--target-color); color: var(--target-color); }
        .tool-btn.tool-gate.active { border-color: var(--gate-a); color: var(--gate-a); }
        .tool-btn.tool-obstacle.active { border-color: var(--obstacle-color); color: var(--text-primary); background: var(--obstacle-color); }
        .tool-btn.tool-bottle.active { border-color: var(--bottle-color); color: var(--bottle-color); }

        /* CHECKBOX */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            margin-bottom: var(--space-2);
        }

        .checkbox-group input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--info);
        }

        .checkbox-group label {
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .subsection-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-2);
            padding-bottom: var(--space-1);
            border-bottom: 1px solid var(--border);
        }

        /* ELEMENT LIST */
        .element-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .element-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-surface);
            border: 1px solid var(--border);
            margin-bottom: var(--space-1);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .element-item:hover {
            border-color: var(--text-tertiary);
        }

        .element-item.selected {
            border-color: var(--info);
            background: rgba(92, 207, 230, 0.05);
        }

        .element-item-info {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .element-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .element-name {
            color: var(--text-primary);
            font-family: var(--font-data);
        }

        .element-detail {
            color: var(--text-tertiary);
            font-size: 11px;
        }

        .element-delete {
            background: transparent;
            border: 1px solid var(--error);
            color: var(--error);
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.15s;
        }

        .element-delete:hover {
            opacity: 1;
            background: rgba(255, 107, 107, 0.1);
        }

        .empty-state {
            color: var(--text-tertiary);
            font-size: 12px;
            text-align: center;
            padding: var(--space-4);
            font-style: italic;
        }

        /* CENTER PANEL */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0d1117;
            min-width: 0;
            overflow: hidden;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-5);
            position: relative;
            min-height: 400px;
            overflow: auto;
            background: radial-gradient(ellipse at center, #151a21 0%, #0a0e14 100%);
        }

        #canvas {
            background: #1a2028;
            border: 3px solid var(--boundary-color);
            cursor: crosshair;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.6), 0 0 20px rgba(92, 207, 230, 0.1), inset 0 2px 8px rgba(0, 0, 0, 0.3);
            max-width: 100%;
            max-height: 100%;
        }

        /* Scale indicator */
        .scale-indicator {
            position: absolute;
            bottom: var(--space-5);
            right: var(--space-5);
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            font-family: var(--font-data);
            font-size: 10px;
            color: var(--text-tertiary);
        }

        .scale-bar {
            height: 4px;
            background: var(--text-secondary);
            border-left: 2px solid var(--text-secondary);
            border-right: 2px solid var(--text-secondary);
        }

        /* Keyboard shortcuts hint */
        .canvas-overlay {
            position: absolute;
            font-family: var(--font-data);
            font-size: 11px;
            padding: var(--space-1) var(--space-2);
            background: rgba(10, 14, 20, 0.9);
            border: 1px solid var(--border);
            pointer-events: none;
        }

        .coords-display {
            bottom: var(--space-5);
            left: var(--space-5);
            color: var(--text-secondary);
            font-size: 13px;
            padding: var(--space-2) var(--space-3);
        }

        .coords-display .value {
            color: var(--info);
            font-weight: 500;
        }

        .canvas-tooltip {
            position: absolute;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            padding: var(--space-2) var(--space-3);
            font-family: var(--font-data);
            font-size: 11px;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            max-width: 200px;
        }

        .canvas-tooltip .tooltip-title {
            font-weight: 500;
            margin-bottom: 4px;
            color: var(--info);
        }

        .canvas-tooltip .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: var(--space-3);
            color: var(--text-secondary);
        }

        .canvas-tooltip .tooltip-value {
            color: var(--text-primary);
        }

        /* BOTTOM PANEL */
        .bottom-panel {
            height: 180px;
            min-height: 36px;
            background: var(--bg-dark);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: height 0.2s ease;
        }

        .bottom-panel.collapsed {
            height: 36px;
        }

        .bottom-panel.collapsed .data-output {
            display: none;
        }

        .bottom-panel.expanded {
            height: 280px;
        }

        .bottom-header {
            height: 36px;
            min-height: 36px;
            background: var(--bg-surface);
            padding: 0 var(--space-3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            user-select: none;
        }

        .bottom-header:hover {
            background: rgba(45, 54, 64, 0.5);
        }

        .bottom-header-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .bottom-header-controls {
            display: flex;
            gap: var(--space-2);
        }

        .bottom-header-controls .btn {
            padding: 2px var(--space-2);
            font-size: 10px;
        }

        .data-output {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
            font-family: var(--font-data);
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .data-output .key { color: var(--info); }
        .data-output .value { color: var(--warning); }
        .data-output .string { color: var(--success); }
        .data-output .number { color: var(--target-color); }
        .data-output .comment { color: var(--text-tertiary); }
        .data-output .header { color: var(--text-primary); font-weight: 500; }

        /* RIGHT PANEL */
        .right-panel {
            width: 260px;
            min-width: 260px;
            background: var(--bg-dark);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: width 0.2s ease, min-width 0.2s ease, margin-right 0.2s ease;
        }

        .main-container.right-collapsed .right-panel {
            width: 0;
            min-width: 0;
            margin-right: -260px;
            overflow: hidden;
        }

        /* VALIDATION */
        .validation-list {
            max-height: 180px;
            overflow-y: auto;
        }

        .validation-item {
            display: flex;
            align-items: flex-start;
            gap: var(--space-2);
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--border);
            font-size: 11px;
            font-family: var(--font-data);
            flex-direction: column;
        }

        .validation-item:last-child {
            border-bottom: none;
        }

        .validation-item.pass { color: var(--success); }
        .validation-item.fail { color: var(--error); }
        .validation-item.warn { color: var(--warning); }

        .validation-main {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            width: 100%;
        }

        .validation-detail {
            font-size: 10px;
            color: var(--text-tertiary);
            padding-left: 18px;
            margin-top: 2px;
        }

        .validation-icon {
            font-size: 12px;
            width: 14px;
            text-align: center;
        }

        .validation-summary {
            display: flex;
            gap: var(--space-3);
            padding: var(--space-2) 0;
            margin-bottom: var(--space-2);
            border-bottom: 1px solid var(--border);
            font-size: 11px;
            font-family: var(--font-data);
        }

        .vs-pass { color: var(--success); }
        .vs-warn { color: var(--warning); }
        .vs-fail { color: var(--error); }

        .rule-id {
            font-size: 9px;
            color: var(--text-tertiary);
            margin-left: auto;
            font-family: var(--font-data);
            opacity: 0.7;
        }

        /* PROPERTIES */
        .properties-content {
            padding: var(--space-3) 0;
        }

        /* MEASUREMENTS */
        .measurement-row {
            display: flex;
            justify-content: space-between;
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
        }

        .measurement-row:last-child {
            border-bottom: none;
        }

        .measurement-label {
            color: var(--text-tertiary);
        }

        .measurement-value {
            font-family: var(--font-data);
            color: var(--text-primary);
        }

        .measurement-value.highlight {
            color: var(--warning);
            font-weight: 500;
        }

        .measurement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: var(--space-2);
            margin-bottom: var(--space-2);
            border-bottom: 1px solid var(--border);
            font-size: 11px;
            color: var(--text-secondary);
        }

        .btn-mini {
            font-family: var(--font-primary);
            font-size: 9px;
            padding: 2px 6px;
            background: transparent;
            border: 1px solid var(--error);
            color: var(--error);
            cursor: pointer;
        }

        .btn-mini:hover {
            background: rgba(255, 107, 107, 0.1);
        }

        .measurement-item {
            display: flex;
            flex-direction: column;
            padding: var(--space-2);
            margin-bottom: var(--space-2);
            background: var(--bg-surface);
            border: 1px solid var(--border);
            font-size: 11px;
            position: relative;
        }

        .measurement-item.valid {
            border-left: 3px solid var(--success);
        }

        .measurement-item.invalid {
            border-left: 3px solid var(--error);
        }

        .measurement-pair {
            font-family: var(--font-data);
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .measurement-data {
            display: flex;
            gap: var(--space-3);
            color: var(--text-secondary);
        }

        .measurement-data .dist {
            color: var(--info);
        }

        .measurement-data .clr.valid {
            color: var(--success);
        }

        .measurement-data .clr.invalid {
            color: var(--error);
        }

        .measurement-delete {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }

        .measurement-delete:hover {
            color: var(--error);
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border: 2px solid var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--obstacle-color);
        }

        /* MODE TABS */
        .mode-tabs {
            display: flex;
            gap: 1px;
            background: var(--border);
            margin-bottom: var(--space-3);
        }

        .mode-tab {
            flex: 1;
            padding: var(--space-2);
            background: var(--bg-surface);
            border: none;
            color: var(--text-tertiary);
            font-family: var(--font-primary);
            font-size: 11px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.15s;
        }

        .mode-tab:hover {
            color: var(--text-secondary);
        }

        .mode-tab.active {
            background: var(--bg-dark);
            color: var(--info);
        }

        /* ALERT */
        .alert {
            padding: var(--space-3);
            margin: var(--space-3) 0;
            font-size: 11px;
            font-family: var(--font-data);
        }

        .alert-error {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }

        .alert-success {
            background: rgba(127, 217, 98, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }

        /* UTILITY */
        .text-success { color: var(--success); }
        .text-warning { color: var(--warning); }
        .text-error { color: var(--error); }
        .text-info { color: var(--info); }
        .text-muted { color: var(--text-tertiary); }

        .mt-2 { margin-top: var(--space-2); }
        .mt-3 { margin-top: var(--space-3); }
        .mb-2 { margin-bottom: var(--space-2); }
        .mb-3 { margin-bottom: var(--space-3); }

        .flex { display: flex; }
        .gap-2 { gap: var(--space-2); }
        .justify-between { justify-content: space-between; }

        .full-width { width: 100%; }
    </style>
</head>
<body>
    <!-- HEADER -->
    <header class="header">
        <div class="header-left">
            <div class="header-brand">
                <img src="https://i.imgur.com/7H1CXR2.png" alt="Paideia Logo" class="header-logo">
                <div class="header-brand-text">
                    <span class="header-school">Paideia Science Olympiad</span>
                    <span class="header-author">Created by Henry Van Ness</span>
                </div>
            </div>
            <div class="header-divider"></div>
            <div class="header-title">
                RT-FIELDGEN
            </div>
        </div>
        <div class="header-controls">
            <button class="btn btn-warning" onclick="undo()" id="undoBtn" disabled title="Ctrl+Z">UNDO</button>
            <button class="btn btn-warning" onclick="redo()" id="redoBtn" disabled title="Ctrl+Y">REDO</button>
            <button class="btn" onclick="autoGenerate()" id="newFieldBtn" title="Ctrl+N">NEW FIELD</button>
            <button class="btn btn-success" onclick="generateRoute()" id="calcRouteBtn" title="Ctrl+R">RECALCULATE</button>
            <div class="dropdown">
                <button class="btn" onclick="toggleExportMenu()" id="exportBtn">EXPORT ▼</button>
                <div class="dropdown-menu" id="exportMenu">
                    <button class="dropdown-item" onclick="downloadImage()">Field as PNG</button>
                    <button class="dropdown-item" onclick="exportJSON()">Field as JSON</button>
                    <button class="dropdown-item" onclick="exportRouteJSON()">Route as JSON</button>
                    <button class="dropdown-item" onclick="exportComplete()">Complete Setup</button>
                </div>
            </div>
        </div>
    </header>

    <div class="main-container" id="mainContainer">
        <!-- PANEL TOGGLES -->
        <button class="panel-toggle left" onclick="toggleLeftPanel()" title="Toggle left panel (L)">◀</button>
        <button class="panel-toggle right" onclick="toggleRightPanel()" title="Toggle right panel (R)">▶</button>

        <!-- LEFT PANEL -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-section">
                <div class="section-header">MODE</div>
                <div class="mode-tabs">
                    <button class="mode-tab active" onclick="setMode('edit')" id="modeEdit">EDIT</button>
                    <button class="mode-tab" onclick="setMode('auto')" id="modeAuto">AUTO</button>
                    <button class="mode-tab" onclick="setMode('sim')" id="modeSim">SIM</button>
                </div>

                <div id="editModePanel">
                    <div class="subsection-label">PLACEMENT_TOOLS</div>
                    <div class="tool-grid">
                        <button class="tool-btn active" data-tool="select">SELECT</button>
                        <button class="tool-btn tool-gate" data-tool="gate">GATE</button>
                        <button class="tool-btn tool-obstacle" data-tool="obstacle">OBSTCL</button>
                        <button class="tool-btn tool-bottle" data-tool="bottle">BOTTLE</button>
                    </div>

                    <div class="subsection-label mt-3">DISPLAY_OPTIONS</div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid" checked>
                        <label for="showGrid">Show Grid Lines</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showZoneLabels" checked>
                        <label for="showZoneLabels">Show Zone Labels</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showClearance">
                        <label for="showClearance">Show Clearances</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showRoute" checked>
                        <label for="showRoute">Show Route Path</label>
                    </div>
                </div>

                <div id="autoModePanel" style="display: none;">
                    <div class="form-group">
                        <label>COMPETITION_LEVEL</label>
                        <select id="autoLevel">
                            <option value="regionals">regionals // 4 gates, 3 bottles</option>
                            <option value="states">states // 5 gates, 4 bottles</option>
                            <option value="nationals">nationals // 6 gates, 5 bottles</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>OBSTACLE_COUNT</label>
                        <input type="number" id="autoObstacles" value="6" min="0" max="10">
                    </div>
                    <button class="btn btn-success full-width mt-2" onclick="autoGenerate()">
                        GENERATE_RANDOM_FIELD
                    </button>
                </div>

                <!-- SIMULATION MODE PANEL -->
                <div id="simModePanel" style="display: none;">
                    <div class="subsection-label">ROBOT_CONFIG</div>
                    <div class="form-group">
                        <label>SPEED (mm/s)</label>
                        <input type="number" id="simSpeed" value="150" min="50" max="400" step="10">
                    </div>
                    <div class="form-group">
                        <label>TURN_RATE (°/s)</label>
                        <input type="number" id="simTurnRate" value="90" min="30" max="180" step="10">
                    </div>
                    <div class="subsection-label mt-3">SIMULATION</div>
                    <div class="flex gap-2">
                        <button class="btn btn-success" onclick="startSimulation()" id="simStartBtn">▶ START</button>
                        <button class="btn btn-warning" onclick="pauseSimulation()" id="simPauseBtn" disabled>⏸ PAUSE</button>
                        <button class="btn btn-error" onclick="resetSimulation()" id="simResetBtn">⟲ RESET</button>
                    </div>

                    <div class="form-group mt-3">
                        <label>PLAYBACK_SPEED</label>
                        <select id="simPlaybackSpeed">
                            <option value="0.25">0.25x (Slow)</option>
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1x (Real-time)</option>
                            <option value="2">2x</option>
                            <option value="4">4x (Fast)</option>
                        </select>
                    </div>

                    <div class="info-grid mt-3">
                        <div class="info-block">
                            <div class="info-label">ELAPSED</div>
                            <div class="info-value" id="simElapsed">0.0s</div>
                        </div>
                        <div class="info-block">
                            <div class="info-label">DISTANCE</div>
                            <div class="info-value" id="simDistance">0mm</div>
                        </div>
                        <div class="info-block">
                            <div class="info-label">GATES</div>
                            <div class="info-value" id="simGates">0/0</div>
                        </div>
                        <div class="info-block">
                            <div class="info-label">BOTTLES</div>
                            <div class="info-value" id="simBottles">0/0</div>
                        </div>
                    </div>

                    <div class="subsection-label mt-3">TOF_SENSORS</div>
                    <div class="sensor-grid" id="sensorTelemetry">
                        <div class="sensor-reading">
                            <span class="sensor-label">FRONT</span>
                            <span class="sensor-value" id="sensor_front">--</span>
                        </div>
                        <div class="sensor-reading">
                            <span class="sensor-label">F_LEFT</span>
                            <span class="sensor-value" id="sensor_front_left">--</span>
                        </div>
                        <div class="sensor-reading">
                            <span class="sensor-label">F_RIGHT</span>
                            <span class="sensor-value" id="sensor_front_right">--</span>
                        </div>
                        <div class="sensor-reading">
                            <span class="sensor-label">LEFT</span>
                            <span class="sensor-value" id="sensor_left">--</span>
                        </div>
                        <div class="sensor-reading">
                            <span class="sensor-label">RIGHT</span>
                            <span class="sensor-value" id="sensor_right">--</span>
                        </div>
                        <div class="sensor-reading">
                            <span class="sensor-label">BACK</span>
                            <span class="sensor-value" id="sensor_back">--</span>
                        </div>
                    </div>

                    <div class="subsection-label mt-3">VISUAL_OPTIONS</div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="simShowTrail" checked>
                        <label for="simShowTrail">Show Trail</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="simShowSensors" checked>
                        <label for="simShowSensors">Show Sensor Rays</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="simShowHeading" checked>
                        <label for="simShowHeading">Show Heading Arrow</label>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-header">FIELD_PARAMETERS</div>
                <div class="form-group">
                    <label>LEVEL</label>
                    <select id="level" onchange="validateField()">
                        <option value="regionals">regionals</option>
                        <option value="states">states</option>
                        <option value="nationals">nationals</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>TARGET_TIME_SEC</label>
                    <input type="number" id="targetTime" value="70" min="50" max="80">
                </div>
                <div class="checkbox-group mt-2">
                    <input type="checkbox" id="optimizeRoute" checked>
                    <label for="optimizeRoute">Optimize for Target Time</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="includeBottles">
                    <label for="includeBottles">Include Bottle Pushing</label>
                </div>
                <div class="form-group mt-2">
                    <label>RISK_APPETITE <span id="riskValue" style="color: var(--accent);">0.35</span> <span id="riskLabel" style="color: var(--text-secondary); font-size: 10px;">(BALANCED)</span></label>
                    <input type="range" id="riskAppetite" min="0" max="100" value="35"
                           style="width: 100%;"
                           oninput="updateRiskDisplay(this.value)">
                    <div style="display: flex; justify-content: space-between; font-size: 9px; color: var(--text-tertiary);">
                        <span>SAFE</span>
                        <span>BALANCED</span>
                        <span>AGGRESSIVE</span>
                        <span>MAX</span>
                    </div>
                    <div id="riskInfo" style="font-size: 9px; color: var(--text-tertiary); margin-top: 4px;">
                        Min gates: 1 | Score weight: 1.18x
                    </div>
                </div>
                <div class="info-grid mt-3">
                    <div class="info-block">
                        <div class="info-label">FIELD_W</div>
                        <div class="info-value">2000mm</div>
                    </div>
                    <div class="info-block">
                        <div class="info-label">FIELD_L</div>
                        <div class="info-value">2500mm</div>
                    </div>
                    <div class="info-block">
                        <div class="info-label">ZONES</div>
                        <div class="info-value">4×5</div>
                    </div>
                    <div class="info-block">
                        <div class="info-label">ZONE_SIZE</div>
                        <div class="info-value">500mm</div>
                    </div>
                </div>
                <div class="flex gap-2 mt-3">
                    <button class="btn btn-error" onclick="clearField()">CLEAR</button>
                    <button class="btn btn-success" onclick="generateRoute()">ROUTE</button>
                </div>
            </div>

            <div class="panel-section" style="flex: 1;">
                <div class="section-header">ELEMENTS // <span id="elementCount">0</span></div>
                <div class="element-list" id="elementList">
                    <div class="empty-state">no elements placed</div>
                </div>
            </div>
        </div>

        <!-- CENTER PANEL -->
        <div class="center-panel">
            <div class="canvas-container">

                <canvas id="canvas" width="600" height="750"></canvas>

                <div class="canvas-overlay coords-display" id="coordsDisplay">
                    X: <span class="value">0</span> Y: <span class="value">0</span> // ZONE: <span class="value">(0,0)</span>
                </div>
                <div class="canvas-tooltip" id="tooltip" style="display: none;"></div>

                <!-- Scale indicator -->
                <div class="scale-indicator" id="scaleIndicator">
                    <div class="scale-bar" style="width: 150px;"></div>
                    <span>500mm</span>
                </div>

            </div>

            <!-- BOTTOM DATA PANEL -->
            <div class="bottom-panel" id="bottomPanel">
                <div class="bottom-header" onclick="toggleBottomPanel()">
                    <div class="bottom-header-title">
                        <span id="panelToggleIcon">▼</span> ROUTE_OUTPUT <span class="text-muted">(click to expand/collapse)</span>
                    </div>
                    <div class="bottom-header-controls" onclick="event.stopPropagation()">
                        <button class="btn" onclick="copyRoute()">COPY</button>
                        <button class="btn" onclick="generateRoute()">REFRESH</button>
                    </div>
                </div>
                <div class="data-output" id="routeOutput">
<span class="comment">// place START, TARGET, and GATES to generate route</span>
<span class="comment">// click GENERATE or ROUTE button to create path</span>
<span class="comment">// enable "Show Route Path" to see visual route on canvas</span>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="section-header">VALIDATION</div>
                <div class="validation-list" id="validationPanel">
                    <div class="empty-state">awaiting elements</div>
                </div>
            </div>

            <div class="panel-section">
                <div class="section-header">SELECTED_ELEMENT</div>
                <div id="propertiesPanel">
                    <div class="empty-state">click element to edit</div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const FIELD_WIDTH = 2000;
        const FIELD_LENGTH = 2500;
        const ZONE_SIZE = 500;
        const TAPE_WIDTH = 25;
        const GRID_COLS = 4;
        const GRID_ROWS = 5;

        const OBSTACLE_WIDTH = 38;
        const OBSTACLE_DEPTH = 89;
        const OBSTACLE_LENGTH = 406;
        const BOTTLE_DIAMETER = 65;
        const ROBOT_SIZE = 300;
        const MIN_CLEARANCE = 200;
        const WALL_MARGIN = 150;

        let SCALE = 0.3; // Dynamic scale for responsive canvas

        const LEVELS = {
            regionals: { gates: 4, bottles: 3, timeMin: 60, timeMax: 80 },
            states: { gates: 5, bottles: 4, timeMin: 55, timeMax: 75 },
            nationals: { gates: 6, bottles: 5, timeMin: 50, timeMax: 65 }
        };

        const GATE_LABELS = ['A', 'B', 'C', 'D', 'E', 'F'];
        const GATE_COLORS = ['#ff7eb3', '#6ad8f0', '#d18cff', '#ffd480', '#8ce077', '#ffac5c'];

        const GRID_LINES_X = [0, 500, 1000, 1500, 2000];
        const GRID_LINES_Y = [0, 500, 1000, 1500, 2000, 2500];

        // ==================== STATE ====================
        let currentTool = 'select';
        let currentMode = 'edit';
        let selectedElement = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let measureStart = null;
        let measureEnd = null;
        let nextGateIndex = 0;
        let validationResults = [];
        let genStartTime = 0;

        let fieldElements = {
            start: null,
            target: null,
            gates: [],
            obstacles: [],
            bottles: []
        };

        // Generated route for visual display
        let generatedRoute = [];

        // Measurement system
        let activeMeasurements = [];
        let measurementFirstElement = null;
        let measurementNextId = 1;

        // Panel state
        let leftPanelCollapsed = false;
        let rightPanelCollapsed = false;
        let bottomPanelCollapsed = true; // Start collapsed for more room

        // ==================== SIMULATION STATE ====================
        let simState = {
            running: false,
            paused: false,
            robot: {
                x: 0,
                y: 0,
                heading: 0, // degrees, 0 = right, 90 = down
                speed: 150, // mm/s
                turnRate: 90 // degrees/s
            },
            elapsedTime: 0,
            totalDistance: 0,
            trail: [],
            visitedGates: new Set(),
            knockedBottles: new Set(),
            currentTarget: null,
            waypoints: [],
            waypointIndex: 0,
            lastTimestamp: 0,
            playbackSpeed: 1,
            // PID-style turn-then-drive state
            movementPhase: 'idle', // 'idle', 'turning', 'driving'
            targetHeading: 0
        };

        // App state for button management
        let appState = 'no_field'; // no_field, field_ready, route_ready, editing
        let pathPlanner = null;

        // ==================== A* PATHFINDING ====================
        class PathPlanner {
            constructor(robotSize = ROBOT_SIZE) {
                this.robotRadius = robotSize / 2; // 150mm for 300mm robot

                // Clearance: 200mm from robot CENTER to obstacle edge
                this.requiredClearance = 200; // mm

                // Safety margin from walls (robot radius + buffer)
                this.safetyMargin = 50; // Extra buffer beyond robot radius

                // Start with ideal inflation, can reduce if no path found
                this.baseInflation = this.requiredClearance + 50; // 250mm ideal
                this.minInflation = this.requiredClearance; // 200mm minimum
                this.inflationRadius = this.baseInflation;

                this.gridResolution = 50; // 50mm grid cells
                this.grid = null;
                this.cols = Math.ceil(FIELD_WIDTH / this.gridResolution);
                this.rows = Math.ceil(FIELD_LENGTH / this.gridResolution);

                console.log(`PathPlanner initialized:`);
                console.log(`  Robot radius: ${this.robotRadius}mm`);
                console.log(`  Safety margin: ${this.safetyMargin}mm`);
                console.log(`  Required clearance: ${this.requiredClearance}mm (center to obstacle)`);
                console.log(`  Grid inflation radius: ${this.inflationRadius}mm`);
            }

            buildGrid() {
                console.log('Building navigation grid...');

                // Create navigation grid
                this.grid = [];
                for (let row = 0; row < this.rows; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.cols; col++) {
                        this.grid[row][col] = {
                            col: col,
                            row: row,
                            worldX: col * this.gridResolution,
                            worldY: row * this.gridResolution,
                            walkable: true,
                            cost: 1,
                            reason: null
                        };
                    }
                }

                console.log(`  Grid size: ${this.cols}×${this.rows} (${this.cols * this.rows} cells)`);

                // Mark boundary margins as unwalkable
                this.markBoundaryMargins();

                // Inflate obstacles with proper clearance
                this.inflateObstacles();

                // Inflate bottles (they're also obstacles to avoid)
                this.inflateBottles();

                return this;
            }

            markBoundaryMargins() {
                // Robot center must stay at least robotRadius from walls
                const marginDistance = this.robotRadius + this.safetyMargin;
                const marginCells = Math.ceil(marginDistance / this.gridResolution);

                let cellsMarked = 0;
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (col < marginCells || col >= this.cols - marginCells ||
                            row < marginCells || row >= this.rows - marginCells) {
                            this.grid[row][col].walkable = false;
                            this.grid[row][col].reason = 'boundary';
                            cellsMarked++;
                        }
                    }
                }
                console.log(`  Boundary margins: ${cellsMarked} cells marked (${marginDistance}mm from walls)`);
            }

            inflateObstacles() {
                let totalCells = 0;

                console.log(`  Inflating ${fieldElements.obstacles.length} obstacles with radius ${this.inflationRadius}mm...`);

                for (let oi = 0; oi < fieldElements.obstacles.length; oi++) {
                    const obs = fieldElements.obstacles[oi];
                    // Get obstacle actual bounds
                    const obsMinX = obs.x;
                    const obsMaxX = obs.x + obs.width;
                    const obsMinY = obs.y;
                    const obsMaxY = obs.y + obs.height;

                    console.log(`    Obstacle ${oi + 1}: (${obsMinX},${obsMinY}) to (${obsMaxX},${obsMaxY}), size ${obs.width}x${obs.height}`);

                    // Inflate bounds by full inflation radius
                    const minX = obsMinX - this.inflationRadius;
                    const maxX = obsMaxX + this.inflationRadius;
                    const minY = obsMinY - this.inflationRadius;
                    const maxY = obsMaxY + this.inflationRadius;

                    // Mark grid cells as unwalkable
                    const minCol = Math.floor(minX / this.gridResolution);
                    const maxCol = Math.ceil(maxX / this.gridResolution);
                    const minRow = Math.floor(minY / this.gridResolution);
                    const maxRow = Math.ceil(maxY / this.gridResolution);

                    let cellsMarked = 0;
                    for (let row = minRow; row <= maxRow; row++) {
                        for (let col = minCol; col <= maxCol; col++) {
                            if (this.isValidCell(col, row) && this.grid[row][col].walkable) {
                                this.grid[row][col].walkable = false;
                                this.grid[row][col].reason = 'obstacle';
                                cellsMarked++;
                            }
                        }
                    }
                    console.log(`      Marked ${cellsMarked} cells (cols ${minCol}-${maxCol}, rows ${minRow}-${maxRow})`);
                    totalCells += cellsMarked;
                }

                console.log(`  Obstacles inflated: ${totalCells} total cells marked`);
            }

            inflateBottles() {
                // DISABLED: Bottles are not obstacles - robot can push through them
                // Only avoid bottles when actively trying to push them to a gate
                console.log('  Bottle inflation DISABLED - bottles are not obstacles');
                return;

                // --- OLD CODE (kept for reference) ---
                // Bottles are smaller but still need clearance
                const bottleInflation = this.robotRadius + 100; // Less clearance needed for bottles
                let totalCells = 0;

                for (const bottle of fieldElements.bottles) {
                    const minX = bottle.x - bottle.radius - bottleInflation;
                    const maxX = bottle.x + bottle.radius + bottleInflation;
                    const minY = bottle.y - bottle.radius - bottleInflation;
                    const maxY = bottle.y + bottle.radius + bottleInflation;

                    const minCol = Math.floor(minX / this.gridResolution);
                    const maxCol = Math.ceil(maxX / this.gridResolution);
                    const minRow = Math.floor(minY / this.gridResolution);
                    const maxRow = Math.ceil(maxY / this.gridResolution);

                    let cellsMarked = 0;
                    for (let row = minRow; row <= maxRow; row++) {
                        for (let col = minCol; col <= maxCol; col++) {
                            if (this.isValidCell(col, row) && this.grid[row][col].walkable) {
                                // Check actual distance from bottle center (circular inflation)
                                const cellCenterX = col * this.gridResolution + this.gridResolution / 2;
                                const cellCenterY = row * this.gridResolution + this.gridResolution / 2;
                                const dist = Math.sqrt(
                                    Math.pow(cellCenterX - bottle.x, 2) +
                                    Math.pow(cellCenterY - bottle.y, 2)
                                );

                                if (dist < bottle.radius + bottleInflation) {
                                    this.grid[row][col].walkable = false;
                                    this.grid[row][col].reason = 'bottle';
                                    cellsMarked++;
                                }
                            }
                        }
                    }
                    totalCells += cellsMarked;
                }

                if (fieldElements.bottles.length > 0) {
                    console.log(`  Bottles inflated: ${totalCells} cells marked for ${fieldElements.bottles.length} bottles`);
                }
            }

            isValidCell(col, row) {
                return row >= 0 && row < this.rows && col >= 0 && col < this.cols;
            }

            worldToGrid(x, y) {
                return {
                    col: Math.floor(x / this.gridResolution),
                    row: Math.floor(y / this.gridResolution)
                };
            }

            gridToWorld(col, row) {
                return {
                    x: col * this.gridResolution + this.gridResolution / 2,
                    y: row * this.gridResolution + this.gridResolution / 2
                };
            }

            findPath(startWorld, goalWorld) {
                if (!this.grid) this.buildGrid();

                let startCell = this.worldToGrid(startWorld.x, startWorld.y);
                let goalCell = this.worldToGrid(goalWorld.x, goalWorld.y);

                // Find nearest walkable if start/goal in obstacle
                if (!this.isValidCell(startCell.col, startCell.row) ||
                    !this.grid[startCell.row][startCell.col].walkable) {
                    startCell = this.findNearestWalkable(startCell.col, startCell.row);
                }

                if (!this.isValidCell(goalCell.col, goalCell.row) ||
                    !this.grid[goalCell.row][goalCell.col].walkable) {
                    goalCell = this.findNearestWalkable(goalCell.col, goalCell.row);
                }

                const openSet = [startCell];
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();

                const key = (c) => `${c.col},${c.row}`;
                const startKey = key(startCell);
                const goalKey = key(goalCell);

                gScore.set(startKey, 0);
                fScore.set(startKey, this.heuristic(startCell, goalCell));

                while (openSet.length > 0) {
                    // Get node with lowest fScore
                    openSet.sort((a, b) => (fScore.get(key(a)) || Infinity) - (fScore.get(key(b)) || Infinity));
                    const current = openSet.shift();
                    const currentKey = key(current);

                    if (currentKey === goalKey) {
                        return this.reconstructPath(cameFrom, current, startWorld, goalWorld);
                    }

                    const neighbors = this.getNeighbors(current.col, current.row);

                    for (const neighbor of neighbors) {
                        const neighborKey = key(neighbor);
                        const tentativeG = gScore.get(currentKey) + this.moveCost(current, neighbor);

                        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
                            cameFrom.set(neighborKey, current);
                            gScore.set(neighborKey, tentativeG);
                            fScore.set(neighborKey, tentativeG + this.heuristic(neighbor, goalCell));

                            if (!openSet.find(n => n.col === neighbor.col && n.row === neighbor.row)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                }

                console.error('No path found from', startWorld, 'to', goalWorld);
                return null;
            }

            findNearestWalkable(col, row) {
                for (let radius = 1; radius < 30; radius++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            if (Math.abs(dx) === radius || Math.abs(dy) === radius) {
                                const checkCol = col + dx;
                                const checkRow = row + dy;
                                if (this.isValidCell(checkCol, checkRow) &&
                                    this.grid[checkRow][checkCol].walkable) {
                                    return { col: checkCol, row: checkRow };
                                }
                            }
                        }
                    }
                }
                return { col, row };
            }

            getNeighbors(col, row) {
                const neighbors = [];
                const directions = [
                    { dc: -1, dr: -1 }, { dc: 0, dr: -1 }, { dc: 1, dr: -1 },
                    { dc: -1, dr: 0 },                     { dc: 1, dr: 0 },
                    { dc: -1, dr: 1 },  { dc: 0, dr: 1 },  { dc: 1, dr: 1 }
                ];

                for (const dir of directions) {
                    const newCol = col + dir.dc;
                    const newRow = row + dir.dr;

                    if (this.isValidCell(newCol, newRow) && this.grid[newRow][newCol].walkable) {
                        // For diagonal, check adjacent cells are walkable
                        if (dir.dc !== 0 && dir.dr !== 0) {
                            const hWalkable = this.grid[row][newCol]?.walkable;
                            const vWalkable = this.grid[newRow][col]?.walkable;
                            if (hWalkable && vWalkable) {
                                neighbors.push({ col: newCol, row: newRow });
                            }
                        } else {
                            neighbors.push({ col: newCol, row: newRow });
                        }
                    }
                }
                return neighbors;
            }

            moveCost(from, to) {
                const isDiagonal = from.col !== to.col && from.row !== to.row;
                return isDiagonal ? 1.414 : 1.0;
            }

            heuristic(a, b) {
                const dx = Math.abs(a.col - b.col);
                const dy = Math.abs(a.row - b.row);
                return Math.sqrt(dx * dx + dy * dy);
            }

            reconstructPath(cameFrom, current, startWorld, goalWorld) {
                const path = [current];
                const key = (c) => `${c.col},${c.row}`;
                let currentKey = key(current);

                while (cameFrom.has(currentKey)) {
                    current = cameFrom.get(currentKey);
                    path.unshift(current);
                    currentKey = key(current);
                }

                // Convert to world coordinates
                let worldPath = path.map(cell => this.gridToWorld(cell.col, cell.row));

                // ALWAYS prepend the actual start position
                worldPath.unshift({ x: startWorld.x, y: startWorld.y });

                // ALWAYS append the actual goal position
                worldPath.push({ x: goalWorld.x, y: goalWorld.y });

                // DO NOT simplify paths here - obstacles may be temporarily cleared
                // during route generation. Simplification will happen in post-processing
                // when obstacles are guaranteed to be present.

                return worldPath;
            }

            // Simplify path by removing unnecessary intermediate waypoints
            // Uses greedy approach: from each point, find furthest visible point
            simplifyPath(path, minClearance) {
                if (path.length <= 2) return path;

                console.log(`simplifyPath called: ${path.length} points, ${fieldElements.obstacles.length} obstacles, clearance=${minClearance}`);

                // If there are no obstacles, we can just go start to end
                if (fieldElements.obstacles.length === 0) {
                    console.log('  NO OBSTACLES - this is the bug!');
                    return [path[0], path[path.length - 1]];
                }

                // Log obstacle positions for debugging
                for (let oi = 0; oi < fieldElements.obstacles.length; oi++) {
                    const obs = fieldElements.obstacles[oi];
                    console.log(`  Obstacle ${oi}: (${obs.x},${obs.y}) size ${obs.width}x${obs.height}`);
                }

                const simplified = [path[0]];
                let i = 0;

                while (i < path.length - 1) {
                    // From current point, find the furthest point we can reach directly
                    // Search from END backwards to find furthest reachable point first
                    let furthest = i + 1;

                    for (let j = path.length - 1; j > i + 1; j--) {
                        // Check if direct path from path[i] to path[j] is clear
                        const from = path[i];
                        const to = path[j];
                        const isClear = this.isSegmentClearOfObstacles(from, to, minClearance);

                        if (isClear) {
                            console.log(`  Shortcut OK: (${from.x.toFixed(0)},${from.y.toFixed(0)}) to (${to.x.toFixed(0)},${to.y.toFixed(0)})`);
                            furthest = j;
                            break; // Found the furthest reachable, use it
                        }
                    }

                    simplified.push(path[furthest]);
                    i = furthest;
                }

                console.log(`  Simplified: ${path.length} -> ${simplified.length} points`);
                return simplified;
            }

            hasLineOfSight(from, to) {
                // Use STRICT obstacle checking against actual obstacle geometry
                // 200mm clearance from robot CENTER to obstacle edge
                const minClearance = 200;
                return this.isSegmentClearOfObstacles(from, to, minClearance);
            }

            // STRICT validation: Check if segment clears ALL obstacles by required margin
            isSegmentClearOfObstacles(from, to, minClearance, debug = false) {
                const segmentLength = distance(from, to);
                // Sample every 2mm for very high precision
                const numSamples = Math.max(100, Math.ceil(segmentLength / 2));

                if (debug) {
                    console.log(`  Checking segment (${from.x.toFixed(0)},${from.y.toFixed(0)}) to (${to.x.toFixed(0)},${to.y.toFixed(0)}), length=${segmentLength.toFixed(0)}mm, ${numSamples} samples`);
                    console.log(`  Against ${fieldElements.obstacles.length} obstacles`);
                }

                for (let i = 0; i <= numSamples; i++) {
                    const t = i / numSamples;
                    const point = {
                        x: from.x + t * (to.x - from.x),
                        y: from.y + t * (to.y - from.y)
                    };

                    // Check against field boundaries
                    const boundaryMargin = this.robotRadius;
                    if (point.x < boundaryMargin || point.x > FIELD_WIDTH - boundaryMargin ||
                        point.y < boundaryMargin || point.y > FIELD_LENGTH - boundaryMargin) {
                        if (debug) console.log(`    FAIL at sample ${i}: boundary violation at (${point.x.toFixed(0)},${point.y.toFixed(0)})`);
                        return false;
                    }

                    // Check against each obstacle - STRICT check
                    for (let oi = 0; oi < fieldElements.obstacles.length; oi++) {
                        const obs = fieldElements.obstacles[oi];
                        // First check if point is INSIDE the obstacle
                        if (point.x >= obs.x && point.x <= obs.x + obs.width &&
                            point.y >= obs.y && point.y <= obs.y + obs.height) {
                            if (debug) console.log(`    FAIL at sample ${i}: point (${point.x.toFixed(0)},${point.y.toFixed(0)}) INSIDE obstacle ${oi + 1}`);
                            return false; // Point is inside obstacle!
                        }

                        // Then check clearance to obstacle edge
                        const clearance = this.pointToRectDistance(point, obs);
                        if (clearance < minClearance) {
                            if (debug) console.log(`    FAIL at sample ${i}: clearance ${clearance.toFixed(0)}mm < ${minClearance}mm to obstacle ${oi + 1} at (${point.x.toFixed(0)},${point.y.toFixed(0)})`);
                            return false;
                        }
                    }
                }
                if (debug) console.log(`    PASS: segment is clear`);
                return true;
            }

            // Calculate distance from point to rectangle edge
            pointToRectDistance(point, rect) {
                const closestX = Math.max(rect.x, Math.min(point.x, rect.x + rect.width));
                const closestY = Math.max(rect.y, Math.min(point.y, rect.y + rect.height));
                const dx = point.x - closestX;
                const dy = point.y - closestY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Validate and fix an entire path - returns a guaranteed safe path
            validateAndFixPath(path, depth = 0) {
                if (!path || path.length < 2) return path;
                if (depth > 5) {
                    console.error('validateAndFixPath: max recursion depth reached');
                    return path;
                }

                // 200mm clearance from robot CENTER to obstacle edge
                const minClearance = 200;
                const fixedPath = [path[0]];
                let hadViolations = false;
                const enableDebug = depth === 0 && path.length > 2; // Debug first pass only

                if (enableDebug) {
                    console.log(`=== validateAndFixPath: checking ${path.length} waypoints, ${fieldElements.obstacles.length} obstacles ===`);
                }

                for (let i = 1; i < path.length; i++) {
                    const from = fixedPath[fixedPath.length - 1];
                    const to = path[i];

                    // Enable debug for first few segments
                    const segmentDebug = enableDebug && i <= 3;
                    const isClear = this.isSegmentClearOfObstacles(from, to, minClearance, segmentDebug);

                    if (isClear) {
                        // Segment is safe, add destination
                        fixedPath.push(to);
                    } else {
                        // Segment violates clearance - must reroute
                        hadViolations = true;
                        console.warn(`Path segment violates ${minClearance}mm clearance from (${from.x.toFixed(0)},${from.y.toFixed(0)}) to (${to.x.toFixed(0)},${to.y.toFixed(0)}), rerouting...`);

                        // Try multiple strategies to find a safe route
                        let reroute = null;

                        // Strategy 1: Use A* with current grid
                        reroute = this.findPathNoSmooth(from, to);

                        // Strategy 2: Rebuild grid with higher inflation and retry
                        if (!reroute || reroute.length < 2) {
                            console.warn('Strategy 1 failed, rebuilding grid with higher inflation...');
                            const oldInflation = this.inflationRadius;
                            this.inflationRadius = Math.min(this.inflationRadius + 50, 350);
                            this.buildGrid();
                            reroute = this.findPathNoSmooth(from, to);
                            this.inflationRadius = oldInflation;
                            this.buildGrid(); // Restore original grid
                        }

                        // Strategy 3: Try intermediate waypoints
                        if (!reroute || reroute.length < 2) {
                            console.warn('Strategy 2 failed, trying intermediate waypoints...');
                            // Find a safe intermediate point
                            const midX = (from.x + to.x) / 2;
                            const midY = (from.y + to.y) / 2;

                            // Try to find a safe point by offsetting perpendicular to the line
                            const dx = to.x - from.x;
                            const dy = to.y - from.y;
                            const len = Math.sqrt(dx * dx + dy * dy);
                            if (len > 0) {
                                const perpX = -dy / len;
                                const perpY = dx / len;

                                for (const offset of [300, -300, 500, -500, 200, -200]) {
                                    const testPoint = {
                                        x: midX + perpX * offset,
                                        y: midY + perpY * offset
                                    };

                                    // Check if this intermediate point is safe
                                    if (testPoint.x > 200 && testPoint.x < FIELD_WIDTH - 200 &&
                                        testPoint.y > 200 && testPoint.y < FIELD_LENGTH - 200) {
                                        const path1 = this.findPathNoSmooth(from, testPoint);
                                        const path2 = this.findPathNoSmooth(testPoint, to);

                                        if (path1 && path1.length >= 2 && path2 && path2.length >= 2) {
                                            reroute = [...path1, ...path2.slice(1)];
                                            console.log(`Found intermediate route via offset ${offset}`);
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        if (reroute && reroute.length > 1) {
                            // Add all intermediate waypoints (skip first as it's 'from')
                            for (let j = 1; j < reroute.length; j++) {
                                fixedPath.push(reroute[j]);
                            }
                        } else {
                            // Last resort: try full A* with rebuilt grid at higher inflation
                            console.error(`Could not find safe reroute, trying full A* with higher inflation...`);

                            // Try with progressively higher inflation
                            let foundPath = null;
                            for (const extraInflation of [50, 100, 150]) {
                                const oldInflation = this.inflationRadius;
                                this.inflationRadius = Math.min(this.inflationRadius + extraInflation, 400);
                                this.buildGrid();
                                foundPath = this.findPath(from, to);
                                this.inflationRadius = oldInflation;
                                this.buildGrid();

                                if (foundPath && foundPath.length >= 2) {
                                    // Verify this path is actually clear
                                    let pathClear = true;
                                    for (let k = 1; k < foundPath.length; k++) {
                                        if (!this.isSegmentClearOfObstacles(foundPath[k-1], foundPath[k], minClearance)) {
                                            pathClear = false;
                                            break;
                                        }
                                    }
                                    if (pathClear) {
                                        console.log(`  Found clear path with inflation +${extraInflation}mm`);
                                        break;
                                    } else {
                                        foundPath = null;
                                    }
                                }
                            }

                            if (foundPath && foundPath.length > 1) {
                                for (let j = 1; j < foundPath.length; j++) {
                                    fixedPath.push(foundPath[j]);
                                }
                            } else {
                                // Absolute last resort: try nearest safe point approach
                                const nearestSafe = this.findNearestSafePoint(to, minClearance);
                                if (nearestSafe) {
                                    const pathToSafe = this.findPathNoSmooth(from, nearestSafe);
                                    if (pathToSafe && pathToSafe.length > 1) {
                                        for (let j = 1; j < pathToSafe.length; j++) {
                                            fixedPath.push(pathToSafe[j]);
                                        }
                                        fixedPath.push(to);
                                    } else {
                                        console.error(`CRITICAL: No safe path exists to ${to.x.toFixed(0)},${to.y.toFixed(0)}`);
                                        fixedPath.push(to); // Mark this segment as problematic
                                    }
                                } else {
                                    console.error(`CRITICAL: No safe path exists to ${to.x.toFixed(0)},${to.y.toFixed(0)}`);
                                    fixedPath.push(to);
                                }
                            }
                        }
                    }
                }

                // If we had violations, validate again to catch any remaining issues
                if (hadViolations && depth < 5) {
                    return this.validateAndFixPath(fixedPath, depth + 1);
                }

                return fixedPath;
            }

            // Find nearest point that has required clearance from all obstacles
            findNearestSafePoint(point, minClearance) {
                for (let radius = 50; radius <= 500; radius += 50) {
                    for (let angle = 0; angle < 360; angle += 30) {
                        const testPoint = {
                            x: point.x + radius * Math.cos(angle * Math.PI / 180),
                            y: point.y + radius * Math.sin(angle * Math.PI / 180)
                        };

                        // Check boundaries
                        if (testPoint.x < minClearance || testPoint.x > FIELD_WIDTH - minClearance ||
                            testPoint.y < minClearance || testPoint.y > FIELD_LENGTH - minClearance) {
                            continue;
                        }

                        // Check all obstacles
                        let isSafe = true;
                        for (const obs of fieldElements.obstacles) {
                            const clearance = this.pointToRectDistance(testPoint, obs);
                            if (clearance < minClearance) {
                                isSafe = false;
                                break;
                            }
                        }

                        if (isSafe) {
                            return testPoint;
                        }
                    }
                }
                return null;
            }

            // Find path without smoothing (for reroutes that need to stay on grid)
            findPathNoSmooth(startWorld, goalWorld) {
                if (!this.grid) this.buildGrid();

                let startCell = this.worldToGrid(startWorld.x, startWorld.y);
                let goalCell = this.worldToGrid(goalWorld.x, goalWorld.y);

                // Find nearest walkable if start/goal in obstacle
                if (!this.isValidCell(startCell.col, startCell.row) ||
                    !this.grid[startCell.row][startCell.col].walkable) {
                    startCell = this.findNearestWalkable(startCell.col, startCell.row);
                }

                if (!this.isValidCell(goalCell.col, goalCell.row) ||
                    !this.grid[goalCell.row][goalCell.col].walkable) {
                    goalCell = this.findNearestWalkable(goalCell.col, goalCell.row);
                }

                const openSet = [startCell];
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();

                const key = (c) => `${c.col},${c.row}`;
                const startKey = key(startCell);
                const goalKey = key(goalCell);

                gScore.set(startKey, 0);
                fScore.set(startKey, this.heuristic(startCell, goalCell));

                while (openSet.length > 0) {
                    openSet.sort((a, b) => (fScore.get(key(a)) || Infinity) - (fScore.get(key(b)) || Infinity));
                    const current = openSet.shift();
                    const currentKey = key(current);

                    if (currentKey === goalKey) {
                        // Reconstruct WITHOUT smoothing
                        const path = [current];
                        let curr = current;
                        let currKey = key(curr);
                        while (cameFrom.has(currKey)) {
                            curr = cameFrom.get(currKey);
                            path.unshift(curr);
                            currKey = key(curr);
                        }
                        // Convert to world coordinates
                        let worldPath = path.map(cell => this.gridToWorld(cell.col, cell.row));
                        worldPath[0] = { x: startWorld.x, y: startWorld.y };
                        worldPath[worldPath.length - 1] = { x: goalWorld.x, y: goalWorld.y };
                        return worldPath; // NO smoothing!
                    }

                    const neighbors = this.getNeighbors(current.col, current.row);

                    for (const neighbor of neighbors) {
                        const neighborKey = key(neighbor);
                        const tentativeG = gScore.get(currentKey) + this.moveCost(current, neighbor);

                        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
                            cameFrom.set(neighborKey, current);
                            gScore.set(neighborKey, tentativeG);
                            fScore.set(neighborKey, tentativeG + this.heuristic(neighbor, goalCell));

                            if (!openSet.find(n => n.col === neighbor.col && n.row === neighbor.row)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                }

                return null;
            }
        }

        // ==================== ROUTE CLEARANCE VALIDATION ====================

        // Calculate distance from a point to the nearest edge of an obstacle
        function calculatePointToObstacleClearance(point, obstacle) {
            // Get obstacle bounds
            const minX = obstacle.x;
            const maxX = obstacle.x + obstacle.width;
            const minY = obstacle.y;
            const maxY = obstacle.y + obstacle.height;

            // Find closest point on obstacle rectangle to the point
            const closestX = Math.max(minX, Math.min(point.x, maxX));
            const closestY = Math.max(minY, Math.min(point.y, maxY));

            // Calculate distance from point to closest point on obstacle
            const dx = point.x - closestX;
            const dy = point.y - closestY;

            return Math.sqrt(dx * dx + dy * dy);
        }

        // Calculate minimum clearance along a path segment
        function calculateSegmentToObstacleClearance(start, end, obstacle) {
            // Sample points along segment and find minimum clearance
            const segmentLength = distance(start, end);
            const numSamples = Math.max(10, Math.ceil(segmentLength / 25)); // Sample every 25mm
            let minClearance = Infinity;

            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const point = {
                    x: start.x + t * (end.x - start.x),
                    y: start.y + t * (end.y - start.y)
                };

                const clearance = calculatePointToObstacleClearance(point, obstacle);
                minClearance = Math.min(minClearance, clearance);
            }

            return minClearance;
        }

        // Validate that a route maintains required clearances from all obstacles
        function validateRouteClearances(route) {
            console.log('Validating route clearances...');

            const violations = [];
            const requiredClearance = MIN_CLEARANCE; // 200mm

            // Collect all waypoints from route segments
            const allWaypoints = [];
            for (const segment of route) {
                if (segment.waypoints) {
                    for (const wp of segment.waypoints) {
                        allWaypoints.push(wp);
                    }
                }
            }

            // Check each waypoint against all obstacles
            for (let i = 0; i < allWaypoints.length; i++) {
                const waypoint = allWaypoints[i];

                for (const obstacle of fieldElements.obstacles) {
                    const clearance = calculatePointToObstacleClearance(waypoint, obstacle);

                    if (clearance < requiredClearance) {
                        violations.push({
                            type: 'waypoint',
                            index: i,
                            position: waypoint,
                            obstacle: obstacle,
                            clearance: clearance,
                            required: requiredClearance,
                            deficit: requiredClearance - clearance
                        });

                        console.warn(`Clearance violation at waypoint ${i}: ${clearance.toFixed(1)}mm < ${requiredClearance}mm`);
                    }
                }
            }

            // Check segments between consecutive waypoints
            for (let i = 0; i < allWaypoints.length - 1; i++) {
                const start = allWaypoints[i];
                const end = allWaypoints[i + 1];

                for (const obstacle of fieldElements.obstacles) {
                    const clearance = calculateSegmentToObstacleClearance(start, end, obstacle);

                    if (clearance < requiredClearance) {
                        violations.push({
                            type: 'segment',
                            startIndex: i,
                            endIndex: i + 1,
                            start: start,
                            end: end,
                            obstacle: obstacle,
                            clearance: clearance,
                            required: requiredClearance
                        });

                        console.warn(`Clearance violation on segment ${i}-${i+1}: ${clearance.toFixed(1)}mm < ${requiredClearance}mm`);
                    }
                }
            }

            if (violations.length > 0) {
                console.error(`Route validation FAILED: ${violations.length} clearance violations`);
                return { valid: false, violations: violations };
            }

            console.log('Route validation PASSED: All clearances maintained');
            return { valid: true, violations: [] };
        }

        // ==================== ROBOT TOUR STRATEGY ENGINE v2 ====================
        // Optimizes for EXPECTED OUTCOME across multiple runs
        // Models: run success probability, risk appetite, obstacle tradeoffs
        // Goal: Maximize P(≥2 successes before ≥2 failures) × score

        class TimeOptimizedRouteGenerator {
            constructor(pathPlanner, targetTime, robotSpeed = 150, turnRate = 90, riskAppetite = 0.35) {
                this.pathPlanner = pathPlanner;
                this.targetTime = targetTime; // Track time in seconds
                this.robotSpeed = robotSpeed; // mm/s
                this.turnRate = turnRate; // degrees/s
                this.riskAppetite = riskAppetite; // 0.0 = ultra-safe, 1.0 = aggressive

                // Risk-dependent margin requirements
                this.getMinMargin = () => {
                    if (this.riskAppetite <= 0.3) return 0.25; // 25% margin for safe
                    if (this.riskAppetite <= 0.6) return 0.15; // 15% margin for balanced
                    return 0.05; // 5% margin for aggressive (they're willing to cut it close)
                };

                // Tournament model: 2 successes needed, 2 failures = elimination
                this.OBSTACLE_REMOVAL_PENALTY = 15; // Fixed penalty for removing obstacles

                // Route classification thresholds
                this.classificationThresholds = {
                    SAFE: { maxTimeRatio: 0.70, maxTurns: 6, maxComplexity: 0.4 },
                    BALANCED: { maxTimeRatio: 0.80, maxTurns: 10, maxComplexity: 0.6 },
                    AGGRESSIVE: { maxTimeRatio: 0.90, maxTurns: 15, maxComplexity: 0.8 },
                    FRAGILE: { maxTimeRatio: 1.0, maxTurns: 999, maxComplexity: 1.0 }
                };

                // === RISK-SCALED SCORING BONUS ===
                // At high risk, scoring becomes THE priority - superlinear growth above 0.6
                this.getScoreWeight = () => {
                    const r = this.riskAppetite;
                    if (r <= 0.6) return 1.0 + r * 0.5; // Linear: 1.0 to 1.3
                    // Superlinear above 0.6: quadratic growth
                    const excess = r - 0.6;
                    return 1.3 + 2.5 * excess * excess * 25; // 1.3 at 0.6, up to ~3.8 at 1.0
                };

                // === MINIMUM SCORING REQUIREMENTS (HARD GATING) ===
                // Risk appetite dictates minimum scoring elements required
                this.getMinScoringElements = (totalAvailable) => {
                    const r = this.riskAppetite;
                    if (r < 0.3) return 0; // No requirement at low risk
                    if (r < 0.6) return 1; // At least 1 scoring element
                    if (r < 0.8) return Math.min(2, totalAvailable); // At least 2
                    return totalAvailable; // Must attempt max feasible at risk >= 0.8
                };

                // === ROUTE TOPOLOGY CLASSIFICATION ===
                this.routeTopologies = {
                    STRAIGHT_SHOT: 'STRAIGHT_SHOT',   // Direct start-to-target, no scoring
                    PERIMETER: 'PERIMETER',           // Hugs edges, minimal scoring
                    ZIGZAG: 'ZIGZAG',                 // Many direction changes
                    SCORING_LOOP: 'SCORING_LOOP',     // Visits scoring elements systematically
                    HYBRID: 'HYBRID'                  // Mixed approach
                };

                // Utility function weights (risk-adjusted dynamically)
                this.weights = {
                    score: 1.0, // Base weight, multiplied by getScoreWeight()
                    time: 0.3 + (1 - this.riskAppetite) * 0.3,
                    turns: 0.5 + (1 - this.riskAppetite) * 0.5,
                    waypoints: 0.1 + (1 - this.riskAppetite) * 0.2,
                    detour: 0.2 + (1 - this.riskAppetite) * 0.2,
                    perimeterHug: 1.0 + (1 - this.riskAppetite) * 1.0,
                    narrowClearance: 0.8 + (1 - this.riskAppetite) * 0.7,
                    successProb: 20 * (1 - this.riskAppetite),
                    // NEW: Trivial route penalty (grows with risk)
                    trivialPenalty: 50 * this.riskAppetite * this.riskAppetite // 0 at risk=0, 50 at risk=1
                };

                // Hard rejection thresholds (risk-adjusted)
                this.hardLimits = {
                    maxTimeRatio: 0.75 + this.riskAppetite * 0.22, // 75-97% based on risk
                    maxTurnsPerGate: Math.round(3 + this.riskAppetite * 4), // 3-7 based on risk
                    maxWaypointsPerGate: Math.round(6 + this.riskAppetite * 8), // 6-14 based on risk
                    maxDetourRatio: 2.0 + this.riskAppetite * 1.5, // 2.0-3.5 based on risk
                    minClearance: 200,
                    minSimplicity: Math.max(0.02, 0.15 - this.riskAppetite * 0.13) // Lower bar at high risk
                };

                // Obstacle annoyance thresholds
                this.obstacleThresholds = {
                    avgDetourRatio: 1.4,
                    maxTimeUsage: 0.85,
                    turnIncrease: 1.5,
                    waypointMultiple: 2.0,
                    scoreEfficiency: 0.70
                };

                // Diagnostic messages for infeasible routes
                this.diagnosticMessages = [];

                // Analysis cache
                this.obstacleAnalysis = null;
                this.strategyPortfolio = null;
            }

            // === ROUTE TOPOLOGY DETECTION ===
            classifyTopology(route, analysis) {
                const gatesVisited = analysis.gatesVisited || 0;
                const totalGates = fieldElements.gates.length;
                const turnCount = analysis.turnCount || 0;
                const perimeterRatio = analysis.perimeterHugDistance / Math.max(analysis.totalDistance, 1);
                const directDistance = analysis.directDistance || 1;
                const totalDistance = analysis.totalDistance || 1;
                const detourRatio = totalDistance / directDistance;

                // STRAIGHT_SHOT: No gates, minimal turns, goes basically direct
                if (gatesVisited === 0 && turnCount <= 2 && detourRatio < 1.2) {
                    return this.routeTopologies.STRAIGHT_SHOT;
                }

                // PERIMETER: High perimeter hugging, may or may not score
                if (perimeterRatio > 0.4) {
                    return this.routeTopologies.PERIMETER;
                }

                // ZIGZAG: Many turns relative to gates visited
                const turnsPerGate = gatesVisited > 0 ? turnCount / gatesVisited : turnCount;
                if (turnsPerGate > 5 || (gatesVisited === 0 && turnCount > 4)) {
                    return this.routeTopologies.ZIGZAG;
                }

                // SCORING_LOOP: Visits most gates efficiently
                if (gatesVisited >= totalGates * 0.7 && detourRatio < 2.0) {
                    return this.routeTopologies.SCORING_LOOP;
                }

                return this.routeTopologies.HYBRID;
            }

            // Check if topology is allowed at current risk level
            isTopologyAllowed(topology, gatesVisited) {
                const r = this.riskAppetite;

                // At risk >= 0.7, STRAIGHT_SHOT routes are BANNED
                if (r >= 0.7 && topology === this.routeTopologies.STRAIGHT_SHOT) {
                    return { allowed: false, reason: 'STRAIGHT_SHOT routes banned at aggressive risk levels' };
                }

                // At risk >= 0.7, PERIMETER routes must score
                if (r >= 0.7 && topology === this.routeTopologies.PERIMETER && gatesVisited === 0) {
                    return { allowed: false, reason: 'PERIMETER routes must score at aggressive risk levels' };
                }

                // At risk >= 0.8, require actual scoring
                if (r >= 0.8 && gatesVisited === 0) {
                    return { allowed: false, reason: 'Zero-scoring routes invalid at risk >= 0.8' };
                }

                return { allowed: true, reason: null };
            }

            // ==================== PROBABILITY MODEL ====================

            // Calculate single-run success probability based on route characteristics
            calculateSuccessProbability(analysis) {
                // Base probability starts at 95%
                let p = 0.95;

                // Time margin impact (most critical factor)
                const marginRatio = analysis.timeMargin / this.targetTime;
                if (marginRatio < 0.10) p *= 0.5;      // Very tight margin
                else if (marginRatio < 0.15) p *= 0.75;
                else if (marginRatio < 0.20) p *= 0.85;
                else if (marginRatio < 0.25) p *= 0.92;
                // Good margin (>25%) doesn't penalize

                // Turn count impact (each turn is failure opportunity)
                const turnsPerGate = analysis.gatesVisited > 0 ?
                    analysis.turnCount / analysis.gatesVisited : analysis.turnCount;
                if (turnsPerGate > 4) p *= Math.pow(0.97, turnsPerGate - 4);

                // Waypoint complexity impact
                const waypointsPerGate = analysis.gatesVisited > 0 ?
                    analysis.waypointCount / analysis.gatesVisited : analysis.waypointCount;
                if (waypointsPerGate > 6) p *= Math.pow(0.98, waypointsPerGate - 6);

                // Narrow clearance impact (each narrow pass is risk)
                p *= Math.pow(0.96, analysis.narrowClearanceCount);

                // Perimeter hugging impact
                const perimeterRatio = analysis.perimeterHugDistance / Math.max(analysis.totalDistance, 1);
                if (perimeterRatio > 0.3) p *= 0.85;
                else if (perimeterRatio > 0.2) p *= 0.92;

                // Detour ratio impact (complex routing = more failure points)
                if (analysis.avgDetourRatio > 1.5) p *= 0.90;
                else if (analysis.avgDetourRatio > 1.3) p *= 0.95;

                // Late-stage precision penalty (harder to recover)
                // Approximated by checking if route has many segments
                if (analysis.gatesVisited > 0) {
                    const segmentComplexity = analysis.waypointCount / analysis.gatesVisited;
                    if (segmentComplexity > 8) p *= 0.92;
                }

                return Math.max(0.1, Math.min(0.99, p)); // Clamp to reasonable range
            }

            // Calculate P(≥2 successes before ≥2 failures) given single-run probability
            // This is a Negative Binomial problem
            calculateTwoSuccessProbability(p) {
                // States: (successes, failures)
                // Win: reach (2, x) where x < 2
                // Lose: reach (x, 2) where x < 2

                // P(win) = P(SS) + P(SFS) + P(FSS)
                // = p² + p(1-p)p + (1-p)pp
                // = p² + 2p²(1-p)
                // = p²(1 + 2(1-p))
                // = p²(3 - 2p)

                return p * p * (3 - 2 * p);
            }

            // Calculate expected outcome for a route
            calculateExpectedOutcome(analysis) {
                const p1 = this.calculateSuccessProbability(analysis);
                const p2 = this.calculateTwoSuccessProbability(p1);
                const score = analysis.totalScore;

                // Risk-weighted expected value
                // At low risk: heavily weight probability
                // At high risk: more weight on raw score
                const expectedValue =
                    (1 - this.riskAppetite) * (p2 * score) +
                    (this.riskAppetite) * score;

                return {
                    singleRunProb: p1,
                    twoSuccessProb: p2,
                    rawScore: score,
                    expectedScore: p2 * score,
                    riskAdjustedValue: expectedValue
                };
            }

            // ==================== ROUTE CLASSIFICATION ====================

            classifyRoute(analysis) {
                const timeRatio = analysis.estimatedTime / this.targetTime;
                const complexity = this.calculateComplexity(analysis);

                if (timeRatio <= this.classificationThresholds.SAFE.maxTimeRatio &&
                    analysis.turnCount <= this.classificationThresholds.SAFE.maxTurns &&
                    complexity <= this.classificationThresholds.SAFE.maxComplexity) {
                    return 'SAFE';
                }

                if (timeRatio <= this.classificationThresholds.BALANCED.maxTimeRatio &&
                    analysis.turnCount <= this.classificationThresholds.BALANCED.maxTurns &&
                    complexity <= this.classificationThresholds.BALANCED.maxComplexity) {
                    return 'BALANCED';
                }

                if (timeRatio <= this.classificationThresholds.AGGRESSIVE.maxTimeRatio &&
                    analysis.turnCount <= this.classificationThresholds.AGGRESSIVE.maxTurns &&
                    complexity <= this.classificationThresholds.AGGRESSIVE.maxComplexity) {
                    return 'AGGRESSIVE';
                }

                return 'FRAGILE';
            }

            // Calculate route complexity score (0-1, lower is simpler)
            calculateComplexity(analysis) {
                const turnFactor = Math.min(1, analysis.turnCount / 20);
                const waypointFactor = Math.min(1, analysis.waypointCount / 40);
                const detourFactor = Math.min(1, (analysis.avgDetourRatio - 1) / 1.5);
                const narrowFactor = Math.min(1, analysis.narrowClearanceCount / 10);

                return (turnFactor + waypointFactor + detourFactor + narrowFactor) / 4;
            }

            // Calculate simplicity score (inverse of complexity)
            calculateSimplicity(analysis) {
                return 1 / (1 + analysis.turnCount * 0.1 + analysis.waypointCount * 0.05);
            }

            // Check if route class is allowed at current risk level
            isClassAllowed(routeClass) {
                if (this.riskAppetite >= 0.7) return true; // Allow all at high risk

                if (this.riskAppetite <= 0.3) {
                    return routeClass === 'SAFE' || routeClass === 'BALANCED';
                }

                return routeClass !== 'FRAGILE';
            }

            // Calculate time for a path including turns
            calculatePathTime(path) {
                if (!path || path.length < 2) return 0;

                let totalTime = 0;
                let currentHeading = null;

                for (let i = 1; i < path.length; i++) {
                    const prev = path[i - 1];
                    const curr = path[i];

                    // Calculate distance
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Calculate heading to this point
                    const heading = Math.atan2(dy, dx) * 180 / Math.PI;

                    // Add turn time if we have a previous heading
                    if (currentHeading !== null) {
                        let turnAngle = Math.abs(heading - currentHeading);
                        if (turnAngle > 180) turnAngle = 360 - turnAngle;
                        totalTime += turnAngle / this.turnRate;
                    }

                    // Add drive time
                    totalTime += dist / this.robotSpeed;
                    currentHeading = heading;
                }

                return totalTime;
            }

            // Count total turns in a path (turns > 15 degrees)
            countTurns(path) {
                if (!path || path.length < 3) return 0;

                let turns = 0;
                let currentHeading = null;

                for (let i = 1; i < path.length; i++) {
                    const prev = path[i - 1];
                    const curr = path[i];
                    const heading = Math.atan2(curr.y - prev.y, curr.x - prev.x) * 180 / Math.PI;

                    if (currentHeading !== null) {
                        let turnAngle = Math.abs(heading - currentHeading);
                        if (turnAngle > 180) turnAngle = 360 - turnAngle;
                        if (turnAngle > 15) turns++; // Only count significant turns
                    }
                    currentHeading = heading;
                }

                return turns;
            }

            // Check if path hugs perimeter (too close to field edges)
            calculatePerimeterHugScore(path) {
                if (!path || path.length < 2) return 0;

                const perimeterThreshold = 250; // mm from edge
                let hugDistance = 0;

                for (let i = 1; i < path.length; i++) {
                    const prev = path[i - 1];
                    const curr = path[i];
                    const segmentLength = distance(prev, curr);

                    // Check if segment is near perimeter
                    const avgX = (prev.x + curr.x) / 2;
                    const avgY = (prev.y + curr.y) / 2;

                    const distToEdge = Math.min(
                        avgX, FIELD_WIDTH - avgX,
                        avgY, FIELD_LENGTH - avgY
                    );

                    if (distToEdge < perimeterThreshold) {
                        hugDistance += segmentLength;
                    }
                }

                return hugDistance;
            }

            // Calculate detour ratio for a segment
            calculateDetourRatio(from, to, actualPath) {
                const directDist = distance(from, to);
                if (directDist < 50) return 1.0; // Avoid division issues

                let actualDist = 0;
                for (let i = 1; i < actualPath.length; i++) {
                    actualDist += distance(actualPath[i-1], actualPath[i]);
                }

                return actualDist / directDist;
            }

            // Check for narrow clearances along path
            countNarrowClearances(path) {
                if (!path || path.length < 2) return 0;

                const narrowThreshold = 250; // mm - just above minimum
                let narrowCount = 0;

                for (let i = 0; i < path.length; i++) {
                    const point = path[i];

                    for (const obs of fieldElements.obstacles) {
                        const clearance = this.pathPlanner.pointToRectDistance(point, obs);
                        if (clearance < narrowThreshold && clearance >= this.hardLimits.minClearance) {
                            narrowCount++;
                            break; // Count each waypoint only once
                        }
                    }
                }

                return narrowCount;
            }

            // ==================== TOURNAMENT-AWARE ROUTE EVALUATION ====================

            // Comprehensive route analysis for tournament-realistic scoring
            analyzeRoute(route) {
                const analysis = {
                    gatesVisited: 0,
                    bottlesPushed: 0,
                    totalScore: 0,
                    estimatedTime: 0,
                    turnCount: 0,
                    waypointCount: 0,
                    totalDistance: 0,
                    directDistance: 0,
                    avgDetourRatio: 1.0,
                    maxDetourRatio: 1.0,
                    perimeterHugDistance: 0,
                    narrowClearanceCount: 0,
                    timeRatio: 0,
                    timeMargin: 0,
                    utility: 0,
                    isValid: true,
                    rejectionReasons: []
                };

                const allWaypoints = [];
                let prevPos = null;

                for (const segment of route) {
                    if (segment.type === 'gate') analysis.gatesVisited++;
                    if (segment.type === 'bottle_push') analysis.bottlesPushed++;

                    if (segment.waypoints && segment.waypoints.length > 0) {
                        allWaypoints.push(...segment.waypoints);

                        // Calculate segment detour ratio
                        if (prevPos && segment.waypoints.length >= 2) {
                            const segmentEnd = segment.waypoints[segment.waypoints.length - 1];
                            const detour = this.calculateDetourRatio(prevPos, segmentEnd, segment.waypoints);
                            analysis.maxDetourRatio = Math.max(analysis.maxDetourRatio, detour);
                        }

                        prevPos = segment.waypoints[segment.waypoints.length - 1];
                    }

                    if (segment.dist) analysis.totalDistance += segment.dist;
                }

                // Calculate metrics
                analysis.totalScore = analysis.gatesVisited * 10 + analysis.bottlesPushed * 15;
                analysis.estimatedTime = this.calculatePathTime(allWaypoints);
                analysis.turnCount = this.countTurns(allWaypoints);
                analysis.waypointCount = allWaypoints.length;
                analysis.perimeterHugDistance = this.calculatePerimeterHugScore(allWaypoints);
                analysis.narrowClearanceCount = this.countNarrowClearances(allWaypoints);

                // Calculate direct distance (start to each gate to target)
                if (route.length >= 2) {
                    for (let i = 1; i < route.length; i++) {
                        const from = route[i-1];
                        const to = route[i];
                        analysis.directDistance += distance(
                            { x: from.x, y: from.y },
                            { x: to.x, y: to.y }
                        );
                    }
                }

                analysis.avgDetourRatio = analysis.directDistance > 0 ?
                    analysis.totalDistance / analysis.directDistance : 1.0;

                // Time analysis
                analysis.timeRatio = analysis.estimatedTime / this.targetTime;
                analysis.timeMargin = this.targetTime - analysis.estimatedTime;

                // Calculate simplicity and complexity
                analysis.simplicity = this.calculateSimplicity(analysis);
                analysis.complexity = this.calculateComplexity(analysis);

                // Hard constraint checks - ONLY apply critical ones
                // Most constraints are now soft (affect utility) rather than hard (reject route)

                // HARD: Route must not exceed time limit (with small buffer)
                if (analysis.timeRatio > 0.98) { // Only reject if over 98% of time
                    analysis.isValid = false;
                    analysis.rejectionReasons.push(`Time ${(analysis.timeRatio * 100).toFixed(0)}% exceeds limit`);
                }

                // Classify route (risk level)
                analysis.classification = this.classifyRoute(analysis);

                // === TOPOLOGY CLASSIFICATION ===
                analysis.topology = this.classifyTopology(route, analysis);

                // HARD: At high risk, ban trivial routes
                if (this.riskAppetite >= 0.7) {
                    const topologyCheck = this.isTopologyAllowed(analysis.topology, analysis.gatesVisited);
                    if (!topologyCheck.allowed) {
                        analysis.isValid = false;
                        analysis.rejectionReasons.push(topologyCheck.reason);
                    }
                }

                // HARD: Minimum scoring constraints at high risk only
                const totalAvailableGates = fieldElements.gates.length;
                const minRequired = this.getMinScoringElements(totalAvailableGates);

                if (this.riskAppetite >= 0.6 && analysis.gatesVisited < minRequired) {
                    analysis.isValid = false;
                    analysis.rejectionReasons.push(
                        `Insufficient scoring: ${analysis.gatesVisited}/${minRequired} required at risk ${this.riskAppetite.toFixed(2)}`
                    );
                }

                // Calculate probabilities and expected outcome
                const outcome = this.calculateExpectedOutcome(analysis);
                analysis.singleRunProb = outcome.singleRunProb;
                analysis.twoSuccessProb = outcome.twoSuccessProb;
                analysis.expectedScore = outcome.expectedScore;
                analysis.riskAdjustedValue = outcome.riskAdjustedValue;

                // Calculate utility (higher is better) - now includes probability
                analysis.utility = this.calculateUtility(analysis);

                return analysis;
            }

            // Tournament-realistic utility function
            // KEY CHANGE: At high risk, actively SEEK scoring, not just tolerate complexity
            // Implements: utility = scoreWeight × S(r) × probabilityFactor − complexityPenalties + bonuses
            calculateUtility(analysis) {
                if (!analysis.isValid) return -Infinity;

                const w = this.weights;
                const risk = this.riskAppetite;
                const rawScore = analysis.totalScore;
                const totalAvailableGates = fieldElements.gates.length;

                // === SCORING COMPONENT (risk-scaled) ===
                // At high risk, scoring weight grows SUPERLINEARLY
                const scoreWeight = this.getScoreWeight();

                // Probability factors
                const p2 = analysis.twoSuccessProb || this.calculateTwoSuccessProbability(
                    this.calculateSuccessProbability(analysis)
                );

                // === EXPECTED VALUE OVER MULTIPLE ATTEMPTS ===
                // At high risk, optimize for expected MAX score over N attempts
                // E[max] ≈ score × (1 - (1-p)^N) for N attempts
                // With 3 attempts before elimination: higher weight on raw score
                const attemptsBeforeElimination = 3; // Can fail once and still win
                const pAtLeastOneSuccess = 1 - Math.pow(1 - analysis.singleRunProb, attemptsBeforeElimination);

                // Risk-weighted expected value
                // Low risk: weight P(2 wins) heavily
                // High risk: weight expected max over attempts
                let scoreComponent;
                if (risk < 0.5) {
                    // Conservative: expected value with P(2 wins)
                    scoreComponent = scoreWeight * rawScore * p2;
                } else {
                    // Aggressive: expected max over multiple attempts
                    // Blend between P(2wins) and P(at least 1 success)
                    const aggressiveBlend = (risk - 0.5) * 2; // 0 at risk=0.5, 1 at risk=1.0
                    const conservativeExpected = p2 * rawScore;
                    const aggressiveExpected = pAtLeastOneSuccess * rawScore;
                    scoreComponent = scoreWeight * ((1 - aggressiveBlend) * conservativeExpected + aggressiveBlend * aggressiveExpected);
                }

                let utility = scoreComponent;

                // === TRIVIAL ROUTE PENALTY (grows with risk) ===
                // At high risk, routes that don't score are HEAVILY penalized
                const topology = analysis.topology || this.classifyTopology([], analysis);

                if (topology === this.routeTopologies.STRAIGHT_SHOT) {
                    // Straight shots get massive penalty at high risk
                    utility -= w.trivialPenalty * 3; // Triple penalty for straight shots
                }

                if (topology === this.routeTopologies.PERIMETER && analysis.gatesVisited === 0) {
                    // Non-scoring perimeter routes penalized at high risk
                    utility -= w.trivialPenalty * 2;
                }

                // === LOW SCORING PENALTY AT HIGH RISK ===
                // At risk >= 0.6, routes that ignore scoring elements are penalized
                if (risk >= 0.6 && totalAvailableGates > 0) {
                    const scoringRatio = analysis.gatesVisited / totalAvailableGates;
                    if (scoringRatio < 0.5) {
                        // Penalty for visiting less than half the gates
                        const underscorePenalty = (0.5 - scoringRatio) * 100 * risk;
                        utility -= underscorePenalty;
                    }
                }

                // === COMPLEXITY PENALTIES (scaled by risk) ===
                // Aggressive players accept more complexity, but still prefer simpler routes
                const complexityScale = 1 - (risk * 0.6); // 1.0 at risk=0, 0.4 at risk=1

                utility -= w.turns * analysis.turnCount * complexityScale;
                utility -= w.waypoints * analysis.waypointCount * complexityScale;

                const detourPenalty = Math.max(0, analysis.avgDetourRatio - 1.0);
                utility -= w.detour * detourPenalty * analysis.totalDistance / 100 * complexityScale;

                utility -= w.perimeterHug * analysis.perimeterHugDistance / 100 * complexityScale;
                utility -= w.narrowClearance * analysis.narrowClearanceCount * complexityScale;

                // === TIME MARGIN BONUS ===
                // Safe players value margin highly, aggressive players less so
                if (analysis.timeMargin > 0) {
                    const marginBonus = Math.min(analysis.timeMargin, 15);
                    utility += marginBonus * (1.5 - risk);
                }

                // === SIMPLICITY BIAS (applies AFTER scoring goals met) ===
                // Even aggressive routes should prefer fewer turns/decisions
                const simplicity = analysis.simplicity || 1 / (1 + analysis.turnCount + analysis.waypointCount);

                // Simplicity bonus only applies if scoring goals are met
                const minRequired = this.getMinScoringElements(totalAvailableGates);
                if (analysis.gatesVisited >= minRequired) {
                    // Full simplicity bonus when scoring goal met
                    utility += simplicity * 25 * (1 - risk * 0.5);
                } else {
                    // Reduced simplicity bonus if under-scoring
                    utility += simplicity * 5;
                }

                // === CLASSIFICATION ALIGNMENT BONUS ===
                const classification = analysis.classification || this.classifyRoute(analysis);
                const classificationBonus = this.getClassificationAlignmentBonus(classification, risk);
                utility += classificationBonus;

                // === SCORING EFFICIENCY BONUS AT HIGH RISK ===
                // Reward routes that score efficiently (points per second)
                if (risk >= 0.5 && analysis.estimatedTime > 0) {
                    const efficiency = rawScore / analysis.estimatedTime;
                    utility += efficiency * 5 * risk; // More bonus at higher risk
                }

                return utility;
            }

            // Bonus for routes that align with player's risk appetite
            getClassificationAlignmentBonus(classification, risk) {
                let preferredClass;
                if (risk <= 0.25) preferredClass = 'SAFE';
                else if (risk <= 0.5) preferredClass = 'BALANCED';
                else if (risk <= 0.75) preferredClass = 'AGGRESSIVE';
                else preferredClass = 'FRAGILE';

                const classOrder = ['SAFE', 'BALANCED', 'AGGRESSIVE', 'FRAGILE'];
                const prefIdx = classOrder.indexOf(preferredClass);
                const actualIdx = classOrder.indexOf(classification);
                const dist = Math.abs(prefIdx - actualIdx);

                // At high risk, also penalize being TOO safe
                if (risk >= 0.7 && classification === 'SAFE') {
                    return -15; // Penalty for overly conservative routes at high risk
                }

                return (2 - dist) * 5;
            }

            // Generate optimized route with tournament-aware selection
            // Now generates a full strategy portfolio with obstacle comparison
            generateOptimizedRoute(start, gates, target, bottles = []) {
                if (!this.pathPlanner.grid) this.pathPlanner.buildGrid();

                // Clear diagnostic messages
                this.diagnosticMessages = [];

                const minRequired = this.getMinScoringElements(gates.length);
                const riskLabel = this.riskAppetite < 0.3 ? 'SAFE' :
                                  this.riskAppetite < 0.6 ? 'BALANCED' :
                                  this.riskAppetite < 0.8 ? 'AGGRESSIVE' : 'MAXIMUM';

                console.log('\n=== STRATEGY ENGINE v3 - RISK-AWARE ROUTE OPTIMIZATION ===');
                console.log(`Track time: ${this.targetTime}s | Risk: ${this.riskAppetite.toFixed(2)} (${riskLabel})`);
                console.log(`Score weight: ${this.getScoreWeight().toFixed(2)}x | Min scoring elements: ${minRequired}/${gates.length}`);
                console.log(`Min margin: ${(this.getMinMargin() * 100).toFixed(0)}%`);

                // Analyze obstacle impact first
                this.obstacleAnalysis = this.analyzeObstacleImpact(start, gates, target);

                const gateCount = gates.length;

                // Generate candidate routes with different strategies
                const candidates = [];
                const rejectedCandidates = []; // Track why routes were rejected

                // === WITH OBSTACLES STRATEGIES ===
                console.log('\n--- WITH OBSTACLES ---');

                // Strategy 1: Visit all gates (if feasible)
                if (gateCount <= 6) {
                    const allGatesRoute = this.bruteForceOptimal(start, gates, target, bottles);
                    if (allGatesRoute) {
                        const analysis = this.analyzeRoute(allGatesRoute);
                        const candidate = { route: allGatesRoute, analysis, strategy: 'ALL_GATES', withObstacles: true };
                        if (analysis.isValid) {
                            candidates.push(candidate);
                        } else {
                            rejectedCandidates.push(candidate);
                        }
                    }
                } else {
                    const heuristicRoute = this.heuristicOptimal(start, gates, target, bottles);
                    if (heuristicRoute) {
                        const analysis = this.analyzeRoute(heuristicRoute);
                        const candidate = { route: heuristicRoute, analysis, strategy: 'HEURISTIC_ALL', withObstacles: true };
                        if (analysis.isValid) {
                            candidates.push(candidate);
                        } else {
                            rejectedCandidates.push(candidate);
                        }
                    }
                }

                // Strategy 2: Visit fewer gates if all-gates is too risky
                // BUT: At high risk, we still prefer more gates even if riskier
                if (gateCount > 2) {
                    for (let skipCount = 1; skipCount <= Math.min(2, gateCount - 2); skipCount++) {
                        const reducedGates = this.selectBestGateSubset(start, gates, target, gateCount - skipCount);
                        const reducedRoute = this.bruteForceOptimal(start, reducedGates, target, bottles);
                        if (reducedRoute) {
                            const analysis = this.analyzeRoute(reducedRoute);
                            const candidate = {
                                route: reducedRoute,
                                analysis,
                                strategy: `SKIP_${skipCount}_GATES`,
                                withObstacles: true
                            };
                            if (analysis.isValid) {
                                candidates.push(candidate);
                            } else {
                                rejectedCandidates.push(candidate);
                            }
                        }
                    }
                }

                // === WITHOUT OBSTACLES STRATEGIES (theoretical) ===
                if (this.obstacleAnalysis.hasObstacles) {
                    console.log('\n--- WITHOUT OBSTACLES (15-point penalty) ---');
                    const noObstacleRoutes = this.generateNoObstacleRoutes(start, gates, target, bottles);
                    for (const candidate of noObstacleRoutes) {
                        candidate.analysis.totalScore -= this.OBSTACLE_REMOVAL_PENALTY;
                        candidate.analysis.obstacleRemovalPenalty = this.OBSTACLE_REMOVAL_PENALTY;
                        candidate.analysis.utility = this.calculateUtility(candidate.analysis);
                        candidate.withObstacles = false;
                        if (candidate.analysis.isValid) {
                            candidates.push(candidate);
                        } else {
                            rejectedCandidates.push(candidate);
                        }
                    }
                }

                // === BUILD STRATEGY PORTFOLIO ===
                this.strategyPortfolio = this.buildStrategyPortfolio(candidates);

                // Select best valid candidate based on risk appetite
                let bestCandidate = null;
                let bestUtility = -Infinity;

                console.log('\n--- All Candidate Routes ---');
                for (const candidate of candidates) {
                    const a = candidate.analysis;
                    const obstacleTag = candidate.withObstacles ? '[OBS]' : '[NO-OBS]';
                    const topologyTag = a.topology ? `[${a.topology}]` : '';
                    console.log(`${obstacleTag}${topologyTag} ${candidate.strategy}: ` +
                        `score=${a.totalScore}, time=${a.estimatedTime.toFixed(1)}s, ` +
                        `gates=${a.gatesVisited}/${gateCount}, ` +
                        `P(2wins)=${(a.twoSuccessProb * 100).toFixed(0)}%, ` +
                        `utility=${a.utility.toFixed(1)}, valid=${a.isValid}`);

                    if (a.isValid && a.utility > bestUtility) {
                        bestUtility = a.utility;
                        bestCandidate = candidate;
                    }
                }

                // Log rejected routes for diagnostics
                if (rejectedCandidates.length > 0) {
                    console.log('\n--- Rejected Routes ---');
                    for (const candidate of rejectedCandidates) {
                        const a = candidate.analysis;
                        console.log(`REJECTED ${candidate.strategy}: ${a.rejectionReasons.join(', ')}`);
                    }
                }

                // === HANDLE NO VALID ROUTES ===
                if (!bestCandidate) {
                    // Collect diagnostic information
                    const allRejectionReasons = new Set();
                    for (const c of rejectedCandidates) {
                        for (const reason of c.analysis.rejectionReasons) {
                            allRejectionReasons.add(reason);
                        }
                    }

                    // Check specific failure modes
                    const hasTimeFailure = [...allRejectionReasons].some(r => r.includes('Time') || r.includes('Margin'));
                    const hasScoringFailure = [...allRejectionReasons].some(r => r.includes('scoring') || r.includes('STRAIGHT_SHOT'));
                    const hasComplexityFailure = [...allRejectionReasons].some(r => r.includes('complex') || r.includes('turns'));

                    // Generate structured diagnostic message
                    if (this.riskAppetite >= 0.8 && hasScoringFailure) {
                        this.diagnosticMessages.push({
                            type: 'AGGRESSIVE_INFEASIBLE',
                            message: 'Aggressive scoring infeasible under current obstacle configuration.',
                            details: 'All scoring routes exceed time limits or fail complexity constraints.',
                            recommendation: 'Consider: (1) Remove or reposition obstacles, (2) Reduce risk appetite, (3) Accept lower score'
                        });
                    } else if (hasTimeFailure) {
                        this.diagnosticMessages.push({
                            type: 'TIME_EXCEEDED',
                            message: 'All routes exceed time budget.',
                            details: `Required margin: ${(this.getMinMargin() * 100).toFixed(0)}%`,
                            recommendation: 'Obstacle layout blocks viable scoring paths. Consider removing or repositioning obstacles.'
                        });
                    } else if (hasComplexityFailure) {
                        this.diagnosticMessages.push({
                            type: 'COMPLEXITY_EXCEEDED',
                            message: 'All routes too complex for reliable execution.',
                            details: 'Obstacle avoidance creates excessive turns/waypoints.',
                            recommendation: 'Consider removing blocking obstacles or reducing risk appetite.'
                        });
                    }

                    // At high risk, refuse to return trivial route - return nothing with explanation
                    if (this.riskAppetite >= 0.7 && candidates.length === 0) {
                        console.error('\n!!! NO ROUTE GENERATED !!!');
                        console.error('At aggressive risk levels, trivial/zero-scoring routes are not acceptable.');
                        for (const msg of this.diagnosticMessages) {
                            console.error(`[${msg.type}] ${msg.message}`);
                            console.error(`  ${msg.recommendation}`);
                        }

                        // Return empty route with diagnostic info attached
                        const emptyRoute = [];
                        emptyRoute.diagnosticMessages = this.diagnosticMessages;
                        emptyRoute.noValidRoute = true;
                        emptyRoute.rejectedCandidates = rejectedCandidates;
                        return emptyRoute;
                    }

                    // At lower risk, fall back to best invalid option
                    console.warn('\nNo valid route found. Selecting least-bad option.');
                    for (const candidate of [...candidates, ...rejectedCandidates]) {
                        const u = candidate.analysis.utility === -Infinity ? -1000000 : candidate.analysis.utility;
                        if (u > bestUtility) {
                            bestUtility = u;
                            bestCandidate = candidate;
                        }
                    }
                }

                if (bestCandidate) {
                    console.log(`\n=== SELECTED: ${bestCandidate.strategy} ===`);
                    this.logStrategyReport(bestCandidate, this.strategyPortfolio);

                    // Attach analysis and portfolio to route for output
                    bestCandidate.route.routeAnalysis = bestCandidate.analysis;
                    bestCandidate.route.selectedStrategy = bestCandidate.strategy;
                    bestCandidate.route.obstacleAnalysis = this.obstacleAnalysis;
                    bestCandidate.route.strategyPortfolio = this.strategyPortfolio;
                    bestCandidate.route.withObstacles = bestCandidate.withObstacles;
                    bestCandidate.route.diagnosticMessages = this.diagnosticMessages;

                    return bestCandidate.route;
                }

                console.error('Failed to generate any route');
                const emptyRoute = [];
                emptyRoute.diagnosticMessages = this.diagnosticMessages;
                emptyRoute.noValidRoute = true;
                return emptyRoute;
            }

            // Generate theoretical routes as if obstacles were removed
            generateNoObstacleRoutes(start, gates, target, bottles) {
                const candidates = [];
                const gateCount = gates.length;

                // Temporarily disable obstacle checking
                const originalObstacles = [...fieldElements.obstacles];
                const savedObstacles = fieldElements.obstacles;
                fieldElements.obstacles = [];
                this.pathPlanner.buildGrid(); // Rebuild grid without obstacles

                try {
                    // All gates route without obstacles
                    if (gateCount <= 6) {
                        const allGatesRoute = this.bruteForceOptimal(start, gates, target, bottles);
                        if (allGatesRoute) {
                            const analysis = this.analyzeRoute(allGatesRoute);
                            candidates.push({ route: allGatesRoute, analysis, strategy: 'NO_OBS_ALL_GATES' });
                        }
                    } else {
                        const heuristicRoute = this.heuristicOptimal(start, gates, target, bottles);
                        if (heuristicRoute) {
                            const analysis = this.analyzeRoute(heuristicRoute);
                            candidates.push({ route: heuristicRoute, analysis, strategy: 'NO_OBS_HEURISTIC' });
                        }
                    }
                } finally {
                    // Restore obstacles
                    fieldElements.obstacles = savedObstacles;
                    this.pathPlanner.buildGrid(); // Rebuild grid with obstacles
                }

                return candidates;
            }

            // Build strategy portfolio with routes categorized by risk level
            buildStrategyPortfolio(candidates) {
                const portfolio = {
                    ultraSafe: null,    // Route A: highest P(2 wins), may skip gates
                    balanced: null,     // Route B: best expected value
                    aggressive: null,   // Route C: highest raw score if it works
                    selected: null,
                    comparison: {
                        withObstacles: [],
                        withoutObstacles: []
                    }
                };

                // Separate by obstacle status
                for (const c of candidates) {
                    if (c.withObstacles) {
                        portfolio.comparison.withObstacles.push(c);
                    } else {
                        portfolio.comparison.withoutObstacles.push(c);
                    }
                }

                // Find ultra-safe: highest P(2 successes)
                let bestSafeP2 = 0;
                for (const c of candidates) {
                    if (c.analysis.isValid && c.analysis.twoSuccessProb > bestSafeP2) {
                        // Only consider if classification is SAFE or BALANCED
                        if (c.analysis.classification === 'SAFE' || c.analysis.classification === 'BALANCED') {
                            bestSafeP2 = c.analysis.twoSuccessProb;
                            portfolio.ultraSafe = c;
                        }
                    }
                }

                // Find balanced: best expected score (P2 × score)
                let bestExpected = 0;
                for (const c of candidates) {
                    if (c.analysis.isValid) {
                        const expected = c.analysis.twoSuccessProb * c.analysis.totalScore;
                        if (expected > bestExpected) {
                            bestExpected = expected;
                            portfolio.balanced = c;
                        }
                    }
                }

                // Find aggressive: highest raw score among valid routes
                let bestScore = 0;
                for (const c of candidates) {
                    if (c.analysis.isValid && c.analysis.totalScore > bestScore) {
                        bestScore = c.analysis.totalScore;
                        portfolio.aggressive = c;
                    }
                }

                return portfolio;
            }

            // Log detailed strategy report to console
            logStrategyReport(selected, portfolio) {
                const a = selected.analysis;

                console.log('\n╔═══════════════════════════════════════════════════════════╗');
                console.log('║              STRATEGY SUMMARY REPORT                       ║');
                console.log('╠═══════════════════════════════════════════════════════════╣');
                console.log(`║ Selected Strategy: ${selected.strategy.padEnd(38)}║`);
                console.log(`║ Obstacle Mode: ${(selected.withObstacles ? 'WITH OBSTACLES' : 'OBSTACLES REMOVED (-15pts)').padEnd(42)}║`);
                console.log('╠═══════════════════════════════════════════════════════════╣');
                console.log('║ EXECUTION METRICS                                          ║');
                console.log(`║   Raw Score:          ${a.totalScore.toString().padEnd(35)}║`);
                console.log(`║   Estimated Time:     ${a.estimatedTime.toFixed(1)}s / ${this.targetTime}s (${(a.timeRatio * 100).toFixed(0)}%)`.padEnd(60) + '║');
                console.log(`║   Time Margin:        ${a.timeMargin.toFixed(1)}s`.padEnd(60) + '║');
                console.log(`║   Turn Count:         ${a.turnCount}`.padEnd(60) + '║');
                console.log(`║   Waypoint Count:     ${a.waypointCount}`.padEnd(60) + '║');
                console.log(`║   Simplicity Score:   ${a.simplicity.toFixed(3)}`.padEnd(60) + '║');
                console.log('╠═══════════════════════════════════════════════════════════╣');
                console.log('║ PROBABILITY ANALYSIS                                       ║');
                console.log(`║   P(single success):  ${(a.singleRunProb * 100).toFixed(1)}%`.padEnd(60) + '║');
                console.log(`║   P(2+ wins in 3):    ${(a.twoSuccessProb * 100).toFixed(1)}%`.padEnd(60) + '║');
                console.log(`║   Expected Score:     ${a.expectedScore.toFixed(1)} pts`.padEnd(60) + '║');
                console.log(`║   Classification:     ${a.classification}`.padEnd(60) + '║');
                console.log('╠═══════════════════════════════════════════════════════════╣');
                console.log('║ STRATEGY PORTFOLIO                                         ║');

                if (portfolio.ultraSafe) {
                    const s = portfolio.ultraSafe.analysis;
                    console.log(`║   Route A (Safe):     ${s.totalScore}pts @ ${(s.twoSuccessProb * 100).toFixed(0)}% → E[${(s.twoSuccessProb * s.totalScore).toFixed(0)}]`.padEnd(60) + '║');
                }
                if (portfolio.balanced) {
                    const b = portfolio.balanced.analysis;
                    console.log(`║   Route B (Balanced): ${b.totalScore}pts @ ${(b.twoSuccessProb * 100).toFixed(0)}% → E[${(b.twoSuccessProb * b.totalScore).toFixed(0)}]`.padEnd(60) + '║');
                }
                if (portfolio.aggressive) {
                    const g = portfolio.aggressive.analysis;
                    console.log(`║   Route C (Aggress.): ${g.totalScore}pts @ ${(g.twoSuccessProb * 100).toFixed(0)}% → E[${(g.twoSuccessProb * g.totalScore).toFixed(0)}]`.padEnd(60) + '║');
                }

                if (portfolio.comparison.withoutObstacles.length > 0) {
                    console.log('╠═══════════════════════════════════════════════════════════╣');
                    console.log('║ OBSTACLE REMOVAL ANALYSIS                                  ║');
                    const withObs = portfolio.comparison.withObstacles[0]?.analysis;
                    const noObs = portfolio.comparison.withoutObstacles[0]?.analysis;
                    if (withObs && noObs) {
                        const timeSaved = withObs.estimatedTime - noObs.estimatedTime;
                        const turnsSaved = withObs.turnCount - noObs.turnCount;
                        const probGain = noObs.twoSuccessProb - withObs.twoSuccessProb;
                        console.log(`║   Time saved:         ${timeSaved.toFixed(1)}s`.padEnd(60) + '║');
                        console.log(`║   Turns reduced:      ${turnsSaved}`.padEnd(60) + '║');
                        console.log(`║   P(2wins) change:    ${probGain >= 0 ? '+' : ''}${(probGain * 100).toFixed(1)}%`.padEnd(60) + '║');
                        console.log(`║   Recommendation:     ${this.obstacleAnalysis.recommendation}`.padEnd(60) + '║');
                    }
                }

                console.log('╚═══════════════════════════════════════════════════════════╝');
            }

            // Select best subset of gates to visit
            selectBestGateSubset(start, gates, target, count) {
                if (count >= gates.length) return gates;

                // Score each gate by efficiency (points vs detour cost)
                const gateScores = gates.map((gate, idx) => {
                    const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                    const directDist = distance(start, gateCenter) + distance(gateCenter, target);

                    // Estimate detour by checking if path needs A*
                    const pathToGate = this.pathPlanner.findPath(start, gateCenter);
                    let actualDist = directDist;
                    if (pathToGate && pathToGate.length > 1) {
                        actualDist = 0;
                        for (let i = 1; i < pathToGate.length; i++) {
                            actualDist += distance(pathToGate[i-1], pathToGate[i]);
                        }
                    }

                    const detourRatio = actualDist / Math.max(directDist * 0.5, 1);
                    const efficiency = 10 / (actualDist / 1000 * detourRatio); // Points per effective distance

                    return { gate, efficiency, detourRatio };
                });

                // Sort by efficiency and take top N
                gateScores.sort((a, b) => b.efficiency - a.efficiency);
                return gateScores.slice(0, count).map(s => s.gate);
            }

            // Analyze obstacle impact on routing
            analyzeObstacleImpact(start, gates, target) {
                const analysis = {
                    hasObstacles: fieldElements.obstacles.length > 0,
                    obstacleCount: fieldElements.obstacles.length,
                    avgDetourRatio: 1.0,
                    maxDetourRatio: 1.0,
                    blockedPaths: 0,
                    totalPaths: 0,
                    theoreticalMaxScore: gates.length * 10,
                    estimatedScoreWithObstacles: 0,
                    estimatedScoreWithoutObstacles: 0,
                    turnIncreaseRatio: 1.0,
                    waypointIncreaseRatio: 1.0,
                    recommendation: 'WITH_OBSTACLES',
                    recommendationReasons: [],
                    warnings: []
                };

                if (!analysis.hasObstacles) {
                    analysis.recommendation = 'NO_OBSTACLES';
                    return analysis;
                }

                // Compute paths between all key points
                const keyPoints = [
                    { pos: start, label: 'START' },
                    ...gates.map(g => ({ pos: { x: g.x + ZONE_SIZE / 2, y: g.y + ZONE_SIZE / 2 }, label: g.label })),
                    { pos: target, label: 'TARGET' }
                ];

                let totalDirect = 0;
                let totalActual = 0;
                let totalTurns = 0;
                let totalWaypoints = 0;

                for (let i = 0; i < keyPoints.length; i++) {
                    for (let j = i + 1; j < keyPoints.length; j++) {
                        analysis.totalPaths++;

                        const from = keyPoints[i].pos;
                        const to = keyPoints[j].pos;
                        const direct = distance(from, to);
                        totalDirect += direct;

                        // Check if direct path is blocked
                        const isBlocked = !this.pathPlanner.isSegmentClearOfObstacles(from, to, 200);

                        if (isBlocked) {
                            analysis.blockedPaths++;

                            const path = this.pathPlanner.findPath(from, to);
                            if (path && path.length > 1) {
                                let actual = 0;
                                for (let k = 1; k < path.length; k++) {
                                    actual += distance(path[k-1], path[k]);
                                }
                                totalActual += actual;
                                totalWaypoints += path.length;
                                totalTurns += this.countTurns(path);

                                const ratio = actual / direct;
                                analysis.maxDetourRatio = Math.max(analysis.maxDetourRatio, ratio);
                            } else {
                                totalActual += direct * 2; // Assume 2x if no path found
                            }
                        } else {
                            totalActual += direct;
                            totalWaypoints += 2; // Direct path = 2 waypoints
                        }
                    }
                }

                analysis.avgDetourRatio = totalDirect > 0 ? totalActual / totalDirect : 1.0;

                // Estimate turns/waypoints without obstacles (straight lines)
                const turnsWithoutObstacles = gates.length + 1; // One turn per segment approximately
                const waypointsWithoutObstacles = (gates.length + 2) * 2;

                analysis.turnIncreaseRatio = turnsWithoutObstacles > 0 ?
                    totalTurns / turnsWithoutObstacles : 1.0;
                analysis.waypointIncreaseRatio = waypointsWithoutObstacles > 0 ?
                    totalWaypoints / waypointsWithoutObstacles : 1.0;

                // Check obstacle annoyance thresholds
                if (analysis.avgDetourRatio >= this.obstacleThresholds.avgDetourRatio) {
                    analysis.warnings.push(`Avg detour ${((analysis.avgDetourRatio - 1) * 100).toFixed(0)}% exceeds threshold`);
                    analysis.recommendationReasons.push(`High avg detour: ${(analysis.avgDetourRatio * 100).toFixed(0)}%`);
                }

                if (analysis.maxDetourRatio >= 2.0) {
                    analysis.warnings.push(`Max detour ${((analysis.maxDetourRatio - 1) * 100).toFixed(0)}% is extreme`);
                    analysis.recommendationReasons.push(`Extreme max detour: ${(analysis.maxDetourRatio * 100).toFixed(0)}%`);
                }

                if (analysis.blockedPaths >= 3) {
                    analysis.warnings.push(`${analysis.blockedPaths} paths significantly blocked`);
                    analysis.recommendationReasons.push(`${analysis.blockedPaths} blocked paths`);
                }

                if (analysis.turnIncreaseRatio >= this.obstacleThresholds.turnIncrease) {
                    analysis.warnings.push(`Turn count ${((analysis.turnIncreaseRatio - 1) * 100).toFixed(0)}% higher than optimal`);
                    analysis.recommendationReasons.push(`+${((analysis.turnIncreaseRatio - 1) * 100).toFixed(0)}% turns`);
                }

                if (analysis.waypointIncreaseRatio >= this.obstacleThresholds.waypointMultiple) {
                    analysis.warnings.push(`Waypoint count ${analysis.waypointIncreaseRatio.toFixed(1)}x higher than optimal`);
                    analysis.recommendationReasons.push(`${analysis.waypointIncreaseRatio.toFixed(1)}x waypoints`);
                }

                // Make recommendation
                if (analysis.recommendationReasons.length >= 2 ||
                    analysis.avgDetourRatio >= 1.5 ||
                    analysis.blockedPaths >= analysis.totalPaths * 0.3) {
                    analysis.recommendation = 'REMOVE_OBSTACLES';
                }

                return analysis;
            }

            // Try all permutations for small gate counts
            bruteForceOptimal(start, gates, target, bottles) {
                const permutations = this.getPermutations(gates);
                let bestRoute = null;
                let bestUtility = -Infinity;

                for (const perm of permutations) {
                    const route = this.buildFullRoute(start, perm, target, bottles);
                    const analysis = this.analyzeRoute(route);

                    // Prefer valid routes, but track best overall
                    const utility = analysis.utility;

                    if (utility > bestUtility) {
                        bestUtility = utility;
                        bestRoute = route;
                    }
                }

                return bestRoute;
            }

            // Heuristic approach for larger gate counts
            heuristicOptimal(start, gates, target, bottles) {
                // Start with nearest neighbor
                let route = this.nearestNeighborRoute(start, gates, target);

                // Apply 2-opt improvement
                route = this.twoOptImprove(route, start, target, bottles);

                return this.buildFullRoute(start, route, target, bottles);
            }

            // Nearest neighbor construction
            nearestNeighborRoute(start, gates, target) {
                const unvisited = [...gates];
                const order = [];
                let currentPos = { x: start.x, y: start.y };

                while (unvisited.length > 0) {
                    let nearestIdx = 0;
                    let nearestDist = Infinity;

                    for (let i = 0; i < unvisited.length; i++) {
                        const gate = unvisited[i];
                        const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                        const dist = distance(currentPos, gateCenter);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestIdx = i;
                        }
                    }

                    const gate = unvisited.splice(nearestIdx, 1)[0];
                    order.push(gate);
                    currentPos = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                }

                return order;
            }

            // 2-opt improvement
            twoOptImprove(gateOrder, start, target, bottles) {
                let improved = true;
                let order = [...gateOrder];

                while (improved) {
                    improved = false;

                    for (let i = 0; i < order.length - 1; i++) {
                        for (let j = i + 2; j < order.length; j++) {
                            const newOrder = this.twoOptSwap(order, i, j);
                            const currentRoute = this.buildFullRoute(start, order, target, bottles);
                            const newRoute = this.buildFullRoute(start, newOrder, target, bottles);

                            if (this.scoreRoute(newRoute) < this.scoreRoute(currentRoute)) {
                                order = newOrder;
                                improved = true;
                            }
                        }
                    }
                }

                return order;
            }

            // 2-opt swap
            twoOptSwap(order, i, j) {
                const newOrder = order.slice(0, i + 1);
                const reversed = order.slice(i + 1, j + 1).reverse();
                const rest = order.slice(j + 1);
                return [...newOrder, ...reversed, ...rest];
            }

            // Build full route with waypoints
            buildFullRoute(start, gateOrder, target, bottles) {
                const route = [];
                let currentPos = { x: start.x, y: start.y };

                // Analyze all bottle opportunities upfront
                const bottleOpportunities = bottles.length > 0 ?
                    this.analyzeBottleOpportunities(bottles, gateOrder) : [];

                // Track which bottles have been used
                const usedBottles = new Set();

                // Track which gates will receive bottles (prefer pushing bottle to gate we're visiting)
                const gateBottleMap = new Map(); // gate.label -> bottle opportunity

                // Assign bottles to gates they can be pushed into
                for (const opp of bottleOpportunities) {
                    const gateLabel = opp.gateLabel;
                    // Only assign if this gate is in our route and bottle not used
                    if (gateOrder.some(g => g.label === gateLabel) && !usedBottles.has(opp.bottleIndex)) {
                        if (!gateBottleMap.has(gateLabel) ||
                            opp.efficiency > gateBottleMap.get(gateLabel).efficiency) {
                            gateBottleMap.set(gateLabel, opp);
                        }
                    }
                }

                console.log(`\n=== BUILDING ROUTE WITH BOTTLES ===`);
                console.log(`Gates in order: ${gateOrder.map(g => g.label).join(' → ')}`);
                console.log(`Bottle assignments: ${Array.from(gateBottleMap.entries()).map(([g, b]) => `${b.bottleLabel}→${g}`).join(', ') || 'none'}`);

                // Start position
                route.push({
                    type: 'start',
                    x: start.x,
                    y: start.y,
                    label: 'S',
                    waypoints: []
                });

                // Visit each gate, potentially pushing bottles
                for (let gi = 0; gi < gateOrder.length; gi++) {
                    const gate = gateOrder[gi];
                    // Find optimal entry point - closest point on gate to current position
                    // Gate is a square zone, we just need to enter it anywhere
                    const gateTarget = this.findBestGateEntry(currentPos, gate);
                    const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };

                    // Check if we should push a bottle into this gate
                    const bottleOpp = gateBottleMap.get(gate.label);

                    if (bottleOpp && !usedBottles.has(bottleOpp.bottleIndex)) {
                        // Calculate if detour is worthwhile
                        const detourCost = this.calculateDetourCost(currentPos, bottleOpp, gateCenter);

                        console.log(`  Evaluating ${bottleOpp.bottleLabel} → ${gate.label}: ` +
                            `benefit=${detourCost.feasible ? detourCost.netBenefit.toFixed(1) : 'N/A'}, ` +
                            `worthwhile=${detourCost.feasible && detourCost.worthwhile}`);

                        if (detourCost.feasible && detourCost.worthwhile) {
                            usedBottles.add(bottleOpp.bottleIndex);

                            // 1. Path to approach position (behind bottle) - uses A* pathfinding
                            const approachPath = this.pathPlanner.findPath(currentPos, bottleOpp.approachPos);
                            if (!approachPath) {
                                console.log(`  ✗ No path to approach position for ${bottleOpp.bottleLabel}`);
                                continue; // Skip this bottle if we can't reach it
                            }

                            let approachDist = 0;
                            for (let i = 1; i < approachPath.length; i++) {
                                approachDist += distance(approachPath[i - 1], approachPath[i]);
                            }

                            // 2. The push is a straight line (bottle must have clear path to gate)
                            // We already validated this in analyzeBottleOpportunities with isPushPathClear
                            const bottlePos = { x: bottleOpp.bottle.x, y: bottleOpp.bottle.y };

                            // Build complete path: pathfind to approach, then straight push to gate
                            const pushPath = [...approachPath, bottlePos, gateCenter];

                            route.push({
                                type: 'bottle_push',
                                x: gateCenter.x,
                                y: gateCenter.y,
                                label: bottleOpp.bottleLabel,
                                targetGate: gate.label,
                                approachPos: bottleOpp.approachPos,
                                bottlePos: bottlePos,
                                dist: approachDist + bottleOpp.pushDist + 120,
                                waypoints: pushPath
                            });

                            console.log(`  ✓ Added bottle push: ${bottleOpp.bottleLabel} → ${gate.label}`);

                            // We're now at the gate after pushing
                            currentPos = gateCenter;

                            // Add gate entry (we entered gate while pushing bottle)
                            route.push({
                                type: 'gate',
                                x: gateCenter.x,
                                y: gateCenter.y,
                                label: gate.label,
                                color: GATE_COLORS[gate.colorIndex],
                                dist: 0, // Already at gate from bottle push
                                waypoints: [gateCenter],
                                withBottle: true
                            });

                            continue; // Move to next gate
                        }
                    }

                    // No bottle push - just navigate to gate normally
                    // Use optimal entry point, not center
                    let path = this.pathPlanner.findPath(currentPos, gateTarget);

                    // If pathfinding fails, try center as fallback
                    if (!path || path.length < 2) {
                        console.warn(`No path to gate ${gate.label} edge, trying center...`);
                        path = this.pathPlanner.findPath(currentPos, gateCenter);
                    }

                    // If still no path, rebuild grid and retry
                    if (!path || path.length < 2) {
                        console.error(`No path found to gate ${gate.label}, rebuilding grid...`);
                        this.pathPlanner.buildGrid();
                        path = this.pathPlanner.findPath(currentPos, gateTarget);
                    }

                    // If still no path, this is a critical error - skip this gate
                    if (!path || path.length < 2) {
                        console.error(`CRITICAL: Cannot find ANY path to gate ${gate.label}`);
                        continue;
                    }

                    let pathDist = 0;
                    for (let i = 1; i < path.length; i++) {
                        pathDist += distance(path[i - 1], path[i]);
                    }

                    route.push({
                        type: 'gate',
                        x: gateTarget.x,
                        y: gateTarget.y,
                        label: gate.label,
                        color: GATE_COLORS[gate.colorIndex],
                        dist: pathDist,
                        waypoints: path
                    });

                    currentPos = gateTarget;
                }

                // Check for any remaining worthwhile bottle opportunities before target
                // (bottles that can be pushed into gates we already visited)
                const remainingOpportunities = bottleOpportunities.filter(opp =>
                    !usedBottles.has(opp.bottleIndex) && opp.efficiency > 1.0
                );

                for (const opp of remainingOpportunities.slice(0, 2)) { // Max 2 extra bottles
                    const targetPos = { x: target.x, y: target.y };
                    const gateCenter = { x: opp.targetGate.x + ZONE_SIZE / 2, y: opp.targetGate.y + ZONE_SIZE / 2 };

                    // Calculate detour: current → bottle → gate → target
                    const toApproach = this.pathPlanner.findPath(currentPos, opp.approachPos);
                    const toTarget = this.pathPlanner.findPath(gateCenter, targetPos);

                    if (!toApproach || !toTarget) continue;

                    let detourDist = 0;
                    for (let i = 1; i < toApproach.length; i++) {
                        detourDist += distance(toApproach[i - 1], toApproach[i]);
                    }
                    detourDist += opp.pushDist + 120;
                    for (let i = 1; i < toTarget.length; i++) {
                        detourDist += distance(toTarget[i - 1], toTarget[i]);
                    }

                    // Direct distance to target
                    const directPath = this.pathPlanner.findPath(currentPos, targetPos);
                    let directDist = 0;
                    if (directPath) {
                        for (let i = 1; i < directPath.length; i++) {
                            directDist += distance(directPath[i - 1], directPath[i]);
                        }
                    }

                    const extraDist = detourDist - directDist;
                    const distPenalty = (extraDist / 10) * 2;
                    const netBenefit = 15 - distPenalty;

                    if (netBenefit > 3) { // Must save at least 3 points to be worth it
                        console.log(`  Adding extra bottle: ${opp.bottleLabel} → ${opp.gateLabel} (benefit: ${netBenefit.toFixed(1)})`);

                        usedBottles.add(opp.bottleIndex);
                        const bottlePos = { x: opp.bottle.x, y: opp.bottle.y };
                        const pushPath = [...toApproach, bottlePos, gateCenter];

                        route.push({
                            type: 'bottle_push',
                            x: gateCenter.x,
                            y: gateCenter.y,
                            label: opp.bottleLabel,
                            targetGate: opp.gateLabel,
                            approachPos: opp.approachPos,
                            bottlePos: bottlePos,
                            dist: detourDist - distance(gateCenter, targetPos),
                            waypoints: pushPath
                        });

                        currentPos = gateCenter;
                    }
                }

                // Final path to target - MUST use pathfinding
                const targetPos = { x: target.x, y: target.y };
                let targetPath = this.pathPlanner.findPath(currentPos, targetPos);

                if (!targetPath || targetPath.length < 2) {
                    console.error(`No path found to target, trying fallback...`);
                    this.pathPlanner.buildGrid();
                    targetPath = this.pathPlanner.findPath(currentPos, targetPos);
                }

                if (!targetPath || targetPath.length < 2) {
                    console.error(`CRITICAL: Cannot find ANY path to target`);
                    targetPath = [currentPos, targetPos]; // Last resort - should never happen
                }

                let targetDist = 0;
                for (let i = 1; i < targetPath.length; i++) {
                    targetDist += distance(targetPath[i - 1], targetPath[i]);
                }

                route.push({
                    type: 'target',
                    x: target.x,
                    y: target.y,
                    label: 'T',
                    dist: targetDist,
                    waypoints: targetPath
                });

                const bottlePushes = route.filter(r => r.type === 'bottle_push').length;
                console.log(`Route complete: ${route.length} segments, ${bottlePushes} bottle pushes`);
                console.log(`=== ROUTE BUILDING COMPLETE ===\n`);

                return route;
            }

            // Analyze all bottle push opportunities
            analyzeBottleOpportunities(bottles, gates) {
                const opportunities = [];
                const MAX_PUSH_DISTANCE = 400; // Maximum distance to push a bottle (mm)
                const PUSH_SPEED = 60; // mm/s when pushing
                const APPROACH_TIME = 2.0; // Time to align behind bottle

                console.log(`\n=== ANALYZING BOTTLE OPPORTUNITIES ===`);
                console.log(`Bottles: ${bottles.length}, Gates: ${gates.length}`);

                if (bottles.length === 0 || gates.length === 0) {
                    console.log('No bottles or gates to analyze');
                    return opportunities;
                }

                for (let bi = 0; bi < bottles.length; bi++) {
                    const bottle = bottles[bi];
                    const bottlePos = { x: bottle.x, y: bottle.y };
                    const bottleLabel = `B${bi + 1}`;

                    console.log(`\nBottle ${bottleLabel} at (${bottle.x.toFixed(0)}, ${bottle.y.toFixed(0)}):`);

                    // Find best gate for this bottle
                    let bestGate = null;
                    let bestScore = -Infinity;
                    let bestDetails = null;

                    for (const gate of gates) {
                        const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                        const pushDist = distance(bottlePos, gateCenter);

                        // Skip if too far to push
                        if (pushDist > MAX_PUSH_DISTANCE) {
                            console.log(`  Gate ${gate.label}: Too far (${pushDist.toFixed(0)}mm > ${MAX_PUSH_DISTANCE}mm)`);
                            continue;
                        }

                        // Calculate approach position (behind bottle, opposite to push direction)
                        const pushDir = {
                            x: (gateCenter.x - bottlePos.x) / pushDist,
                            y: (gateCenter.y - bottlePos.y) / pushDist
                        };
                        const approachDist = 120; // 120mm behind bottle
                        const approachPos = {
                            x: bottlePos.x - pushDir.x * approachDist,
                            y: bottlePos.y - pushDir.y * approachDist
                        };

                        // Check if approach position is within field boundaries
                        // Robot needs WALL_MARGIN + robotRadius from edges
                        const minBound = WALL_MARGIN + this.pathPlanner.robotRadius;
                        const maxX = FIELD_WIDTH - minBound;
                        const maxY = FIELD_LENGTH - minBound;

                        if (approachPos.x < minBound || approachPos.x > maxX ||
                            approachPos.y < minBound || approachPos.y > maxY) {
                            console.log(`  Gate ${gate.label}: Approach outside field bounds`);
                            continue;
                        }

                        // Check if approach position is valid (not in obstacle)
                        const cell = this.pathPlanner.worldToGrid(approachPos.x, approachPos.y);
                        if (!this.pathPlanner.isValidCell(cell.col, cell.row) ||
                            !this.pathPlanner.grid[cell.row][cell.col].walkable) {
                            console.log(`  Gate ${gate.label}: Approach blocked by obstacle`);
                            continue;
                        }

                        // Check if push path is clear
                        if (!this.isPushPathClear(approachPos, gateCenter)) {
                            console.log(`  Gate ${gate.label}: Push path blocked`);
                            continue;
                        }

                        // Calculate time cost
                        const pushTime = (pushDist + approachDist) / PUSH_SPEED;
                        const totalTime = APPROACH_TIME + pushTime;

                        // Score: -15 pts for bottle, minus time cost (2 pts per second over target)
                        const scoreGain = 15; // Points gained
                        const efficiency = scoreGain / totalTime; // Points per second

                        console.log(`  Gate ${gate.label}: dist=${pushDist.toFixed(0)}mm, time=${totalTime.toFixed(1)}s, efficiency=${efficiency.toFixed(2)} pts/s`);

                        if (efficiency > bestScore) {
                            bestScore = efficiency;
                            bestGate = gate;
                            bestDetails = {
                                pushDist,
                                approachPos,
                                pushDir,
                                totalTime,
                                efficiency
                            };
                        }
                    }

                    if (bestGate && bestDetails) {
                        opportunities.push({
                            bottle: bottle,
                            bottleIndex: bi,
                            bottleLabel: bottleLabel,
                            targetGate: bestGate,
                            gateLabel: bestGate.label,
                            approachPos: bestDetails.approachPos,
                            pushDir: bestDetails.pushDir,
                            pushDist: bestDetails.pushDist,
                            totalTime: bestDetails.totalTime,
                            efficiency: bestDetails.efficiency,
                            scoreGain: 15
                        });
                        console.log(`  ✓ BEST: Gate ${bestGate.label} (efficiency: ${bestDetails.efficiency.toFixed(2)} pts/s)`);
                    } else {
                        console.log(`  ✗ No feasible gate found`);
                    }
                }

                // Sort by efficiency (best first)
                opportunities.sort((a, b) => b.efficiency - a.efficiency);

                console.log(`\nFound ${opportunities.length} bottle opportunities`);
                console.log(`=== BOTTLE ANALYSIS COMPLETE ===\n`);

                return opportunities;
            }

            // Check if push path from approach position through bottle to gate is clear
            isPushPathClear(from, to) {
                const steps = Math.ceil(distance(from, to) / 25); // Check every 25mm
                const dx = (to.x - from.x) / steps;
                const dy = (to.y - from.y) / steps;
                const robotRadius = this.pathPlanner.robotRadius; // 150mm for 300mm robot

                // Minimum distance from field edge (wall margin + robot radius)
                const minBound = WALL_MARGIN + robotRadius;
                const maxX = FIELD_WIDTH - minBound;
                const maxY = FIELD_LENGTH - minBound;

                for (let i = 0; i <= steps; i++) {
                    const x = from.x + dx * i;
                    const y = from.y + dy * i;

                    // Check if robot center would be within safe bounds
                    if (x < minBound || x > maxX || y < minBound || y > maxY) {
                        return false;
                    }

                    // Check against obstacles (with robot radius clearance)
                    for (const obs of fieldElements.obstacles) {
                        if (x >= obs.x - robotRadius && x <= obs.x + obs.width + robotRadius &&
                            y >= obs.y - robotRadius && y <= obs.y + obs.height + robotRadius) {
                            return false;
                        }
                    }
                }

                return true;
            }

            // Calculate detour cost to reach a bottle then continue to original destination
            calculateDetourCost(currentPos, bottleOpportunity, nextDestination) {
                const approachPath = this.pathPlanner.findPath(currentPos, bottleOpportunity.approachPos);
                const gateCenter = {
                    x: bottleOpportunity.targetGate.x + ZONE_SIZE / 2,
                    y: bottleOpportunity.targetGate.y + ZONE_SIZE / 2
                };
                const continueFromGate = this.pathPlanner.findPath(gateCenter, nextDestination);

                if (!approachPath || !continueFromGate) {
                    return { feasible: false };
                }

                // Calculate approach distance
                let approachDist = 0;
                for (let i = 1; i < approachPath.length; i++) {
                    approachDist += distance(approachPath[i - 1], approachPath[i]);
                }

                // Push distance (approach to gate through bottle)
                const pushDist = bottleOpportunity.pushDist + 120; // Include approach behind bottle

                // Continue distance
                let continueDist = 0;
                for (let i = 1; i < continueFromGate.length; i++) {
                    continueDist += distance(continueFromGate[i - 1], continueFromGate[i]);
                }

                // Direct distance (what we'd travel without detour)
                const directPath = this.pathPlanner.findPath(currentPos, nextDestination);
                let directDist = 0;
                if (directPath) {
                    for (let i = 1; i < directPath.length; i++) {
                        directDist += distance(directPath[i - 1], directPath[i]);
                    }
                } else {
                    directDist = distance(currentPos, nextDestination);
                }

                // Time calculations
                const approachTime = approachDist / this.robotSpeed;
                const pushTime = pushDist / 60; // Slower when pushing
                const continueTime = continueDist / this.robotSpeed;
                const detourTime = approachTime + pushTime + continueTime + 2.0; // +2s for alignment

                const directTime = directDist / this.robotSpeed;
                const extraTime = detourTime - directTime;

                // Score impact: +15 for bottle, -2 per extra cm distance
                const extraDist = (approachDist + pushDist + continueDist) - directDist;
                const distPenalty = (extraDist / 10) * 2; // 2 pts per cm
                const netBenefit = 15 - distPenalty;

                return {
                    feasible: true,
                    approachPath,
                    continueFromGate,
                    approachDist,
                    pushDist,
                    continueDist,
                    extraTime,
                    extraDist,
                    netBenefit,
                    worthwhile: netBenefit > 0
                };
            }

            // Find best entry point for a gate - closest edge to current position
            // Robot center must be far enough inside that the entire robot body is within the gate
            findBestGateEntry(fromPos, gate) {
                // Robot radius + safety buffer to ensure entire robot is inside gate
                const margin = this.pathPlanner.robotRadius + 50; // 150 + 50 = 200mm from edge
                const gateLeft = gate.x + margin;
                const gateRight = gate.x + ZONE_SIZE - margin;
                const gateBottom = gate.y + margin;
                const gateTop = gate.y + ZONE_SIZE - margin;

                // Clamp current position to gate bounds to find closest edge point
                const clampedX = Math.max(gateLeft, Math.min(fromPos.x, gateRight));
                const clampedY = Math.max(gateBottom, Math.min(fromPos.y, gateTop));

                // If we're already aligned with the gate on one axis, use that
                // Otherwise find the closest corner/edge
                let targetX, targetY;

                if (fromPos.x >= gateLeft && fromPos.x <= gateRight) {
                    // Horizontally aligned - enter from top or bottom
                    targetX = fromPos.x;
                    targetY = fromPos.y < gate.y + ZONE_SIZE / 2 ? gateBottom : gateTop;
                } else if (fromPos.y >= gateBottom && fromPos.y <= gateTop) {
                    // Vertically aligned - enter from left or right
                    targetX = fromPos.x < gate.x + ZONE_SIZE / 2 ? gateLeft : gateRight;
                    targetY = fromPos.y;
                } else {
                    // Not aligned - target the closest corner
                    targetX = fromPos.x < gate.x + ZONE_SIZE / 2 ? gateLeft : gateRight;
                    targetY = fromPos.y < gate.y + ZONE_SIZE / 2 ? gateBottom : gateTop;
                }

                return { x: targetX, y: targetY };
            }

            // Score a route using tournament-aware utility (higher is better)
            // This is used for 2-opt comparison - uses full utility function
            scoreRoute(route) {
                const analysis = this.analyzeRoute(route);
                // Return negative utility because 2-opt expects lower=better
                return -analysis.utility;
            }

            // Generate all permutations
            getPermutations(arr) {
                if (arr.length <= 1) return [arr];
                const result = [];

                for (let i = 0; i < arr.length; i++) {
                    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
                    const perms = this.getPermutations(rest);
                    for (const perm of perms) {
                        result.push([arr[i], ...perm]);
                    }
                }

                return result;
            }
        }

        // ==================== BOTTLE PUSH ANALYZER ====================
        class BottlePushAnalyzer {
            constructor(pathPlanner) {
                this.pathPlanner = pathPlanner;
                this.pushDistance = 300; // Maximum push distance in mm
                this.pushWidth = 150; // Robot push width
            }

            // Analyze if pushing a bottle into a gate is beneficial
            analyzeBottlePush(bottle, gates, currentPos, targetGate) {
                const analysis = {
                    bottle: bottle,
                    canPush: false,
                    targetGate: null,
                    pushPath: null,
                    timeSaved: 0,
                    scoreBenefit: 0
                };

                // Check each gate for push opportunity
                for (const gate of gates) {
                    const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };

                    // Check if bottle is pushable into this gate
                    const pushResult = this.canPushIntoGate(bottle, gate, currentPos);

                    if (pushResult.canPush) {
                        // Calculate benefit
                        const directDist = distance(currentPos, gateCenter);
                        const pushDist = pushResult.totalDistance;
                        const extraDist = pushDist - directDist;

                        // Bottle in gate = -15 points, extra distance costs 2 pts/cm
                        const distCost = (extraDist / 10) * 2;
                        const benefit = 15 - distCost;

                        if (benefit > analysis.scoreBenefit) {
                            analysis.canPush = true;
                            analysis.targetGate = gate;
                            analysis.pushPath = pushResult.path;
                            analysis.scoreBenefit = benefit;
                            analysis.approachAngle = pushResult.approachAngle;
                        }
                    }
                }

                return analysis;
            }

            // Check if a bottle can be pushed into a specific gate
            canPushIntoGate(bottle, gate, currentPos) {
                const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                const bottlePos = { x: bottle.x, y: bottle.y };

                // Vector from bottle to gate center
                const toGate = {
                    x: gateCenter.x - bottlePos.x,
                    y: gateCenter.y - bottlePos.y
                };
                const distToGate = Math.sqrt(toGate.x * toGate.x + toGate.y * toGate.y);

                // Bottle must be within push range of gate
                if (distToGate > this.pushDistance) {
                    return { canPush: false };
                }

                // Normalize direction
                const pushDir = { x: toGate.x / distToGate, y: toGate.y / distToGate };

                // Calculate approach position (behind bottle, opposite to push direction)
                const approachDist = 100; // 100mm behind bottle
                const approachPos = {
                    x: bottlePos.x - pushDir.x * approachDist,
                    y: bottlePos.y - pushDir.y * approachDist
                };

                // Check if approach position is valid
                const cell = this.pathPlanner.worldToGrid(approachPos.x, approachPos.y);
                if (!this.pathPlanner.isValidCell(cell.col, cell.row) ||
                    !this.pathPlanner.grid[cell.row][cell.col].walkable) {
                    return { canPush: false };
                }

                // Check push path is clear (no obstacles)
                if (!this.isPushPathClear(approachPos, gateCenter)) {
                    return { canPush: false };
                }

                // Calculate total path distance
                const pathToApproach = this.pathPlanner.findPath(currentPos, approachPos);
                let totalDist = 0;

                if (pathToApproach && pathToApproach.length > 1) {
                    for (let i = 1; i < pathToApproach.length; i++) {
                        totalDist += distance(pathToApproach[i - 1], pathToApproach[i]);
                    }
                } else {
                    totalDist = distance(currentPos, approachPos);
                }

                // Add push distance
                totalDist += distToGate + approachDist;

                return {
                    canPush: true,
                    path: pathToApproach,
                    approachPos: approachPos,
                    pushDirection: pushDir,
                    totalDistance: totalDist,
                    approachAngle: Math.atan2(pushDir.y, pushDir.x) * 180 / Math.PI
                };
            }

            // Check if push path is clear
            isPushPathClear(from, to) {
                const steps = Math.ceil(distance(from, to) / 25); // Check every 25mm
                const dx = (to.x - from.x) / steps;
                const dy = (to.y - from.y) / steps;

                for (let i = 0; i <= steps; i++) {
                    const x = from.x + dx * i;
                    const y = from.y + dy * i;

                    // Check if point is within bounds and not in obstacle
                    if (x < WALL_MARGIN || x > FIELD_WIDTH - WALL_MARGIN ||
                        y < WALL_MARGIN || y > FIELD_LENGTH - WALL_MARGIN) {
                        return false;
                    }

                    // Check against obstacles
                    for (const obs of fieldElements.obstacles) {
                        const margin = this.pushWidth / 2;
                        if (x >= obs.x - margin && x <= obs.x + obs.width + margin &&
                            y >= obs.y - margin && y <= obs.y + obs.height + margin) {
                            return false;
                        }
                    }
                }

                return true;
            }
        }

        // ==================== TOF SENSOR SIMULATOR ====================
        class ToFSensorSimulator {
            constructor() {
                // VL53L0X sensor specifications
                this.maxRange = 2000; // 2000mm max range
                this.minRange = 30;   // 30mm minimum
                this.fov = 25;        // 25 degree field of view
                this.accuracy = 3;    // ±3% accuracy
                this.noiseStdDev = 10; // 10mm noise standard deviation

                // Sensor mounting configuration (relative to robot center)
                this.sensors = [
                    { id: 'front', angle: 0, offset: { x: 75, y: 0 } },
                    { id: 'front_left', angle: 45, offset: { x: 53, y: 53 } },
                    { id: 'front_right', angle: -45, offset: { x: 53, y: -53 } },
                    { id: 'left', angle: 90, offset: { x: 0, y: 75 } },
                    { id: 'right', angle: -90, offset: { x: 0, y: -75 } },
                    { id: 'back', angle: 180, offset: { x: -75, y: 0 } }
                ];

                // Last readings storage
                this.readings = {};
                this.raycastHits = [];
            }

            // Get sensor world position and direction
            getSensorPose(sensorConfig, robotX, robotY, robotHeading) {
                const headingRad = robotHeading * Math.PI / 180;

                // Rotate offset by robot heading
                const cosH = Math.cos(headingRad);
                const sinH = Math.sin(headingRad);

                const worldX = robotX + sensorConfig.offset.x * cosH - sensorConfig.offset.y * sinH;
                const worldY = robotY + sensorConfig.offset.x * sinH + sensorConfig.offset.y * cosH;

                // Sensor world angle
                const sensorAngle = robotHeading + sensorConfig.angle;

                return {
                    x: worldX,
                    y: worldY,
                    angle: sensorAngle
                };
            }

            // Perform raycast for a sensor
            raycast(sensorPose) {
                const angleRad = sensorPose.angle * Math.PI / 180;
                const dx = Math.cos(angleRad);
                const dy = Math.sin(angleRad);

                let minDist = this.maxRange;
                let hitPoint = null;
                let hitType = 'none';

                // Check boundaries
                const boundaryHit = this.raycastBoundaries(sensorPose.x, sensorPose.y, dx, dy);
                if (boundaryHit && boundaryHit.distance < minDist) {
                    minDist = boundaryHit.distance;
                    hitPoint = boundaryHit.point;
                    hitType = 'boundary';
                }

                // Check obstacles
                for (const obs of fieldElements.obstacles) {
                    const obsHit = this.raycastRect(
                        sensorPose.x, sensorPose.y, dx, dy,
                        obs.x, obs.y, obs.width, obs.height
                    );
                    if (obsHit && obsHit.distance < minDist) {
                        minDist = obsHit.distance;
                        hitPoint = obsHit.point;
                        hitType = 'obstacle';
                    }
                }

                // Check bottles
                for (const bottle of fieldElements.bottles) {
                    const bottleHit = this.raycastCircle(
                        sensorPose.x, sensorPose.y, dx, dy,
                        bottle.x, bottle.y, bottle.radius
                    );
                    if (bottleHit && bottleHit.distance < minDist) {
                        minDist = bottleHit.distance;
                        hitPoint = bottleHit.point;
                        hitType = 'bottle';
                    }
                }

                return {
                    distance: minDist,
                    hitPoint: hitPoint,
                    hitType: hitType,
                    valid: minDist >= this.minRange && minDist <= this.maxRange
                };
            }

            // Raycast against field boundaries
            raycastBoundaries(x, y, dx, dy) {
                let minDist = Infinity;
                let hitPoint = null;

                // Left boundary (x = 0)
                if (dx < 0) {
                    const t = -x / dx;
                    if (t > 0) {
                        const hitY = y + t * dy;
                        if (hitY >= 0 && hitY <= FIELD_LENGTH && t < minDist) {
                            minDist = t;
                            hitPoint = { x: 0, y: hitY };
                        }
                    }
                }

                // Right boundary (x = FIELD_WIDTH)
                if (dx > 0) {
                    const t = (FIELD_WIDTH - x) / dx;
                    if (t > 0) {
                        const hitY = y + t * dy;
                        if (hitY >= 0 && hitY <= FIELD_LENGTH && t < minDist) {
                            minDist = t;
                            hitPoint = { x: FIELD_WIDTH, y: hitY };
                        }
                    }
                }

                // Bottom boundary (y = 0)
                if (dy < 0) {
                    const t = -y / dy;
                    if (t > 0) {
                        const hitX = x + t * dx;
                        if (hitX >= 0 && hitX <= FIELD_WIDTH && t < minDist) {
                            minDist = t;
                            hitPoint = { x: hitX, y: 0 };
                        }
                    }
                }

                // Top boundary (y = FIELD_LENGTH)
                if (dy > 0) {
                    const t = (FIELD_LENGTH - y) / dy;
                    if (t > 0) {
                        const hitX = x + t * dx;
                        if (hitX >= 0 && hitX <= FIELD_WIDTH && t < minDist) {
                            minDist = t;
                            hitPoint = { x: hitX, y: FIELD_LENGTH };
                        }
                    }
                }

                if (hitPoint) {
                    return { distance: minDist, point: hitPoint };
                }
                return null;
            }

            // Raycast against rectangle (obstacle)
            raycastRect(x, y, dx, dy, rx, ry, rw, rh) {
                let minT = Infinity;
                let hitPoint = null;

                // Check all 4 sides
                const sides = [
                    { x1: rx, y1: ry, x2: rx + rw, y2: ry },         // bottom
                    { x1: rx, y1: ry + rh, x2: rx + rw, y2: ry + rh }, // top
                    { x1: rx, y1: ry, x2: rx, y2: ry + rh },         // left
                    { x1: rx + rw, y1: ry, x2: rx + rw, y2: ry + rh }  // right
                ];

                for (const side of sides) {
                    const hit = this.rayLineIntersection(
                        x, y, dx, dy,
                        side.x1, side.y1, side.x2, side.y2
                    );
                    if (hit && hit.t < minT) {
                        minT = hit.t;
                        hitPoint = hit.point;
                    }
                }

                if (hitPoint) {
                    return { distance: minT, point: hitPoint };
                }
                return null;
            }

            // Ray-line segment intersection
            rayLineIntersection(rx, ry, dx, dy, x1, y1, x2, y2) {
                const vx = x2 - x1;
                const vy = y2 - y1;

                const denom = dx * vy - dy * vx;
                if (Math.abs(denom) < 0.0001) return null; // Parallel

                const t = ((x1 - rx) * vy - (y1 - ry) * vx) / denom;
                const u = ((x1 - rx) * dy - (y1 - ry) * dx) / denom;

                if (t > 0 && u >= 0 && u <= 1) {
                    return {
                        t: t,
                        point: { x: rx + t * dx, y: ry + t * dy }
                    };
                }
                return null;
            }

            // Raycast against circle (bottle)
            raycastCircle(x, y, dx, dy, cx, cy, r) {
                const ocx = x - cx;
                const ocy = y - cy;

                const a = dx * dx + dy * dy;
                const b = 2 * (ocx * dx + ocy * dy);
                const c = ocx * ocx + ocy * ocy - r * r;

                const disc = b * b - 4 * a * c;
                if (disc < 0) return null;

                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-b - sqrtDisc) / (2 * a);
                const t2 = (-b + sqrtDisc) / (2 * a);

                const t = t1 > 0 ? t1 : (t2 > 0 ? t2 : null);
                if (t === null) return null;

                return {
                    distance: t,
                    point: { x: x + t * dx, y: y + t * dy }
                };
            }

            // Add sensor noise
            addNoise(reading) {
                if (!reading.valid) return reading;

                // Gaussian noise
                const u1 = Math.random();
                const u2 = Math.random();
                const noise = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * this.noiseStdDev;

                // Accuracy-based error
                const accuracyError = reading.distance * (this.accuracy / 100) * (Math.random() - 0.5) * 2;

                return {
                    ...reading,
                    rawDistance: reading.distance,
                    distance: Math.max(this.minRange, reading.distance + noise + accuracyError)
                };
            }

            // Get all sensor readings
            update(robotX, robotY, robotHeading) {
                this.raycastHits = [];

                for (const sensor of this.sensors) {
                    const pose = this.getSensorPose(sensor, robotX, robotY, robotHeading);
                    let reading = this.raycast(pose);
                    reading = this.addNoise(reading);
                    reading.sensorId = sensor.id;
                    reading.pose = pose;

                    this.readings[sensor.id] = reading;

                    if (reading.hitPoint) {
                        this.raycastHits.push({
                            sensorId: sensor.id,
                            from: { x: pose.x, y: pose.y },
                            to: reading.hitPoint,
                            distance: reading.distance,
                            hitType: reading.hitType
                        });
                    }
                }

                return this.readings;
            }

            // Get formatted readings for display
            getFormattedReadings() {
                const formatted = {};
                for (const [id, reading] of Object.entries(this.readings)) {
                    formatted[id] = {
                        distance: Math.round(reading.distance),
                        hitType: reading.hitType,
                        valid: reading.valid
                    };
                }
                return formatted;
            }
        }

        // Global sensor simulator instance
        let sensorSimulator = null;

        // ==================== MEASUREMENT FUNCTIONS ====================
        function getElementCenter(elem) {
            if (!elem) return null;
            switch (elem.type) {
                case 'start':
                case 'target':
                case 'bottle':
                    return { x: elem.x, y: elem.y };
                case 'gate':
                    return { x: elem.x + ZONE_SIZE / 2, y: elem.y + ZONE_SIZE / 2 };
                case 'obstacle':
                    return { x: elem.x + elem.width / 2, y: elem.y + elem.height / 2 };
                default:
                    return { x: elem.x, y: elem.y };
            }
        }

        function getElementBounds(elem) {
            if (!elem) return null;
            switch (elem.type) {
                case 'start':
                case 'target':
                    return { x: elem.x - 15, y: elem.y - 15, w: 30, h: 30 };
                case 'bottle':
                    return { x: elem.x - elem.radius, y: elem.y - elem.radius, w: elem.radius * 2, h: elem.radius * 2 };
                case 'gate':
                    return { x: elem.x, y: elem.y, w: ZONE_SIZE, h: ZONE_SIZE };
                case 'obstacle':
                    return { x: elem.x, y: elem.y, w: elem.width, h: elem.height };
                default:
                    return { x: elem.x, y: elem.y, w: 50, h: 50 };
            }
        }

        function calculateClearance(elem1, elem2) {
            const b1 = getElementBounds(elem1);
            const b2 = getElementBounds(elem2);
            if (!b1 || !b2) return Infinity;

            // Calculate edge-to-edge distance
            const left1 = b1.x, right1 = b1.x + b1.w, top1 = b1.y, bottom1 = b1.y + b1.h;
            const left2 = b2.x, right2 = b2.x + b2.w, top2 = b2.y, bottom2 = b2.y + b2.h;

            const dx = Math.max(0, Math.max(left1 - right2, left2 - right1));
            const dy = Math.max(0, Math.max(top1 - bottom2, top2 - bottom1));

            return Math.sqrt(dx * dx + dy * dy);
        }

        function addMeasurement(elem1, elem2) {
            const c1 = getElementCenter(elem1);
            const c2 = getElementCenter(elem2);
            const dist = distance(c1, c2);
            const clearance = calculateClearance(elem1, elem2);

            const measurement = {
                id: measurementNextId++,
                element1: elem1,
                element2: elem2,
                distance: dist,
                clearance: clearance,
                isValid: clearance >= MIN_CLEARANCE
            };

            activeMeasurements.push(measurement);
            updateMeasurementsPanel();
            redraw();
            return measurement;
        }

        function removeMeasurement(id) {
            activeMeasurements = activeMeasurements.filter(m => m.id !== id);
            updateMeasurementsPanel();
            redraw();
        }

        function clearAllMeasurements() {
            activeMeasurements = [];
            measurementFirstElement = null;
            updateMeasurementsPanel();
            redraw();
        }

        function getElementLabel(elem) {
            if (!elem) return '?';
            switch (elem.type) {
                case 'start': return 'START';
                case 'target': return 'TARGET';
                case 'gate': return `GATE_${elem.label}`;
                case 'obstacle':
                    const obsIdx = fieldElements.obstacles.indexOf(elem) + 1;
                    return `OBS_${String(obsIdx).padStart(2, '0')}`;
                case 'bottle':
                    const btlIdx = fieldElements.bottles.indexOf(elem) + 1;
                    return `BTL_${String(btlIdx).padStart(2, '0')}`;
                default: return elem.type.toUpperCase();
            }
        }

        function updateMeasurementsPanel() {
            const panel = document.getElementById('measurementsPanel');
            if (!panel) return; // Panel not yet in DOM

            if (activeMeasurements.length === 0) {
                // Show default distance info when no active measurements
                let rows = [];
                if (selectedElement && fieldElements.start && selectedElement !== fieldElements.start) {
                    const center = getElementCenter(selectedElement);
                    const dist = distance(center, fieldElements.start);
                    rows.push({ label: '→ START', value: `${Math.round(dist)}mm` });
                }
                if (selectedElement && fieldElements.target && selectedElement !== fieldElements.target) {
                    const center = getElementCenter(selectedElement);
                    const dist = distance(center, fieldElements.target);
                    rows.push({ label: '→ TARGET', value: `${Math.round(dist)}mm` });
                }
                if (fieldElements.start && fieldElements.target) {
                    const totalDist = distance(fieldElements.start, fieldElements.target);
                    rows.push({ label: 'START→TARGET', value: `${Math.round(totalDist)}mm`, highlight: true });
                }

                if (rows.length === 0) {
                    panel.innerHTML = `<div class="empty-state">Use MEASURE tool to click<br>two elements</div>`;
                    return;
                }

                panel.innerHTML = rows.map(r => `
                    <div class="measurement-row">
                        <span class="measurement-label">${r.label}</span>
                        <span class="measurement-value ${r.highlight ? 'highlight' : ''}">${r.value}</span>
                    </div>
                `).join('');
                return;
            }

            // Show active measurements
            let html = `<div class="measurement-header">
                <span>${activeMeasurements.length} measurement${activeMeasurements.length > 1 ? 's' : ''}</span>
                <button class="btn-mini" onclick="clearAllMeasurements()">CLEAR</button>
            </div>`;

            html += activeMeasurements.map(m => {
                const label1 = getElementLabel(m.element1);
                const label2 = getElementLabel(m.element2);
                const statusClass = m.isValid ? 'valid' : 'invalid';
                const statusIcon = m.isValid ? '✓' : '✗';

                return `<div class="measurement-item ${statusClass}">
                    <div class="measurement-pair">${label1} ↔ ${label2}</div>
                    <div class="measurement-data">
                        <span class="dist">${Math.round(m.distance)}mm</span>
                        <span class="clr ${statusClass}">clr: ${Math.round(m.clearance)}mm ${statusIcon}</span>
                    </div>
                    <button class="measurement-delete" onclick="removeMeasurement(${m.id})">×</button>
                </div>`;
            }).join('');

            panel.innerHTML = html;
        }

        // Undo/Redo history
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO = 50;

        function saveState() {
            const state = JSON.stringify({
                fieldElements: {
                    start: fieldElements.start ? { ...fieldElements.start } : null,
                    target: fieldElements.target ? { ...fieldElements.target } : null,
                    gates: fieldElements.gates.map(g => ({ ...g })),
                    obstacles: fieldElements.obstacles.map(o => ({ ...o })),
                    bottles: fieldElements.bottles.map(b => ({ ...b }))
                },
                nextGateIndex
            });
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length <= 1) return;
            const current = undoStack.pop();
            redoStack.push(current);
            const previous = undoStack[undoStack.length - 1];
            restoreState(previous);
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const state = redoStack.pop();
            undoStack.push(state);
            restoreState(state);
            updateUndoRedoButtons();
        }

        function restoreState(stateJson) {
            const state = JSON.parse(stateJson);
            fieldElements = state.fieldElements;
            nextGateIndex = state.nextGateIndex;
            selectedElement = null;
            updateElementList();
            updatePropertiesPanel();
            updateMeasurements();
            validateField();
            redraw();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = undoStack.length <= 1;
            document.getElementById('redoBtn').disabled = redoStack.length === 0;
        }

        // Save initial state
        saveState();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ==================== MODE ====================
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('modeEdit').classList.toggle('active', mode === 'edit');
            document.getElementById('modeAuto').classList.toggle('active', mode === 'auto');
            document.getElementById('modeSim').classList.toggle('active', mode === 'sim');
            document.getElementById('editModePanel').style.display = mode === 'edit' ? 'block' : 'none';
            document.getElementById('autoModePanel').style.display = mode === 'auto' ? 'block' : 'none';
            document.getElementById('simModePanel').style.display = mode === 'sim' ? 'block' : 'none';

            // Reset simulation when leaving sim mode
            if (mode !== 'sim' && simState.running) {
                resetSimulation();
            }

            // Initialize simulation display when entering sim mode
            if (mode === 'sim') {
                updateSimDisplay();
                resetSimulation();
            }

            redraw();
        }

        // ==================== TOOLS ====================
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                selectedElement = null;
                measureStart = null;
                measureEnd = null;
                updatePropertiesPanel();
                redraw();
            });
        });

        // ==================== SMART RULE-BASED SNAPPING ====================

        // Snap feedback for visual indicators
        const snapFeedback = {
            zone_corner: { color: '#ff9940', message: 'SNAP: Zone corner' },
            zone_center: { color: '#ff9940', message: 'SNAP: Zone center' },
            boundary_centered: { color: '#7fd962', message: 'SNAP: Boundary (centered)' },
            line_constrained: { color: '#5ccfe6', message: 'ON LINE: Slide to adjust' },
            invalid: { color: '#ff6b6b', message: 'INVALID: Cannot place here' }
        };

        let currentSnapResult = null;

        // ===== GATE SNAPPING: Strict zone corners =====
        function snapGateToZone(x, y) {
            const col = Math.round(x / ZONE_SIZE);
            const row = Math.round(y / ZONE_SIZE);
            const snappedCol = Math.max(0, Math.min(GRID_COLS - 1, col));
            const snappedRow = Math.max(0, Math.min(GRID_ROWS - 1, row));

            return {
                x: snappedCol * ZONE_SIZE,
                y: snappedRow * ZONE_SIZE,
                col: snappedCol,
                row: snappedRow,
                zone: `(${snappedCol},${snappedRow})`,
                snapType: 'zone_corner',
                valid: true
            };
        }

        // ===== START POINT SNAPPING: Boundary edge, centered between lines =====
        function snapStartToBoundary(x, y) {
            const distToLeft = x;
            const distToRight = FIELD_WIDTH - x;
            const distToBottom = y;
            const distToTop = FIELD_LENGTH - y;

            const minDist = Math.min(distToLeft, distToRight, distToBottom, distToTop);

            let snappedX, snappedY, edge, direction;

            // Valid centered positions
            const verticalCenters = [250, 750, 1250, 1750, 2250]; // For left/right edges
            const horizontalCenters = [250, 750, 1250, 1750]; // For top/bottom edges

            if (minDist === distToLeft) {
                edge = 'left';
                direction = 'E'; // Facing into field
                snappedX = TAPE_WIDTH;
                snappedY = verticalCenters.reduce((prev, curr) =>
                    Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
                );
            } else if (minDist === distToRight) {
                edge = 'right';
                direction = 'W';
                snappedX = FIELD_WIDTH - TAPE_WIDTH;
                snappedY = verticalCenters.reduce((prev, curr) =>
                    Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
                );
            } else if (minDist === distToBottom) {
                edge = 'bottom';
                direction = 'N';
                snappedY = TAPE_WIDTH;
                snappedX = horizontalCenters.reduce((prev, curr) =>
                    Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
                );
            } else {
                edge = 'top';
                direction = 'S';
                snappedY = FIELD_LENGTH - TAPE_WIDTH;
                snappedX = horizontalCenters.reduce((prev, curr) =>
                    Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
                );
            }

            return {
                x: snappedX,
                y: snappedY,
                edge: edge,
                direction: direction,
                snapType: 'boundary_centered',
                valid: true
            };
        }

        // ===== TARGET SNAPPING: Zone centers only =====
        function snapTargetToZoneCenter(x, y) {
            const validX = [250, 750, 1250, 1750];
            const validY = [250, 750, 1250, 1750, 2250];

            const snappedX = validX.reduce((prev, curr) =>
                Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
            );
            const snappedY = validY.reduce((prev, curr) =>
                Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
            );

            const col = Math.floor(snappedX / ZONE_SIZE);
            const row = Math.floor(snappedY / ZONE_SIZE);

            return {
                x: snappedX,
                y: snappedY,
                zone: `(${col},${row})`,
                snapType: 'zone_center',
                valid: true
            };
        }

        // ===== OBSTACLE SNAPPING: On lines, perpendicular orientation =====
        function snapObstacleToLine(x, y, currentOrientation) {
            const verticalLines = [0, 500, 1000, 1500, 2000];
            const horizontalLines = [0, 500, 1000, 1500, 2000, 2500];

            const closestVertical = verticalLines.reduce((prev, curr) =>
                Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
            );
            const closestHorizontal = horizontalLines.reduce((prev, curr) =>
                Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
            );

            const distToVertical = Math.abs(closestVertical - x);
            const distToHorizontal = Math.abs(closestHorizontal - y);

            let snappedX, snappedY, orientation, placedOn;

            // Soft centering positions
            const vertCenters = [250, 750, 1250, 1750, 2250];
            const horzCenters = [250, 750, 1250, 1750];

            if (distToVertical < distToHorizontal) {
                // Snap to vertical line - obstacle should be horizontal (perpendicular)
                snappedX = closestVertical;
                orientation = 'horizontal';
                placedOn = `vertical_${closestVertical}`;

                // Soft snap to centered position
                const suggestedY = vertCenters.reduce((prev, curr) =>
                    Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
                );
                snappedY = Math.abs(suggestedY - y) < 100 ? suggestedY : y;

                // Clamp to field bounds
                snappedY = Math.max(WALL_MARGIN + OBSTACLE_DEPTH/2, Math.min(FIELD_LENGTH - WALL_MARGIN - OBSTACLE_DEPTH/2, snappedY));
            } else {
                // Snap to horizontal line - obstacle should be vertical (perpendicular)
                snappedY = closestHorizontal;
                orientation = 'vertical';
                placedOn = `horizontal_${closestHorizontal}`;

                const suggestedX = horzCenters.reduce((prev, curr) =>
                    Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
                );
                snappedX = Math.abs(suggestedX - x) < 100 ? suggestedX : x;

                snappedX = Math.max(WALL_MARGIN + OBSTACLE_DEPTH/2, Math.min(FIELD_WIDTH - WALL_MARGIN - OBSTACLE_DEPTH/2, snappedX));
            }

            // Calculate dimensions based on orientation
            const width = orientation === 'horizontal' ? OBSTACLE_LENGTH : OBSTACLE_DEPTH;
            const height = orientation === 'horizontal' ? OBSTACLE_DEPTH : OBSTACLE_LENGTH;

            // Adjust position to center obstacle on line
            let finalX, finalY;
            if (orientation === 'horizontal') {
                finalX = snappedX - width / 2;
                finalY = snappedY - height / 2;
            } else {
                finalX = snappedX - width / 2;
                finalY = snappedY - height / 2;
            }

            return {
                x: finalX,
                y: finalY,
                centerX: snappedX,
                centerY: snappedY,
                width: width,
                height: height,
                orientation: orientation,
                placedOn: placedOn,
                snapType: 'line_constrained',
                valid: true
            };
        }

        // ===== BOTTLE SNAPPING: Interior lines only, not boundaries =====
        function snapBottleToLine(x, y) {
            // Interior lines only (not 0 or max)
            const verticalLines = [500, 1000, 1500];
            const horizontalLines = [500, 1000, 1500, 2000];

            const closestVertical = verticalLines.reduce((prev, curr) =>
                Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
            );
            const closestHorizontal = horizontalLines.reduce((prev, curr) =>
                Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
            );

            const distToVertical = Math.abs(closestVertical - x);
            const distToHorizontal = Math.abs(closestHorizontal - y);

            let snappedX, snappedY, placedOn;

            const vertCenters = [250, 750, 1250, 1750, 2250];
            const horzCenters = [250, 750, 1250, 1750];

            if (distToVertical < distToHorizontal) {
                snappedX = closestVertical;
                placedOn = `vertical_${closestVertical}`;

                const suggestedY = vertCenters.reduce((prev, curr) =>
                    Math.abs(curr - y) < Math.abs(prev - y) ? curr : prev
                );
                snappedY = Math.abs(suggestedY - y) < 100 ? suggestedY : y;

                // Keep away from boundaries
                snappedY = Math.max(WALL_MARGIN + BOTTLE_DIAMETER/2, Math.min(FIELD_LENGTH - WALL_MARGIN - BOTTLE_DIAMETER/2, snappedY));
            } else {
                snappedY = closestHorizontal;
                placedOn = `horizontal_${closestHorizontal}`;

                const suggestedX = horzCenters.reduce((prev, curr) =>
                    Math.abs(curr - x) < Math.abs(prev - x) ? curr : prev
                );
                snappedX = Math.abs(suggestedX - x) < 100 ? suggestedX : x;

                snappedX = Math.max(WALL_MARGIN + BOTTLE_DIAMETER/2, Math.min(FIELD_WIDTH - WALL_MARGIN - BOTTLE_DIAMETER/2, snappedX));
            }

            // Check if at intersection (invalid for bottles)
            const atIntersection = verticalLines.includes(snappedX) && horizontalLines.includes(snappedY);

            return {
                x: snappedX,
                y: snappedY,
                placedOn: placedOn,
                snapType: 'line_constrained',
                valid: !atIntersection,
                atIntersection: atIntersection
            };
        }

        // Get snap result for any element type during drag
        function getSnapResult(type, x, y, element) {
            switch (type) {
                case 'gate':
                    return snapGateToZone(x, y);
                case 'start':
                    return snapStartToBoundary(x, y);
                case 'target':
                    return snapTargetToZoneCenter(x, y);
                case 'obstacle':
                    return snapObstacleToLine(x, y, element?.orientation);
                case 'bottle':
                    return snapBottleToLine(x, y);
                default:
                    return { x, y, snapType: 'free', valid: true };
            }
        }

        // Legacy function for compatibility
        function snapToGridLine(value, gridLines) {
            return gridLines.reduce((prev, curr) =>
                Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
            );
        }

        // ==================== CANVAS EVENTS ====================
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / SCALE;
            const y = FIELD_LENGTH - (e.clientY - rect.top) / SCALE;

            const col = Math.floor(x / ZONE_SIZE);
            const row = Math.floor(y / ZONE_SIZE);

            document.getElementById('coordsDisplay').innerHTML =
                `X: <span class="value">${Math.round(x)}</span> Y: <span class="value">${Math.round(y)}</span> // ZONE: <span class="value">(${col},${row})</span>`;

            // Show tooltip on hover
            const hoveredElement = findElementAt(x, y);
            const tooltip = document.getElementById('tooltip');
            if (hoveredElement && !isDragging) {
                const tooltipContent = getTooltipContent(hoveredElement);
                tooltip.innerHTML = tooltipContent;
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
            } else {
                tooltip.style.display = 'none';
            }

            if (isDragging && selectedElement) {
                let newX = x - dragOffset.x;
                let newY = y - dragOffset.y;

                // Apply smart rule-based snapping based on element type
                if (selectedElement.type === 'gate') {
                    // Gates: strict zone corner snapping
                    const snap = snapGateToZone(newX, newY);
                    newX = snap.x;
                    newY = snap.y;
                    selectedElement.col = snap.col;
                    selectedElement.row = snap.row;
                    currentSnapResult = snap;

                } else if (selectedElement.type === 'start') {
                    // Start: boundary edge, centered
                    const snap = snapStartToBoundary(newX, newY);
                    newX = snap.x;
                    newY = snap.y;
                    selectedElement.edge = snap.edge;
                    selectedElement.direction = snap.direction;
                    currentSnapResult = snap;

                } else if (selectedElement.type === 'target') {
                    // Target: zone center only
                    const snap = snapTargetToZoneCenter(newX, newY);
                    newX = snap.x;
                    newY = snap.y;
                    currentSnapResult = snap;

                } else if (selectedElement.type === 'obstacle') {
                    // Obstacles: line-constrained with auto-orientation
                    const centerX = newX + selectedElement.width / 2;
                    const centerY = newY + selectedElement.height / 2;
                    const snap = snapObstacleToLine(centerX, centerY, selectedElement.orientation);
                    newX = snap.x;
                    newY = snap.y;
                    selectedElement.width = snap.width;
                    selectedElement.height = snap.height;
                    selectedElement.orientation = snap.orientation;
                    selectedElement.placedOn = snap.placedOn;
                    currentSnapResult = snap;

                } else if (selectedElement.type === 'bottle') {
                    // Bottles: interior lines only
                    const snap = snapBottleToLine(newX, newY);
                    newX = snap.x;
                    newY = snap.y;
                    selectedElement.placedOn = snap.placedOn;
                    currentSnapResult = snap;
                }

                selectedElement.x = newX;
                selectedElement.y = newY;

                updatePropertiesPanel();
                updateMeasurements();
                validateField();
                redraw();
            }

            if (currentTool === 'measure' && measureStart) {
                measureEnd = { x, y };
                redraw();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / SCALE;
            const y = FIELD_LENGTH - (e.clientY - rect.top) / SCALE;

            if (currentTool === 'select') {
                const element = findElementAt(x, y);
                if (element) {
                    selectedElement = element;
                    isDragging = true;
                    dragOffset = { x: x - element.x, y: y - element.y };
                } else {
                    selectedElement = null;
                }
                updatePropertiesPanel();
                updateMeasurements();
                updateElementList();
                redraw();
            } else if (currentTool === 'measure') {
                // Click-to-measure between elements
                const clickedElement = findElementAt(x, y);
                if (clickedElement) {
                    if (!measurementFirstElement) {
                        // First element selected
                        measurementFirstElement = clickedElement;
                        selectedElement = clickedElement;
                        document.getElementById('statusText').textContent = 'SELECT 2ND ELEMENT';
                    } else {
                        // Second element selected - create measurement
                        if (clickedElement !== measurementFirstElement) {
                            addMeasurement(measurementFirstElement, clickedElement);
                        }
                        measurementFirstElement = null;
                        selectedElement = null;
                        updateStatus();
                    }
                    updatePropertiesPanel();
                    redraw();
                } else {
                    // Clicked empty space - cancel measurement
                    measurementFirstElement = null;
                    selectedElement = null;
                    updateStatus();
                    redraw();
                }
                // Also support free-form measurement line
                measureStart = { x, y };
                measureEnd = null;
            } else {
                placeElement(currentTool, x, y);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                saveState();
                validateField();
            }
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => { isDragging = false; });

        // ==================== ELEMENT PLACEMENT ====================
        function placeElement(type, x, y) {
            // Smart snapping is always enabled per element type rules
            switch (type) {
                case 'start': {
                    // Always use smart boundary snapping for start
                    const snap = snapStartToBoundary(x, y);
                    fieldElements.start = {
                        type: 'start',
                        x: snap.x,
                        y: snap.y,
                        edge: snap.edge,
                        direction: snap.direction,
                        id: 'start'
                    };
                    selectedElement = fieldElements.start;
                    break;
                }
                case 'target': {
                    // Always snap to zone center
                    const snap = snapTargetToZoneCenter(x, y);
                    fieldElements.target = {
                        type: 'target',
                        x: snap.x,
                        y: snap.y,
                        id: 'target'
                    };
                    selectedElement = fieldElements.target;
                    break;
                }
                case 'gate': {
                    if (nextGateIndex >= 6) return;
                    // Always snap to zone grid
                    const snap = snapGateToZone(x, y);
                    if (fieldElements.gates.find(g => g.col === snap.col && g.row === snap.row)) return;
                    const gate = {
                        type: 'gate',
                        label: GATE_LABELS[nextGateIndex],
                        x: snap.x,
                        y: snap.y,
                        col: snap.col,
                        row: snap.row,
                        width: ZONE_SIZE,
                        height: ZONE_SIZE,
                        id: `gate_${nextGateIndex}`,
                        colorIndex: nextGateIndex
                    };
                    fieldElements.gates.push(gate);
                    selectedElement = gate;
                    nextGateIndex++;
                    break;
                }
                case 'obstacle': {
                    // Smart line-constrained snapping
                    const snap = snapObstacleToLine(x, y);
                    const obstacle = {
                        type: 'obstacle',
                        x: snap.x,
                        y: snap.y,
                        width: snap.width,
                        height: snap.height,
                        orientation: snap.orientation,
                        placedOn: snap.placedOn,
                        id: `obs_${Date.now()}`
                    };
                    fieldElements.obstacles.push(obstacle);
                    selectedElement = obstacle;
                    break;
                }
                case 'bottle': {
                    // Smart interior line snapping
                    const snap = snapBottleToLine(x, y);
                    if (!snap.valid) {
                        // Try to nudge off intersection
                        const nudged = snapBottleToLine(x + 50, y);
                        if (nudged.valid) {
                            snap.x = nudged.x;
                            snap.y = nudged.y;
                        }
                    }
                    const bottle = {
                        type: 'bottle',
                        x: snap.x,
                        y: snap.y,
                        radius: BOTTLE_DIAMETER / 2,
                        placedOn: snap.placedOn,
                        id: `bottle_${Date.now()}`
                    };
                    fieldElements.bottles.push(bottle);
                    selectedElement = bottle;
                    break;
                }
            }

            saveState();
            updateElementList();
            updatePropertiesPanel();
            updateMeasurements();
            validateField();
            updateButtonStates();
            redraw();
        }

        function findElementAt(x, y) {
            for (const bottle of fieldElements.bottles) {
                if (Math.sqrt(Math.pow(x - bottle.x, 2) + Math.pow(y - bottle.y, 2)) < bottle.radius + 30) return bottle;
            }
            if (fieldElements.start && Math.sqrt(Math.pow(x - fieldElements.start.x, 2) + Math.pow(y - fieldElements.start.y, 2)) < 50) return fieldElements.start;
            if (fieldElements.target && Math.sqrt(Math.pow(x - fieldElements.target.x, 2) + Math.pow(y - fieldElements.target.y, 2)) < 50) return fieldElements.target;
            for (const obs of fieldElements.obstacles) {
                if (x >= obs.x - 20 && x <= obs.x + obs.width + 20 && y >= obs.y - 20 && y <= obs.y + obs.height + 20) return obs;
            }
            for (const gate of fieldElements.gates) {
                if (x >= gate.x && x <= gate.x + gate.width && y >= gate.y && y <= gate.y + gate.height) return gate;
            }
            return null;
        }

        function deleteElement(element) {
            if (element.type === 'start') fieldElements.start = null;
            else if (element.type === 'target') fieldElements.target = null;
            else if (element.type === 'gate') {
                const idx = fieldElements.gates.indexOf(element);
                if (idx > -1) {
                    fieldElements.gates.splice(idx, 1);
                    fieldElements.gates.forEach((g, i) => { g.label = GATE_LABELS[i]; g.id = `gate_${i}`; g.colorIndex = i; });
                    nextGateIndex = fieldElements.gates.length;
                }
            }
            else if (element.type === 'obstacle') {
                const idx = fieldElements.obstacles.indexOf(element);
                if (idx > -1) fieldElements.obstacles.splice(idx, 1);
            }
            else if (element.type === 'bottle') {
                const idx = fieldElements.bottles.indexOf(element);
                if (idx > -1) fieldElements.bottles.splice(idx, 1);
            }
            selectedElement = null;
            saveState();
            updateElementList();
            updatePropertiesPanel();
            updateMeasurements();
            validateField();
            redraw();
        }

        // ==================== COMPREHENSIVE VALIDATION ====================
        const VALIDATION_RULES = {
            // Priority 1 - Critical
            'EC-1': { name: 'Gate Count', priority: 1, category: 'elements' },
            'EC-2': { name: 'Bottle Count', priority: 1, category: 'elements' },
            'EC-4': { name: 'Start/Target Exist', priority: 1, category: 'elements' },
            'FG-1': { name: 'Field Bounds', priority: 1, category: 'geometry' },

            // Priority 2 - Required
            'SP-1': { name: 'Start on Boundary', priority: 2, category: 'start' },
            'SP-2': { name: 'Start Centered', priority: 2, category: 'start' },
            'SP-3': { name: 'Start Zone Clear', priority: 2, category: 'start' },
            'TP-1': { name: 'Target in Zone Center', priority: 2, category: 'target' },
            'GZ-4': { name: 'Gate Exclusions', priority: 2, category: 'gates' },
            'OB-2': { name: 'Obstacles on Lines', priority: 2, category: 'obstacles' },
            'OB-5': { name: 'Obstacle Clearance', priority: 2, category: 'obstacles' },
            'OB-7': { name: 'Wall Clearance', priority: 2, category: 'obstacles' },
            'WB-2': { name: 'Bottles on Lines', priority: 2, category: 'bottles' },
            'WB-4': { name: 'Bottle-Obstacle Clearance', priority: 2, category: 'bottles' },
            'CP-1': { name: 'Min Element Clearance', priority: 2, category: 'clearance' },

            // Priority 3 - Recommended
            'TP-2': { name: 'Target Distance', priority: 3, category: 'target' },
            'GZ-6': { name: 'Gate Distribution', priority: 3, category: 'gates' },
            'EC-3': { name: 'Obstacle Count', priority: 3, category: 'elements' },
        };

        function validateField() {
            const level = document.getElementById('level').value;
            const config = LEVELS[level];
            const results = [];

            // EC-1: Gate Count
            const gateCount = fieldElements.gates.length;
            results.push({
                id: 'EC-1',
                pass: gateCount === config.gates,
                warn: gateCount > 0 && gateCount !== config.gates,
                msg: `GATES: ${gateCount}/${config.gates}`,
                detail: gateCount < config.gates ? `Need ${config.gates - gateCount} more` :
                        (gateCount > config.gates ? `Remove ${gateCount - config.gates}` : 'Correct count')
            });

            // EC-2: Bottle Count
            const bottleCount = fieldElements.bottles.length;
            results.push({
                id: 'EC-2',
                pass: bottleCount === config.bottles,
                warn: bottleCount > 0 && bottleCount !== config.bottles,
                msg: `BOTTLES: ${bottleCount}/${config.bottles}`,
                detail: bottleCount < config.bottles ? `Need ${config.bottles - bottleCount} more` :
                        (bottleCount > config.bottles ? `Remove ${bottleCount - config.bottles}` : 'Correct count')
            });

            // EC-4: Start/Target Exist
            results.push({
                id: 'EC-4a',
                pass: !!fieldElements.start,
                msg: fieldElements.start ? 'START: placed' : 'START: missing',
                detail: fieldElements.start ? `Edge: ${fieldElements.start.edge}, Zone: (${Math.floor(fieldElements.start.x/ZONE_SIZE)},${Math.floor(fieldElements.start.y/ZONE_SIZE)})` : 'Required'
            });

            results.push({
                id: 'EC-4b',
                pass: !!fieldElements.target,
                msg: fieldElements.target ? 'TARGET: placed' : 'TARGET: missing',
                detail: fieldElements.target ? `Zone: (${Math.floor(fieldElements.target.x/ZONE_SIZE)},${Math.floor(fieldElements.target.y/ZONE_SIZE)})` : 'Required'
            });

            // FG-1: Field Bounds - check all elements within 2000x2500
            let boundsOk = true;
            let boundsIssue = '';
            const allElements = [
                ...fieldElements.obstacles,
                ...fieldElements.bottles,
                ...(fieldElements.start ? [fieldElements.start] : []),
                ...(fieldElements.target ? [fieldElements.target] : [])
            ];
            for (const el of allElements) {
                const bounds = getElementBounds(el);
                if (bounds && (bounds.x < 0 || bounds.x + bounds.w > FIELD_WIDTH || bounds.y < 0 || bounds.y + bounds.h > FIELD_LENGTH)) {
                    boundsOk = false;
                    boundsIssue = `${el.type} outside field`;
                    break;
                }
            }
            results.push({
                id: 'FG-1',
                pass: boundsOk,
                msg: boundsOk ? 'BOUNDS: ok' : 'BOUNDS: violation',
                detail: boundsOk ? 'All elements within 2000×2500mm' : boundsIssue
            });

            // SP-1: Start on Boundary
            if (fieldElements.start) {
                const s = fieldElements.start;
                const onBoundary = s.x <= TAPE_WIDTH + 5 || s.x >= FIELD_WIDTH - TAPE_WIDTH - 5 ||
                                   s.y <= TAPE_WIDTH + 5 || s.y >= FIELD_LENGTH - TAPE_WIDTH - 5;
                results.push({
                    id: 'SP-1',
                    pass: onBoundary,
                    msg: onBoundary ? 'START_EDGE: ok' : 'START_EDGE: not on boundary',
                    detail: onBoundary ? `On ${s.edge} edge` : 'Must be on field boundary'
                });
            }

            // SP-3: Start Zone Clear (no gates in start zone)
            if (fieldElements.start && fieldElements.gates.length > 0) {
                const startCol = Math.floor(fieldElements.start.x / ZONE_SIZE);
                const startRow = Math.floor(fieldElements.start.y / ZONE_SIZE);
                let gateTooClose = null;
                fieldElements.gates.forEach(gate => {
                    if (gate.col === startCol && gate.row === startRow) {
                        gateTooClose = gate.label;
                    }
                    // Also check adjacent zone based on entry direction
                    const gateCenter = { x: gate.x + ZONE_SIZE/2, y: gate.y + ZONE_SIZE/2 };
                    if (distance(fieldElements.start, gateCenter) < ZONE_SIZE) {
                        gateTooClose = gate.label;
                    }
                });
                results.push({
                    id: 'SP-3',
                    pass: !gateTooClose,
                    msg: gateTooClose ? 'START_ZONE: gate conflict' : 'START_ZONE: clear',
                    detail: gateTooClose ? `Gate ${gateTooClose} in/near start zone` : 'No gates blocking entry'
                });
            }

            // GZ-4: Gate not in target zone
            if (fieldElements.target && fieldElements.gates.length > 0) {
                const targetCol = Math.floor(fieldElements.target.x / ZONE_SIZE);
                const targetRow = Math.floor(fieldElements.target.y / ZONE_SIZE);
                let gateInTarget = fieldElements.gates.find(g => g.col === targetCol && g.row === targetRow);
                results.push({
                    id: 'GZ-4',
                    pass: !gateInTarget,
                    warn: !!gateInTarget,
                    msg: gateInTarget ? 'GATE_TARGET: overlap' : 'GATE_TARGET: ok',
                    detail: gateInTarget ? `Gate ${gateInTarget.label} in target zone` : 'Gates separate from target'
                });
            }

            // OB-2: Obstacles on grid lines
            let obsOnLines = true;
            let obsLineIssue = '';
            fieldElements.obstacles.forEach((obs, i) => {
                const centerX = obs.x + obs.width / 2;
                const centerY = obs.y + obs.height / 2;
                const onVertLine = GRID_LINES_X.some(lx => Math.abs(centerX - lx) < 30);
                const onHorizLine = GRID_LINES_Y.some(ly => Math.abs(centerY - ly) < 30);
                if (!onVertLine && !onHorizLine) {
                    obsOnLines = false;
                    obsLineIssue = `OBS_${String(i+1).padStart(2,'0')} not on grid line`;
                }
            });
            if (fieldElements.obstacles.length > 0) {
                results.push({
                    id: 'OB-2',
                    pass: obsOnLines,
                    warn: !obsOnLines,
                    msg: obsOnLines ? 'OBS_LINES: ok' : 'OBS_LINES: off-grid',
                    detail: obsOnLines ? 'All obstacles centered on lines' : obsLineIssue
                });
            }

            // OB-5: Obstacle-to-Obstacle Clearance (200mm)
            let obsClearanceOk = true;
            let obsClearanceIssue = '';
            for (let i = 0; i < fieldElements.obstacles.length; i++) {
                for (let j = i + 1; j < fieldElements.obstacles.length; j++) {
                    const clearance = calculateClearance(fieldElements.obstacles[i], fieldElements.obstacles[j]);
                    if (clearance < MIN_CLEARANCE) {
                        obsClearanceOk = false;
                        obsClearanceIssue = `OBS_${String(i+1).padStart(2,'0')} ↔ OBS_${String(j+1).padStart(2,'0')}: ${Math.round(clearance)}mm`;
                    }
                }
            }
            if (fieldElements.obstacles.length > 1) {
                results.push({
                    id: 'OB-5',
                    pass: obsClearanceOk,
                    msg: obsClearanceOk ? 'OBS_CLEARANCE: ≥200mm' : 'OBS_CLEARANCE: <200mm',
                    detail: obsClearanceOk ? 'All obstacles 200mm+ apart' : obsClearanceIssue
                });
            }

            // OB-7: Obstacle-to-Wall Clearance (150mm)
            let wallClearanceOk = true;
            let wallClearanceIssue = '';
            fieldElements.obstacles.forEach((obs, i) => {
                const margin = WALL_MARGIN;
                if (obs.x < margin || obs.x + obs.width > FIELD_WIDTH - margin ||
                    obs.y < margin || obs.y + obs.height > FIELD_LENGTH - margin) {
                    wallClearanceOk = false;
                    wallClearanceIssue = `OBS_${String(i+1).padStart(2,'0')} too close to wall`;
                }
            });
            if (fieldElements.obstacles.length > 0) {
                results.push({
                    id: 'OB-7',
                    pass: wallClearanceOk,
                    warn: !wallClearanceOk,
                    msg: wallClearanceOk ? 'WALL_CLEARANCE: ok' : 'WALL_CLEARANCE: <150mm',
                    detail: wallClearanceOk ? 'All obstacles 150mm+ from walls' : wallClearanceIssue
                });
            }

            // WB-2: Bottles on grid lines
            let btlOnLines = true;
            let btlLineIssue = '';
            fieldElements.bottles.forEach((btl, i) => {
                const onVertLine = GRID_LINES_X.slice(1, -1).some(lx => Math.abs(btl.x - lx) < 30); // Not on boundaries
                const onHorizLine = GRID_LINES_Y.slice(1, -1).some(ly => Math.abs(btl.y - ly) < 30);
                if (!onVertLine && !onHorizLine) {
                    btlOnLines = false;
                    btlLineIssue = `BTL_${String(i+1).padStart(2,'0')} not on grid line`;
                }
            });
            if (fieldElements.bottles.length > 0) {
                results.push({
                    id: 'WB-2',
                    pass: btlOnLines,
                    warn: !btlOnLines,
                    msg: btlOnLines ? 'BTL_LINES: ok' : 'BTL_LINES: off-grid',
                    detail: btlOnLines ? 'All bottles on interior lines' : btlLineIssue
                });
            }

            // WB-4: Bottle-to-Obstacle Clearance
            let btlObsClearanceOk = true;
            let btlObsClearanceIssue = '';
            fieldElements.bottles.forEach((btl, bi) => {
                fieldElements.obstacles.forEach((obs, oi) => {
                    const clearance = calculateClearance(btl, obs);
                    if (clearance < MIN_CLEARANCE) {
                        btlObsClearanceOk = false;
                        btlObsClearanceIssue = `BTL_${String(bi+1).padStart(2,'0')} ↔ OBS_${String(oi+1).padStart(2,'0')}: ${Math.round(clearance)}mm`;
                    }
                });
            });
            if (fieldElements.bottles.length > 0 && fieldElements.obstacles.length > 0) {
                results.push({
                    id: 'WB-4',
                    pass: btlObsClearanceOk,
                    msg: btlObsClearanceOk ? 'BTL_OBS_CLR: ≥200mm' : 'BTL_OBS_CLR: <200mm',
                    detail: btlObsClearanceOk ? 'Bottles clear of obstacles' : btlObsClearanceIssue
                });
            }

            // TP-2: Target distance from start (recommended ≥1000mm)
            if (fieldElements.start && fieldElements.target) {
                const targetDist = distance(fieldElements.start, fieldElements.target);
                results.push({
                    id: 'TP-2',
                    pass: targetDist >= 1000,
                    warn: targetDist >= 500 && targetDist < 1000,
                    msg: `TARGET_DIST: ${Math.round(targetDist)}mm`,
                    detail: targetDist >= 1000 ? 'Good challenge distance' :
                            (targetDist >= 500 ? 'Consider moving target farther' : 'Target too close to start')
                });
            }

            // EC-3: Obstacle count (0-10)
            const obsCount = fieldElements.obstacles.length;
            results.push({
                id: 'EC-3',
                pass: obsCount <= 10,
                warn: obsCount > 8,
                msg: `OBSTACLES: ${obsCount}/10`,
                detail: obsCount === 0 ? '+50pts penalty if no obstacles' :
                        (obsCount <= 10 ? 'Within limits' : 'Maximum 10 obstacles')
            });

            validationResults = results;
            updateValidationPanel();
            updateStatus();
        }

        function checkCollision(obj1, obj2, clearance = 0) {
            const r1 = getObjectRect(obj1);
            const r2 = getObjectRect(obj2);
            return !(r1.x + r1.w + clearance < r2.x || r2.x + r2.w + clearance < r1.x ||
                    r1.y + r1.h + clearance < r2.y || r2.y + r2.h + clearance < r1.y);
        }

        function getObjectRect(obj) {
            if (obj.type === 'bottle') return { x: obj.x - obj.radius, y: obj.y - obj.radius, w: obj.radius * 2, h: obj.radius * 2 };
            return { x: obj.x, y: obj.y, w: obj.width || 50, h: obj.height || 50 };
        }

        function updateValidationPanel() {
            const panel = document.getElementById('validationPanel');
            if (validationResults.length === 0) {
                panel.innerHTML = '<div class="empty-state">awaiting elements</div>';
                return;
            }

            // Count pass/fail/warn
            const passCount = validationResults.filter(r => r.pass && !r.warn).length;
            const warnCount = validationResults.filter(r => r.warn).length;
            const failCount = validationResults.filter(r => !r.pass).length;

            let html = `<div class="validation-summary">
                <span class="vs-pass">${passCount} ✓</span>
                <span class="vs-warn">${warnCount} ⚠</span>
                <span class="vs-fail">${failCount} ✗</span>
            </div>`;

            html += validationResults.map(r => {
                const cls = r.pass ? (r.warn ? 'warn' : 'pass') : 'fail';
                const icon = r.pass ? (r.warn ? '⚠' : '✓') : '✗';
                const detail = r.detail || '';
                const ruleId = r.id ? `<span class="rule-id">${r.id}</span>` : '';
                return `<div class="validation-item ${cls}">
                    <div class="validation-main">
                        <span class="validation-icon">${icon}</span>
                        <span>${r.msg}</span>
                        ${ruleId}
                    </div>
                    ${detail ? `<div class="validation-detail">${detail}</div>` : ''}
                </div>`;
            }).join('');

            panel.innerHTML = html;
        }

        function updateStatus() {
            // Status badge removed from UI - validation still runs but no display
        }

        // ==================== AUTO GENERATION ====================

        // Get all valid start positions on field boundaries
        function getValidStartPositions() {
            const positions = [];
            const verticalCenters = [250, 750, 1250, 1750, 2250]; // For left/right edges
            const horizontalCenters = [250, 750, 1250, 1750]; // For top/bottom edges

            // Left edge positions (facing East into field)
            for (const y of verticalCenters) {
                positions.push({ x: TAPE_WIDTH, y: y, edge: 'left', direction: 'E' });
            }

            // Right edge positions (facing West into field)
            for (const y of verticalCenters) {
                positions.push({ x: FIELD_WIDTH - TAPE_WIDTH, y: y, edge: 'right', direction: 'W' });
            }

            // Bottom edge positions (facing North into field)
            for (const x of horizontalCenters) {
                positions.push({ x: x, y: TAPE_WIDTH, edge: 'bottom', direction: 'N' });
            }

            // Top edge positions (facing South into field)
            for (const x of horizontalCenters) {
                positions.push({ x: x, y: FIELD_LENGTH - TAPE_WIDTH, edge: 'top', direction: 'S' });
            }

            return positions;
        }

        function autoGenerate() {
            console.log('=== autoGenerate() called ===');
            genStartTime = performance.now();
            const level = document.getElementById('autoLevel')?.value || document.getElementById('level').value;
            const numObstacles = parseInt(document.getElementById('autoObstacles')?.value || 6);
            const config = LEVELS[level];

            console.log(`Generating field: level=${level}, obstacles=${numObstacles}, gates=${config.gates}, bottles=${config.bottles}`);

            fieldElements = { start: null, target: null, gates: [], obstacles: [], bottles: [] };
            nextGateIndex = 0;

            const startPositions = getValidStartPositions();
            const startPos = startPositions[Math.floor(Math.random() * startPositions.length)];
            fieldElements.start = {
                type: 'start',
                x: startPos.x,
                y: startPos.y,
                edge: startPos.edge,
                direction: startPos.direction,
                id: 'start'
            };
            console.log(`Start placed at (${startPos.x}, ${startPos.y}) on ${startPos.edge} edge, facing ${startPos.direction}`);

            const startCol = Math.floor(startPos.x / ZONE_SIZE);
            const startRow = Math.floor(startPos.y / ZONE_SIZE);

            const targetOptions = [];
            for (let c = 0; c < GRID_COLS; c++) {
                for (let r = 0; r < GRID_ROWS; r++) {
                    if (Math.abs(c - startCol) + Math.abs(r - startRow) >= 3) targetOptions.push({ col: c, row: r });
                }
            }
            const targetZone = targetOptions[Math.floor(Math.random() * targetOptions.length)];
            fieldElements.target = { type: 'target', x: targetZone.col * ZONE_SIZE + ZONE_SIZE / 2, y: targetZone.row * ZONE_SIZE + ZONE_SIZE / 2, id: 'target' };

            // SP-3: Exclude start zone and adjacent zones from gates
            const usedZones = new Set([`${startCol},${startRow}`]);
            for (let dc = -1; dc <= 1; dc++) {
                for (let dr = -1; dr <= 1; dr++) {
                    const nc = startCol + dc, nr = startRow + dr;
                    if (nc >= 0 && nc < GRID_COLS && nr >= 0 && nr < GRID_ROWS) usedZones.add(`${nc},${nr}`);
                }
            }

            // GZ-4: Also exclude target zone from gates
            usedZones.add(`${targetZone.col},${targetZone.row}`);

            for (let i = 0; i < config.gates; i++) {
                const available = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    for (let r = 0; r < GRID_ROWS; r++) {
                        if (!usedZones.has(`${c},${r}`)) available.push({ col: c, row: r });
                    }
                }
                if (available.length === 0) break;
                const chosen = available[Math.floor(Math.random() * available.length)];
                usedZones.add(`${chosen.col},${chosen.row}`);
                fieldElements.gates.push({
                    type: 'gate', label: GATE_LABELS[i],
                    x: chosen.col * ZONE_SIZE, y: chosen.row * ZONE_SIZE,
                    col: chosen.col, row: chosen.row, width: ZONE_SIZE, height: ZONE_SIZE,
                    id: `gate_${i}`, colorIndex: i
                });
                nextGateIndex++;
            }

            for (let i = 0; i < numObstacles; i++) {
                for (let attempt = 0; attempt < 100; attempt++) {
                    const horizontal = Math.random() > 0.5;
                    const width = horizontal ? OBSTACLE_LENGTH : OBSTACLE_DEPTH;
                    const height = horizontal ? OBSTACLE_DEPTH : OBSTACLE_LENGTH;
                    const lineX = GRID_LINES_X[Math.floor(Math.random() * GRID_LINES_X.length)];
                    const lineY = GRID_LINES_Y[Math.floor(Math.random() * GRID_LINES_Y.length)];
                    const ox = lineX - width / 2, oy = lineY - height / 2;

                    if (ox < WALL_MARGIN || ox + width > FIELD_WIDTH - WALL_MARGIN ||
                        oy < WALL_MARGIN || oy + height > FIELD_LENGTH - WALL_MARGIN) continue;

                    const newObs = { x: ox, y: oy, width, height, type: 'obstacle' };
                    let collision = fieldElements.obstacles.some(obs => checkCollision(newObs, obs, MIN_CLEARANCE));
                    if (fieldElements.start && checkCollision(newObs, { x: fieldElements.start.x - 100, y: fieldElements.start.y - 100, width: 200, height: 200 }, 0)) collision = true;
                    if (fieldElements.target && checkCollision(newObs, { x: fieldElements.target.x - 100, y: fieldElements.target.y - 100, width: 200, height: 200 }, 0)) collision = true;

                    if (!collision) {
                        fieldElements.obstacles.push({ ...newObs, orientation: horizontal ? 'horizontal' : 'vertical', id: `obs_${Date.now()}_${i}` });
                        break;
                    }
                }
            }

            // WB-2, WB-4, WB-6: Place bottles on interior grid lines with proper clearances
            for (let i = 0; i < config.bottles; i++) {
                for (let attempt = 0; attempt < 100; attempt++) {
                    // WB-2: Only interior grid lines (not boundaries)
                    const lineX = GRID_LINES_X[1 + Math.floor(Math.random() * (GRID_LINES_X.length - 2))];
                    const lineY = GRID_LINES_Y[1 + Math.floor(Math.random() * (GRID_LINES_Y.length - 2))];
                    const newBottle = { x: lineX, y: lineY, radius: BOTTLE_DIAMETER / 2, type: 'bottle' };

                    // WB-4: Check bottle-to-obstacle clearance (200mm)
                    let collision = fieldElements.obstacles.some(obs => {
                        const clearance = calculateClearance(newBottle, obs);
                        return clearance < MIN_CLEARANCE;
                    });

                    // WB-6: Check bottle-to-bottle clearance (150mm)
                    collision = collision || fieldElements.bottles.some(b =>
                        distance({ x: newBottle.x, y: newBottle.y }, { x: b.x, y: b.y }) < BOTTLE_DIAMETER + 100
                    );

                    // Keep away from start
                    if (fieldElements.start && distance(newBottle, fieldElements.start) < 250) collision = true;

                    // Keep away from target
                    if (fieldElements.target && distance(newBottle, fieldElements.target) < 150) collision = true;

                    if (!collision) {
                        fieldElements.bottles.push({ ...newBottle, id: `bottle_${Date.now()}_${i}` });
                        break;
                    }
                }
            }

            document.getElementById('level').value = level;
            if (document.getElementById('autoLevel')) document.getElementById('autoLevel').value = level;

            console.log(`Field generated: ${fieldElements.gates.length} gates, ${fieldElements.obstacles.length} obstacles, ${fieldElements.bottles.length} bottles`);

            saveState();
            updateElementList();
            updatePropertiesPanel();
            updateMeasurements();
            validateField();
            redraw();
            try {
                updateRiskDisplay(document.getElementById('riskAppetite').value);
            } catch (e) {
                console.error('updateRiskDisplay error:', e);
            }
            generateRoute();

            const genTime = Math.round(performance.now() - genStartTime);
            document.getElementById('statusText').textContent = `GENERATED // ${genTime}ms`;

            // Update status badge to success
            const badge = document.getElementById('statusBadge');
            badge.classList.remove('warning', 'error');

            console.log(`=== Generation complete in ${genTime}ms ===`);
        }

        // ==================== UI UPDATES ====================
        function updateElementList() {
            const list = document.getElementById('elementList');
            const countEl = document.getElementById('elementCount');
            let items = [];

            if (fieldElements.start) {
                const dir = fieldElements.start.direction || '?';
                items.push({ el: fieldElements.start, color: '#7fd962', name: 'START', detail: `${fieldElements.start.edge} → ${dir}` });
            }
            if (fieldElements.target) {
                items.push({ el: fieldElements.target, color: '#ff9940', name: 'TARGET', detail: `(${Math.round(fieldElements.target.x)},${Math.round(fieldElements.target.y)})` });
            }
            fieldElements.gates.forEach(g => {
                items.push({ el: g, color: GATE_COLORS[g.colorIndex], name: `GATE_${g.label}`, detail: `zone(${g.col},${g.row})` });
            });
            fieldElements.obstacles.forEach((o, i) => {
                items.push({ el: o, color: '#454d5d', name: `OBS_${String(i+1).padStart(2,'0')}`, detail: o.orientation.slice(0,4) });
            });
            fieldElements.bottles.forEach((b, i) => {
                items.push({ el: b, color: '#5ccfe6', name: `BTL_${String(i+1).padStart(2,'0')}`, detail: `(${Math.round(b.x)},${Math.round(b.y)})` });
            });

            countEl.textContent = items.length;

            if (items.length === 0) {
                list.innerHTML = '<div class="empty-state">no elements placed</div>';
                return;
            }

            list.innerHTML = items.map(item => `
                <div class="element-item ${selectedElement === item.el ? 'selected' : ''}" data-id="${item.el.id}">
                    <div class="element-item-info">
                        <div class="element-dot" style="background: ${item.color}"></div>
                        <span class="element-name">${item.name}</span>
                        <span class="element-detail">${item.detail}</span>
                    </div>
                    <button class="element-delete" data-id="${item.el.id}">×</button>
                </div>
            `).join('');

            list.querySelectorAll('.element-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('element-delete')) return;
                    selectedElement = findElementById(item.dataset.id);
                    updateElementList();
                    updatePropertiesPanel();
                    updateMeasurements();
                    redraw();
                });
            });

            list.querySelectorAll('.element-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const element = findElementById(btn.dataset.id);
                    if (element) deleteElement(element);
                });
            });
        }

        function findElementById(id) {
            if (fieldElements.start?.id === id) return fieldElements.start;
            if (fieldElements.target?.id === id) return fieldElements.target;
            for (const g of fieldElements.gates) if (g.id === id) return g;
            for (const o of fieldElements.obstacles) if (o.id === id) return o;
            for (const b of fieldElements.bottles) if (b.id === id) return b;
            return null;
        }

        function updatePropertiesPanel() {
            const panel = document.getElementById('propertiesPanel');
            if (!selectedElement) {
                panel.innerHTML = '<div class="empty-state">click element to edit</div>';
                return;
            }

            const el = selectedElement;
            let html = '<div class="properties-content">';

            if (el.type === 'start') {
                html += `
                    <div class="form-row">
                        <div class="form-group">
                            <label>POSITION</label>
                            <input type="number" value="${Math.round(el.edge === 'left' || el.edge === 'right' ? el.y : el.x)}" onchange="updateStartPosition(this.value)">
                        </div>
                        <div class="form-group">
                            <label>EDGE</label>
                            <select onchange="updateStartEdge(this.value)">
                                <option value="bottom" ${el.edge === 'bottom' ? 'selected' : ''}>bottom</option>
                                <option value="top" ${el.edge === 'top' ? 'selected' : ''}>top</option>
                                <option value="left" ${el.edge === 'left' ? 'selected' : ''}>left</option>
                                <option value="right" ${el.edge === 'right' ? 'selected' : ''}>right</option>
                            </select>
                        </div>
                    </div>`;
            } else if (el.type === 'target') {
                html += `
                    <div class="form-row">
                        <div class="form-group">
                            <label>X</label>
                            <input type="number" value="${Math.round(el.x)}" onchange="updateElementProperty('x', this.value)">
                        </div>
                        <div class="form-group">
                            <label>Y</label>
                            <input type="number" value="${Math.round(el.y)}" onchange="updateElementProperty('y', this.value)">
                        </div>
                    </div>
                    <button class="btn full-width mt-2" onclick="snapTargetToZone()">SNAP_TO_ZONE</button>`;
            } else if (el.type === 'gate') {
                html += `
                    <div class="form-row">
                        <div class="form-group">
                            <label>COL</label>
                            <input type="number" value="${el.col}" min="0" max="3" onchange="updateGateZone('col', this.value)">
                        </div>
                        <div class="form-group">
                            <label>ROW</label>
                            <input type="number" value="${el.row}" min="0" max="4" onchange="updateGateZone('row', this.value)">
                        </div>
                    </div>`;
            } else if (el.type === 'obstacle') {
                html += `
                    <div class="form-row">
                        <div class="form-group">
                            <label>X</label>
                            <input type="number" value="${Math.round(el.x)}" onchange="updateElementProperty('x', this.value)">
                        </div>
                        <div class="form-group">
                            <label>Y</label>
                            <input type="number" value="${Math.round(el.y)}" onchange="updateElementProperty('y', this.value)">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>ORIENTATION</label>
                        <select onchange="updateObstacleOrientation(this.value)">
                            <option value="horizontal" ${el.orientation === 'horizontal' ? 'selected' : ''}>horizontal // 406×89</option>
                            <option value="vertical" ${el.orientation === 'vertical' ? 'selected' : ''}>vertical // 89×406</option>
                        </select>
                    </div>`;
            } else if (el.type === 'bottle') {
                html += `
                    <div class="form-row">
                        <div class="form-group">
                            <label>X</label>
                            <input type="number" value="${Math.round(el.x)}" onchange="updateElementProperty('x', this.value)">
                        </div>
                        <div class="form-group">
                            <label>Y</label>
                            <input type="number" value="${Math.round(el.y)}" onchange="updateElementProperty('y', this.value)">
                        </div>
                    </div>
                    <button class="btn full-width mt-2" onclick="snapBottleToGrid()">SNAP_TO_GRID</button>`;
            }

            html += `<button class="btn btn-error full-width mt-3" onclick="deleteElement(selectedElement)">DELETE</button>`;
            html += '</div>';
            panel.innerHTML = html;
        }

        function updateElementProperty(prop, value) {
            if (!selectedElement) return;
            selectedElement[prop] = parseFloat(value);
            updateElementList();
            updateMeasurements();
            validateField();
            redraw();
        }

        function updateStartPosition(value) {
            if (!selectedElement || selectedElement.type !== 'start') return;
            const pos = parseFloat(value);
            if (selectedElement.edge === 'left' || selectedElement.edge === 'right') selectedElement.y = pos;
            else selectedElement.x = pos;
            updatePropertiesPanel();
            updateElementList();
            validateField();
            redraw();
        }

        function updateStartEdge(edge) {
            if (!selectedElement || selectedElement.type !== 'start') return;
            selectedElement.edge = edge;
            switch (edge) {
                case 'bottom': selectedElement.y = TAPE_WIDTH; break;
                case 'top': selectedElement.y = FIELD_LENGTH - TAPE_WIDTH; break;
                case 'left': selectedElement.x = TAPE_WIDTH; break;
                case 'right': selectedElement.x = FIELD_WIDTH - TAPE_WIDTH; break;
            }
            updatePropertiesPanel();
            updateElementList();
            validateField();
            redraw();
        }

        function snapTargetToZone() {
            if (!selectedElement || selectedElement.type !== 'target') return;
            const col = Math.floor(selectedElement.x / ZONE_SIZE);
            const row = Math.floor(selectedElement.y / ZONE_SIZE);
            selectedElement.x = col * ZONE_SIZE + ZONE_SIZE / 2;
            selectedElement.y = row * ZONE_SIZE + ZONE_SIZE / 2;
            updatePropertiesPanel();
            updateElementList();
            validateField();
            redraw();
        }

        function snapBottleToGrid() {
            if (!selectedElement || selectedElement.type !== 'bottle') return;
            selectedElement.x = snapToGridLine(selectedElement.x, GRID_LINES_X);
            selectedElement.y = snapToGridLine(selectedElement.y, GRID_LINES_Y);
            updatePropertiesPanel();
            updateElementList();
            validateField();
            redraw();
        }

        function updateGateZone(prop, value) {
            if (!selectedElement || selectedElement.type !== 'gate') return;
            selectedElement[prop] = parseInt(value);
            selectedElement.x = selectedElement.col * ZONE_SIZE;
            selectedElement.y = selectedElement.row * ZONE_SIZE;
            updatePropertiesPanel();
            updateElementList();
            validateField();
            redraw();
        }

        function updateObstacleOrientation(orientation) {
            if (!selectedElement || selectedElement.type !== 'obstacle') return;
            selectedElement.orientation = orientation;
            selectedElement.width = orientation === 'horizontal' ? OBSTACLE_LENGTH : OBSTACLE_DEPTH;
            selectedElement.height = orientation === 'horizontal' ? OBSTACLE_DEPTH : OBSTACLE_LENGTH;
            updateElementList();
            validateField();
            redraw();
        }

        function updateMeasurements() {
            const panel = document.getElementById('measurementsPanel');
            if (!panel) return; // Panel not yet in DOM
            let rows = [];

            if (selectedElement && fieldElements.start && selectedElement !== fieldElements.start) {
                const center = getElementCenter(selectedElement);
                const dist = distance(center, fieldElements.start);
                rows.push({ label: '→ START', value: `${Math.round(dist)}mm` });
            }

            if (selectedElement && fieldElements.target && selectedElement !== fieldElements.target) {
                const center = getElementCenter(selectedElement);
                const dist = distance(center, fieldElements.target);
                rows.push({ label: '→ TARGET', value: `${Math.round(dist)}mm` });
            }

            if (selectedElement?.type === 'bottle') {
                fieldElements.gates.forEach(gate => {
                    const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                    const dist = distance(selectedElement, gateCenter);
                    rows.push({ label: `→ GATE_${gate.label}`, value: `${Math.round(dist)}mm` });
                });
            }

            if (fieldElements.start && fieldElements.target) {
                const totalDist = distance(fieldElements.start, fieldElements.target);
                rows.push({ label: 'START→TARGET', value: `${Math.round(totalDist)}mm`, highlight: true });
            }

            if (rows.length === 0) {
                panel.innerHTML = '<div class="empty-state">select element</div>';
                return;
            }

            panel.innerHTML = rows.map(r => `
                <div class="measurement-row">
                    <span class="measurement-label">${r.label}</span>
                    <span class="measurement-value ${r.highlight ? 'highlight' : ''}">${r.value}</span>
                </div>
            `).join('');
        }

        function getElementCenter(el) {
            if (el.type === 'bottle' || el.type === 'start' || el.type === 'target') return { x: el.x, y: el.y };
            return { x: el.x + (el.width || 0) / 2, y: el.y + (el.height || 0) / 2 };
        }

        function getTooltipContent(el) {
            let html = '<div class="tooltip-title">';
            if (el.type === 'start') {
                html += 'START</div>';
                html += `<div class="tooltip-row"><span>edge:</span><span class="tooltip-value">${el.edge}</span></div>`;
                html += `<div class="tooltip-row"><span>zone:</span><span class="tooltip-value">(${Math.floor(el.x/ZONE_SIZE)},${Math.floor(el.y/ZONE_SIZE)})</span></div>`;
            } else if (el.type === 'target') {
                html += 'TARGET</div>';
                html += `<div class="tooltip-row"><span>pos:</span><span class="tooltip-value">(${Math.round(el.x)}, ${Math.round(el.y)})</span></div>`;
                html += `<div class="tooltip-row"><span>zone:</span><span class="tooltip-value">(${Math.floor(el.x/ZONE_SIZE)},${Math.floor(el.y/ZONE_SIZE)})</span></div>`;
            } else if (el.type === 'gate') {
                html += `GATE_${el.label}</div>`;
                html += `<div class="tooltip-row"><span>zone:</span><span class="tooltip-value">(${el.col}, ${el.row})</span></div>`;
                html += `<div class="tooltip-row"><span>pos:</span><span class="tooltip-value">(${el.x}, ${el.y})</span></div>`;
                html += `<div class="tooltip-row"><span>bonus:</span><span class="tooltip-value">-15pts</span></div>`;
            } else if (el.type === 'obstacle') {
                const idx = fieldElements.obstacles.indexOf(el) + 1;
                html += `OBS_${String(idx).padStart(2,'0')}</div>`;
                html += `<div class="tooltip-row"><span>size:</span><span class="tooltip-value">${el.width}×${el.height}mm</span></div>`;
                html += `<div class="tooltip-row"><span>pos:</span><span class="tooltip-value">(${Math.round(el.x)}, ${Math.round(el.y)})</span></div>`;
                html += `<div class="tooltip-row"><span>orient:</span><span class="tooltip-value">${el.orientation}</span></div>`;
                html += `<div class="tooltip-row"><span>penalty:</span><span class="tooltip-value">+70pts</span></div>`;
            } else if (el.type === 'bottle') {
                const idx = fieldElements.bottles.indexOf(el) + 1;
                html += `BTL_${String(idx).padStart(2,'0')}</div>`;
                html += `<div class="tooltip-row"><span>pos:</span><span class="tooltip-value">(${Math.round(el.x)}, ${Math.round(el.y)})</span></div>`;
                html += `<div class="tooltip-row"><span>bonus:</span><span class="tooltip-value">-15pts</span></div>`;
            }
            return html;
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // ==================== DRAWING ====================
        function redraw() {
            ctx.fillStyle = '#151a21';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Boundary - outer frame
            ctx.fillStyle = '#8a919d';
            ctx.fillRect(0, 0, FIELD_WIDTH * SCALE, FIELD_LENGTH * SCALE);

            // Field interior - slightly lighter than pure bg
            ctx.fillStyle = '#1e252e';
            ctx.fillRect(TAPE_WIDTH * SCALE, TAPE_WIDTH * SCALE,
                        (FIELD_WIDTH - 2 * TAPE_WIDTH) * SCALE,
                        (FIELD_LENGTH - 2 * TAPE_WIDTH) * SCALE);

            // Grid
            if (document.getElementById('showGrid').checked) {
                // Grid lines - much more visible
                ctx.strokeStyle = '#3d4650';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                GRID_LINES_X.forEach(x => {
                    ctx.beginPath();
                    ctx.moveTo(x * SCALE, 0);
                    ctx.lineTo(x * SCALE, FIELD_LENGTH * SCALE);
                    ctx.stroke();
                });
                GRID_LINES_Y.forEach(y => {
                    ctx.beginPath();
                    ctx.moveTo(0, (FIELD_LENGTH - y) * SCALE);
                    ctx.lineTo(FIELD_WIDTH * SCALE, (FIELD_LENGTH - y) * SCALE);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // Zone labels
                if (document.getElementById('showZoneLabels').checked) {
                    ctx.fillStyle = '#5c6370';
                    ctx.font = '9px JetBrains Mono';
                    ctx.textAlign = 'left';
                    for (let col = 0; col < GRID_COLS; col++) {
                        for (let row = 0; row < GRID_ROWS; row++) {
                            const label = `${col},${row}`;
                            const x = col * ZONE_SIZE * SCALE + 4;
                            const y = (FIELD_LENGTH - row * ZONE_SIZE - ZONE_SIZE) * SCALE + 12;
                            ctx.fillText(label, x, y);
                        }
                    }
                }
            }

            // Draw snap guides when dragging or placing elements (always enabled)
            if (isDragging || ['gate', 'start', 'target', 'obstacle', 'bottle'].includes(currentTool)) {
                ctx.globalAlpha = 0.4;

                if (currentTool === 'gate' || (isDragging && selectedElement?.type === 'gate')) {
                    // Show valid zone corners for gates
                    ctx.fillStyle = '#ff9940';
                    for (let col = 0; col < GRID_COLS; col++) {
                        for (let row = 0; row < GRID_ROWS; row++) {
                            const x = col * ZONE_SIZE * SCALE;
                            const y = (FIELD_LENGTH - row * ZONE_SIZE - ZONE_SIZE) * SCALE;
                            ctx.strokeStyle = '#ff9940';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x + 2, y + 2, ZONE_SIZE * SCALE - 4, ZONE_SIZE * SCALE - 4);
                        }
                    }
                }

                if (currentTool === 'target' || (isDragging && selectedElement?.type === 'target')) {
                    // Show valid zone centers for target
                    ctx.fillStyle = '#ff9940';
                    const validX = [250, 750, 1250, 1750];
                    const validY = [250, 750, 1250, 1750, 2250];
                    for (const vx of validX) {
                        for (const vy of validY) {
                            const cx = vx * SCALE;
                            const cy = (FIELD_LENGTH - vy) * SCALE;
                            ctx.beginPath();
                            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                if (currentTool === 'start' || (isDragging && selectedElement?.type === 'start')) {
                    // Show valid start positions on boundaries
                    ctx.fillStyle = '#7fd962';
                    // Left edge
                    [250, 750, 1250, 1750, 2250].forEach(vy => {
                        ctx.beginPath();
                        ctx.arc(TAPE_WIDTH * SCALE, (FIELD_LENGTH - vy) * SCALE, 8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    // Right edge
                    [250, 750, 1250, 1750, 2250].forEach(vy => {
                        ctx.beginPath();
                        ctx.arc((FIELD_WIDTH - TAPE_WIDTH) * SCALE, (FIELD_LENGTH - vy) * SCALE, 8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    // Bottom edge
                    [250, 750, 1250, 1750].forEach(vx => {
                        ctx.beginPath();
                        ctx.arc(vx * SCALE, (FIELD_LENGTH - TAPE_WIDTH) * SCALE, 8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    // Top edge
                    [250, 750, 1250, 1750].forEach(vx => {
                        ctx.beginPath();
                        ctx.arc(vx * SCALE, TAPE_WIDTH * SCALE, 8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                if (currentTool === 'obstacle' || (isDragging && selectedElement?.type === 'obstacle')) {
                    // Show grid lines where obstacles can be placed
                    ctx.strokeStyle = '#5ccfe6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    // Vertical lines
                    [0, 500, 1000, 1500, 2000].forEach(vx => {
                        ctx.beginPath();
                        ctx.moveTo(vx * SCALE, WALL_MARGIN * SCALE);
                        ctx.lineTo(vx * SCALE, (FIELD_LENGTH - WALL_MARGIN) * SCALE);
                        ctx.stroke();
                    });
                    // Horizontal lines
                    [0, 500, 1000, 1500, 2000, 2500].forEach(vy => {
                        ctx.beginPath();
                        ctx.moveTo(WALL_MARGIN * SCALE, (FIELD_LENGTH - vy) * SCALE);
                        ctx.lineTo((FIELD_WIDTH - WALL_MARGIN) * SCALE, (FIELD_LENGTH - vy) * SCALE);
                        ctx.stroke();
                    });
                    ctx.setLineDash([]);
                }

                if (currentTool === 'bottle' || (isDragging && selectedElement?.type === 'bottle')) {
                    // Show interior lines where bottles can be placed
                    ctx.strokeStyle = '#6ad8f0';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    // Interior vertical lines only
                    [500, 1000, 1500].forEach(vx => {
                        ctx.beginPath();
                        ctx.moveTo(vx * SCALE, WALL_MARGIN * SCALE);
                        ctx.lineTo(vx * SCALE, (FIELD_LENGTH - WALL_MARGIN) * SCALE);
                        ctx.stroke();
                    });
                    // Interior horizontal lines only
                    [500, 1000, 1500, 2000].forEach(vy => {
                        ctx.beginPath();
                        ctx.moveTo(WALL_MARGIN * SCALE, (FIELD_LENGTH - vy) * SCALE);
                        ctx.lineTo((FIELD_WIDTH - WALL_MARGIN) * SCALE, (FIELD_LENGTH - vy) * SCALE);
                        ctx.stroke();
                    });
                    ctx.setLineDash([]);
                }

                ctx.globalAlpha = 1.0;
            }

            // Outer boundary stroke - thick and visible
            ctx.strokeStyle = '#8a919d';
            ctx.lineWidth = 3;
            ctx.strokeRect(1.5, 1.5, FIELD_WIDTH * SCALE - 3, FIELD_LENGTH * SCALE - 3);

            // Gates
            fieldElements.gates.forEach(gate => {
                const x = gate.x * SCALE;
                const y = (FIELD_LENGTH - gate.y - ZONE_SIZE) * SCALE;
                const isSelected = selectedElement === gate;
                const color = GATE_COLORS[gate.colorIndex];

                ctx.fillStyle = color + '26';
                ctx.fillRect(x, y, ZONE_SIZE * SCALE, ZONE_SIZE * SCALE);
                ctx.strokeStyle = isSelected ? '#e6e6e6' : color;
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.strokeRect(x, y, ZONE_SIZE * SCALE, ZONE_SIZE * SCALE);

                ctx.fillStyle = color;
                ctx.font = 'bold 20px IBM Plex Mono';
                ctx.textAlign = 'center';
                ctx.fillText(gate.label, x + ZONE_SIZE * SCALE / 2, y + ZONE_SIZE * SCALE / 2 + 7);
            });

            // Obstacles
            fieldElements.obstacles.forEach(obs => {
                const x = obs.x * SCALE;
                const y = (FIELD_LENGTH - obs.y - obs.height) * SCALE;
                const w = obs.width * SCALE;
                const h = obs.height * SCALE;
                const isSelected = selectedElement === obs;

                // Base fill
                ctx.fillStyle = '#525a6a';
                ctx.fillRect(x, y, w, h);

                // Diagonal stripes for texture
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.clip();
                ctx.strokeStyle = '#454d5d';
                ctx.lineWidth = 2;
                for (let i = -h; i < w + h; i += 8) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y);
                    ctx.lineTo(x + i + h, y + h);
                    ctx.stroke();
                }
                ctx.restore();

                // Border stroke - always visible
                ctx.strokeStyle = isSelected ? '#e6e6e6' : '#6a7080';
                ctx.lineWidth = isSelected ? 2.5 : 2;
                ctx.strokeRect(x, y, w, h);

                // Glow effect when selected
                if (isSelected) {
                    ctx.shadowColor = 'rgba(230, 230, 230, 0.4)';
                    ctx.shadowBlur = 8;
                    ctx.strokeRect(x, y, w, h);
                    ctx.shadowBlur = 0;
                }

                if (document.getElementById('showClearance').checked) {
                    // Draw pathfinder inflation zone (outermost - 400mm total)
                    const inflationRadius = 400; // robotRadius(150) + clearance(200) + safety(50)
                    ctx.fillStyle = 'rgba(255, 107, 107, 0.08)';
                    ctx.fillRect(
                        x - inflationRadius * SCALE,
                        y - inflationRadius * SCALE,
                        (obs.width + 2 * inflationRadius) * SCALE,
                        (obs.height + 2 * inflationRadius) * SCALE
                    );
                    ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(
                        x - inflationRadius * SCALE,
                        y - inflationRadius * SCALE,
                        (obs.width + 2 * inflationRadius) * SCALE,
                        (obs.height + 2 * inflationRadius) * SCALE
                    );

                    // Draw required clearance zone (200mm)
                    ctx.fillStyle = 'rgba(255, 204, 102, 0.1)';
                    ctx.fillRect(
                        x - MIN_CLEARANCE * SCALE,
                        y - MIN_CLEARANCE * SCALE,
                        (obs.width + 2 * MIN_CLEARANCE) * SCALE,
                        (obs.height + 2 * MIN_CLEARANCE) * SCALE
                    );
                    ctx.strokeStyle = isSelected ? 'rgba(255,204,102,0.6)' : 'rgba(255,204,102,0.35)';
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(
                        x - MIN_CLEARANCE * SCALE,
                        y - MIN_CLEARANCE * SCALE,
                        (obs.width + 2 * MIN_CLEARANCE) * SCALE,
                        (obs.height + 2 * MIN_CLEARANCE) * SCALE
                    );
                    ctx.setLineDash([]);
                }
            });

            // Bottles
            fieldElements.bottles.forEach(bottle => {
                const x = bottle.x * SCALE;
                const y = (FIELD_LENGTH - bottle.y) * SCALE;
                const isSelected = selectedElement === bottle;
                const r = bottle.radius * SCALE;

                // Outer glow
                if (isSelected) {
                    ctx.shadowColor = 'rgba(106, 216, 240, 0.6)';
                    ctx.shadowBlur = 10;
                }

                // Fill with gradient for 3D effect
                const gradient = ctx.createRadialGradient(x - r/3, y - r/3, 0, x, y, r);
                gradient.addColorStop(0, '#8ae8ff');
                gradient.addColorStop(0.7, '#6ad8f0');
                gradient.addColorStop(1, '#4ac8e0');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2 * Math.PI);
                ctx.fill();

                // Border
                ctx.strokeStyle = isSelected ? '#e6e6e6' : '#6ad8f0';
                ctx.lineWidth = isSelected ? 2.5 : 2;
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Label
                ctx.fillStyle = '#0a0e14';
                ctx.font = 'bold 8px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText('B', x, y + 3);
            });

            // Start
            if (fieldElements.start) {
                const x = fieldElements.start.x * SCALE;
                const y = (FIELD_LENGTH - fieldElements.start.y) * SCALE;
                const isSelected = selectedElement === fieldElements.start;
                const edge = fieldElements.start.edge;

                // Draw arrow indicating entry direction
                ctx.save();
                ctx.translate(x, y);
                let rotation = 0;
                if (edge === 'bottom') rotation = -Math.PI / 2;
                else if (edge === 'top') rotation = Math.PI / 2;
                else if (edge === 'left') rotation = 0;
                else if (edge === 'right') rotation = Math.PI;
                ctx.rotate(rotation);

                // Arrow body
                ctx.fillStyle = '#73d47a';
                ctx.beginPath();
                ctx.moveTo(-8, -10);
                ctx.lineTo(8, 0);
                ctx.lineTo(-8, 10);
                ctx.lineTo(-4, 0);
                ctx.closePath();
                ctx.fill();

                // Outer circle
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, 2 * Math.PI);
                ctx.strokeStyle = isSelected ? '#e6e6e6' : '#73d47a';
                ctx.lineWidth = isSelected ? 2.5 : 2;
                ctx.stroke();

                ctx.restore();

                // Glow when selected
                if (isSelected) {
                    ctx.shadowColor = 'rgba(115, 212, 122, 0.5)';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(x, y, 14, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#73d47a';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Label showing zone
                const col = Math.floor(fieldElements.start.x / ZONE_SIZE);
                const row = Math.floor(fieldElements.start.y / ZONE_SIZE);
                ctx.fillStyle = '#73d47a';
                ctx.font = 'bold 9px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`S(${col},${row})`, x, y + 26);
            }

            // Target
            if (fieldElements.target) {
                const x = fieldElements.target.x * SCALE;
                const y = (FIELD_LENGTH - fieldElements.target.y) * SCALE;
                const isSelected = selectedElement === fieldElements.target;

                // Pulsing glow effect (using sin for animation-like effect based on timestamp)
                const pulse = 0.6 + Math.sin(Date.now() / 300) * 0.2;

                // Outer glow
                ctx.shadowColor = `rgba(255, 153, 64, ${pulse})`;
                ctx.shadowBlur = 12;

                // Outer square - larger
                ctx.strokeStyle = '#ff9940';
                ctx.lineWidth = 2.5;
                ctx.strokeRect(x - 14, y - 14, 28, 28);

                // Crosshair - larger
                ctx.beginPath();
                ctx.moveTo(x - 22, y);
                ctx.lineTo(x - 8, y);
                ctx.moveTo(x + 8, y);
                ctx.lineTo(x + 22, y);
                ctx.moveTo(x, y - 22);
                ctx.lineTo(x, y - 8);
                ctx.moveTo(x, y + 8);
                ctx.lineTo(x, y + 22);
                ctx.stroke();

                // Center dot
                ctx.fillStyle = '#ff9940';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();

                ctx.shadowBlur = 0;

                // Selection indicator
                if (isSelected) {
                    ctx.strokeStyle = '#e6e6e6';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(x - 18, y - 18, 36, 36);
                    ctx.setLineDash([]);
                }

                // Label
                ctx.fillStyle = '#ff9940';
                ctx.font = 'bold 9px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText('TARGET', x, y + 30);
            }

            // Measurement line
            if (measureStart && measureEnd) {
                const x1 = measureStart.x * SCALE;
                const y1 = (FIELD_LENGTH - measureStart.y) * SCALE;
                const x2 = measureEnd.x * SCALE;
                const y2 = (FIELD_LENGTH - measureEnd.y) * SCALE;

                ctx.strokeStyle = '#ffcc66';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#ffcc66';
                ctx.beginPath();
                ctx.arc(x1, y1, 3, 0, 2 * Math.PI);
                ctx.arc(x2, y2, 3, 0, 2 * Math.PI);
                ctx.fill();

                const dist = distance(measureStart, measureEnd);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                ctx.fillStyle = 'rgba(10, 14, 20, 0.95)';
                ctx.fillRect(midX - 30, midY - 10, 60, 20);
                ctx.strokeStyle = '#ffcc66';
                ctx.lineWidth = 1;
                ctx.strokeRect(midX - 30, midY - 10, 60, 20);
                ctx.fillStyle = '#ffcc66';
                ctx.font = '11px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(dist)}`, midX, midY + 4);
            }

            // Draw active measurements
            activeMeasurements.forEach(m => {
                const c1 = getElementCenter(m.element1);
                const c2 = getElementCenter(m.element2);
                if (!c1 || !c2) return;

                const x1 = c1.x * SCALE;
                const y1 = (FIELD_LENGTH - c1.y) * SCALE;
                const x2 = c2.x * SCALE;
                const y2 = (FIELD_LENGTH - c2.y) * SCALE;

                const lineColor = m.isValid ? '#7fd962' : '#ff6b6b';

                // Draw measurement line
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw endpoints
                ctx.fillStyle = lineColor;
                ctx.beginPath();
                ctx.arc(x1, y1, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x2, y2, 5, 0, 2 * Math.PI);
                ctx.fill();

                // Draw label at midpoint
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                ctx.fillStyle = 'rgba(10, 14, 20, 0.95)';
                ctx.fillRect(midX - 40, midY - 18, 80, 36);
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1;
                ctx.strokeRect(midX - 40, midY - 18, 80, 36);

                ctx.fillStyle = '#e6e6e6';
                ctx.font = '10px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`${Math.round(m.distance)}mm`, midX, midY - 4);
                ctx.fillStyle = lineColor;
                ctx.fillText(`clr: ${Math.round(m.clearance)}mm`, midX, midY + 10);
            });

            // Draw measurement preview line when first element selected
            if (currentTool === 'measure' && measurementFirstElement) {
                const c1 = getElementCenter(measurementFirstElement);
                if (c1) {
                    const x1 = c1.x * SCALE;
                    const y1 = (FIELD_LENGTH - c1.y) * SCALE;

                    // Highlight first selected element
                    ctx.strokeStyle = '#5ccfe6';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(x1, y1, 20, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw visual route path with A* waypoints
            if (document.getElementById('showRoute').checked && generatedRoute.length > 1) {
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw each route segment using waypoints from pathfinding
                for (let i = 1; i < generatedRoute.length; i++) {
                    const segment = generatedRoute[i];
                    const waypoints = segment.waypoints || [];
                    // Use RED for collision paths, cyan for bottle pushes, otherwise gate color or default
                    const lineColor = segment.hasObstacleCollision ? '#ff3333' :
                        (segment.type === 'bottle_push' ? '#6ad8f0' : (segment.color || '#ffcc66'));

                    if (waypoints.length > 1) {
                        // Draw shadow path
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(waypoints[0].x * SCALE + 2, (FIELD_LENGTH - waypoints[0].y) * SCALE + 2);
                        for (let j = 1; j < waypoints.length; j++) {
                            ctx.lineTo(waypoints[j].x * SCALE + 2, (FIELD_LENGTH - waypoints[j].y) * SCALE + 2);
                        }
                        ctx.stroke();

                        // Draw main path
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(waypoints[0].x * SCALE, (FIELD_LENGTH - waypoints[0].y) * SCALE);
                        for (let j = 1; j < waypoints.length; j++) {
                            ctx.lineTo(waypoints[j].x * SCALE, (FIELD_LENGTH - waypoints[j].y) * SCALE);
                        }
                        ctx.stroke();

                        // Draw waypoint dots for paths with multiple waypoints
                        if (waypoints.length > 2) {
                            ctx.fillStyle = lineColor;
                            for (let j = 1; j < waypoints.length - 1; j++) {
                                const wx = waypoints[j].x * SCALE;
                                const wy = (FIELD_LENGTH - waypoints[j].y) * SCALE;
                                ctx.beginPath();
                                ctx.arc(wx, wy, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }

                        // Draw arrow at final segment
                        if (waypoints.length >= 2) {
                            const lastIdx = waypoints.length - 1;
                            const x1 = waypoints[lastIdx - 1].x * SCALE;
                            const y1 = (FIELD_LENGTH - waypoints[lastIdx - 1].y) * SCALE;
                            const x2 = waypoints[lastIdx].x * SCALE;
                            const y2 = (FIELD_LENGTH - waypoints[lastIdx].y) * SCALE;
                            const midX = (x1 + x2) / 2;
                            const midY = (y1 + y2) / 2;
                            const angle = Math.atan2(y2 - y1, x2 - x1);

                            ctx.save();
                            ctx.translate(midX, midY);
                            ctx.rotate(angle);
                            ctx.fillStyle = lineColor;
                            ctx.beginPath();
                            ctx.moveTo(8, 0);
                            ctx.lineTo(-4, -5);
                            ctx.lineTo(-4, 5);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                    } else {
                        // Fallback: generate path on-the-fly (should not happen after post-processing)
                        const from = generatedRoute[i - 1];
                        console.warn('Drawing fallback - generating path on-the-fly for segment', segment.label || segment.type);

                        // Try to generate a safe path
                        const safePath = pathPlanner.findPath(
                            { x: from.x, y: from.y },
                            { x: segment.x, y: segment.y }
                        );

                        if (safePath && safePath.length > 1) {
                            // Draw the safe path
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                            ctx.lineWidth = 5;
                            ctx.beginPath();
                            ctx.moveTo(safePath[0].x * SCALE + 2, (FIELD_LENGTH - safePath[0].y) * SCALE + 2);
                            for (let j = 1; j < safePath.length; j++) {
                                ctx.lineTo(safePath[j].x * SCALE + 2, (FIELD_LENGTH - safePath[j].y) * SCALE + 2);
                            }
                            ctx.stroke();

                            ctx.strokeStyle = lineColor;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(safePath[0].x * SCALE, (FIELD_LENGTH - safePath[0].y) * SCALE);
                            for (let j = 1; j < safePath.length; j++) {
                                ctx.lineTo(safePath[j].x * SCALE, (FIELD_LENGTH - safePath[j].y) * SCALE);
                            }
                            ctx.stroke();

                            // Update segment waypoints for future use
                            segment.waypoints = safePath;
                        } else {
                            // Last resort: draw direct line (should NEVER happen)
                            console.error('CRITICAL: No safe path found, drawing dangerous direct line');
                            const x1 = from.x * SCALE;
                            const y1 = (FIELD_LENGTH - from.y) * SCALE;
                            const x2 = segment.x * SCALE;
                            const y2 = (FIELD_LENGTH - segment.y) * SCALE;

                            ctx.strokeStyle = '#ff0000'; // RED to indicate danger
                            ctx.lineWidth = 3;
                            ctx.setLineDash([10, 5]); // Dashed to indicate problem
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }

                    // Draw step number at destination
                    if (segment.step) {
                        const x2 = segment.x * SCALE;
                        const y2 = (FIELD_LENGTH - segment.y) * SCALE;

                        ctx.fillStyle = 'rgba(10, 14, 20, 0.85)';
                        ctx.beginPath();
                        ctx.arc(x2, y2 - 20, 12, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = 1.5;
                        ctx.stroke();

                        ctx.fillStyle = lineColor;
                        ctx.font = 'bold 10px JetBrains Mono';
                        ctx.textAlign = 'center';
                        ctx.fillText(segment.step, x2, y2 - 16);
                    }
                }

                // Draw distance labels for each segment
                for (let i = 1; i < generatedRoute.length; i++) {
                    const segment = generatedRoute[i];
                    const waypoints = segment.waypoints || [];
                    const x2 = segment.x * SCALE;
                    const y2 = (FIELD_LENGTH - segment.y) * SCALE;

                    // Put label near the destination
                    const labelX = x2 + 15;
                    const labelY = y2 + 15;

                    ctx.fillStyle = 'rgba(10, 14, 20, 0.8)';
                    ctx.fillRect(labelX - 22, labelY - 8, 44, 16);
                    ctx.fillStyle = '#ffcc66';
                    ctx.font = '9px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.round(segment.dist)}mm`, labelX, labelY + 3);
                }
            }

            // Draw simulation overlay (robot, trail, etc.)
            drawSimulation(ctx);
        }

        // ==================== ROUTE GENERATION ====================
        function generateRoute() {
            const output = document.getElementById('routeOutput');
            generatedRoute = []; // Clear previous route

            if (!fieldElements.start || !fieldElements.target) {
                output.innerHTML = '<span class="comment">// ERROR: place START and TARGET</span>';
                appState = 'field_ready';
                updateButtonStates();
                redraw();
                return;
            }

            if (fieldElements.gates.length === 0) {
                output.innerHTML = '<span class="comment">// ERROR: place at least one GATE</span>';
                appState = 'field_ready';
                updateButtonStates();
                redraw();
                return;
            }

            // Build pathfinding grid
            pathPlanner = new PathPlanner();
            pathPlanner.buildGrid();

            const targetTime = parseInt(document.getElementById('targetTime').value);
            const useOptimization = document.getElementById('optimizeRoute').checked;
            const includeBottles = document.getElementById('includeBottles').checked;
            const robotSpeed = parseFloat(document.getElementById('simSpeed')?.value) || 150;
            const turnRate = parseFloat(document.getElementById('simTurnRate')?.value) || 90;

            let html = '';
            let totalDistance = 0;

            const riskAppetite = parseFloat(document.getElementById('riskAppetite').value) / 100;
            const riskLabel = riskAppetite < 0.3 ? 'SAFE' : riskAppetite < 0.6 ? 'BALANCED' : riskAppetite < 0.8 ? 'AGGRESSIVE' : 'MAXIMUM';
            const minScoringRequired = riskAppetite < 0.3 ? 0 : riskAppetite < 0.6 ? 1 : riskAppetite < 0.8 ? 2 : fieldElements.gates.length;

            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  ROBOT_TOUR_ROUTE // TARGET_TIME: ${targetTime}s</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `  <span class="comment">optimization:</span> ${useOptimization ? '<span class="value">ENABLED</span>' : 'disabled'}\n`;
            html += `  <span class="comment">bottle_push:</span>  ${includeBottles ? '<span class="value">ENABLED</span>' : 'disabled'}\n\n`;

            // === STRATEGY ENGINE v3 STATUS ===
            if (useOptimization) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="header">  STRATEGY_ENGINE_v3 // RISK-AWARE OPTIMIZATION</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

                // Calculate score weight for display
                const scoreWeight = riskAppetite <= 0.6 ? 1.0 + riskAppetite * 0.5 : 1.3 + 2.5 * Math.pow(riskAppetite - 0.6, 2) * 25;

                html += `  <span class="key">risk_mode:</span>        <span class="${riskAppetite >= 0.8 ? 'error' : riskAppetite >= 0.6 ? 'value' : 'number'}">${riskLabel}</span> <span class="comment">(${(riskAppetite * 100).toFixed(0)}%)</span>\n`;
                html += `  <span class="key">score_weight:</span>     <span class="value">${scoreWeight.toFixed(2)}x</span> <span class="comment">// ${riskAppetite > 0.6 ? 'superlinear boost' : 'linear'}</span>\n`;
                html += `  <span class="key">min_gates:</span>        <span class="${minScoringRequired > 0 ? 'value' : 'number'}">${minScoringRequired}</span>/<span class="number">${fieldElements.gates.length}</span> <span class="comment">// hard requirement</span>\n`;

                if (riskAppetite >= 0.7) {
                    html += `  <span class="error">STRAIGHT_SHOT:</span>    <span class="error">BANNED</span> <span class="comment">// trivial routes rejected</span>\n`;
                }
                if (riskAppetite >= 0.8) {
                    html += `  <span class="error">ZERO_SCORING:</span>     <span class="error">BANNED</span> <span class="comment">// must attempt all gates</span>\n`;
                }
                html += `\n`;
            }

            // Use optimized route generator if enabled
            if (useOptimization) {
                const optimizer = new TimeOptimizedRouteGenerator(pathPlanner, targetTime, robotSpeed, turnRate, riskAppetite);
                const bottles = includeBottles ? fieldElements.bottles : [];
                generatedRoute = optimizer.generateOptimizedRoute(
                    fieldElements.start,
                    fieldElements.gates,
                    fieldElements.target,
                    bottles
                );
            } else {
                // Use original nearest-neighbor algorithm
                generatedRoute = generateNearestNeighborRoute();
            }

            // POST-PROCESSING: Validate and fix ALL waypoints to ensure obstacle clearance
            console.log('=== POST-PROCESSING: Validating all route segments ===');

            // Debug: log route structure
            const gateSegments = generatedRoute.filter(s => s.type === 'gate');
            console.log(`Route has ${generatedRoute.length} segments total, ${gateSegments.length} gate visits`);
            console.log(`Gates in route: ${gateSegments.map(s => s.label).join(' → ') || '(none)'}`);
            if (gateSegments.length === 0 && fieldElements.gates.length > 0) {
                console.error('WARNING: Route has no gates but field has gates! Something went wrong in route generation.');
            }

            // CRITICAL: Rebuild the pathfinding grid to ensure obstacles are marked
            console.log('=== REBUILDING GRID FOR POST-PROCESSING ===');
            console.log(`  Obstacles in fieldElements: ${fieldElements.obstacles.length}`);
            for (let oi = 0; oi < fieldElements.obstacles.length; oi++) {
                const obs = fieldElements.obstacles[oi];
                console.log(`    OBS ${oi}: (${obs.x.toFixed(0)},${obs.y.toFixed(0)}) size ${obs.width}x${obs.height}`);
            }
            pathPlanner.buildGrid();

            // Check if this is a NO_OBSTACLE route - if so, ALL paths need regeneration
            const isNoObstacleRoute = generatedRoute.withObstacles === false;
            if (isNoObstacleRoute) {
                console.warn('Route was calculated WITHOUT obstacles - forcing full path regeneration');
            }

            let prevSegmentEnd = { x: fieldElements.start.x, y: fieldElements.start.y };

            for (const segment of generatedRoute) {
                if (segment.type === 'start') {
                    prevSegmentEnd = { x: segment.x, y: segment.y };
                    continue;
                }

                const segmentEnd = { x: segment.x, y: segment.y };

                // Check if existing waypoints actually avoid obstacles
                let existingPathValid = false;
                if (segment.waypoints && segment.waypoints.length >= 2) {
                    existingPathValid = true;
                    for (let wi = 1; wi < segment.waypoints.length; wi++) {
                        if (!pathPlanner.isSegmentClearOfObstacles(segment.waypoints[wi-1], segment.waypoints[wi], 150)) {
                            existingPathValid = false;
                            console.warn(`  Existing path to ${segment.label || segment.type} has obstacle collision at waypoint ${wi}`);
                            break;
                        }
                    }
                }

                // Force regenerate paths for NO_OBSTACLE routes, if waypoints are missing, OR if path is invalid
                const needsRegeneration = isNoObstacleRoute ||
                    !segment.waypoints ||
                    segment.waypoints.length < 2 ||
                    !existingPathValid;

                if (needsRegeneration) {
                    console.log(`Generating path to ${segment.label || segment.type}...`);

                    // Try multiple inflation radii to find a valid path
                    let newPath = null;
                    const originalInflation = pathPlanner.inflationRadius;

                    for (const inflation of [250, 200, 150, 100]) {
                        pathPlanner.inflationRadius = inflation;
                        pathPlanner.buildGrid();
                        newPath = pathPlanner.findPath(prevSegmentEnd, segmentEnd);
                        if (newPath && newPath.length >= 2) {
                            console.log(`  Found path with inflation=${inflation}mm`);
                            break;
                        }
                    }

                    // Restore original inflation
                    pathPlanner.inflationRadius = originalInflation;
                    pathPlanner.buildGrid();

                    if (newPath && newPath.length >= 2) {
                        segment.waypoints = newPath;
                    } else {
                        console.error(`A* failed for segment to ${segment.label || segment.type}, trying intermediate waypoints...`);

                        // Try to find path via intermediate points around obstacles
                        const midX = (prevSegmentEnd.x + segmentEnd.x) / 2;
                        const midY = (prevSegmentEnd.y + segmentEnd.y) / 2;

                        // Try different intermediate points
                        let foundPath = false;
                        for (const offset of [300, 500, 700, -300, -500, -700]) {
                            const intermediate1 = { x: midX + offset, y: midY };
                            const intermediate2 = { x: midX, y: midY + offset };

                            for (const intermediate of [intermediate1, intermediate2]) {
                                // Check intermediate is in bounds
                                if (intermediate.x < 200 || intermediate.x > FIELD_WIDTH - 200 ||
                                    intermediate.y < 200 || intermediate.y > FIELD_LENGTH - 200) continue;

                                const path1 = pathPlanner.findPath(prevSegmentEnd, intermediate);
                                const path2 = pathPlanner.findPath(intermediate, segmentEnd);

                                if (path1 && path1.length >= 2 && path2 && path2.length >= 2) {
                                    // Combine paths
                                    segment.waypoints = [...path1, ...path2.slice(1)];
                                    console.log(`  Found path via intermediate point (${intermediate.x.toFixed(0)}, ${intermediate.y.toFixed(0)})`);
                                    foundPath = true;
                                    break;
                                }
                            }
                            if (foundPath) break;
                        }

                        if (!foundPath) {
                            console.error(`CRITICAL: Cannot find ANY path to ${segment.label || segment.type}`);
                            // Create a marked invalid path - still need waypoints for drawing
                            segment.waypoints = [prevSegmentEnd, segmentEnd];
                            segment.hasObstacleCollision = true;
                        }
                    }
                }

                // Validate the path and simplify it (now that obstacles are guaranteed to be present)
                if (segment.waypoints && segment.waypoints.length >= 2) {
                    // First simplify to remove unnecessary waypoints
                    segment.waypoints = pathPlanner.simplifyPath(segment.waypoints, 200);
                    // Then validate and fix any remaining issues
                    segment.waypoints = pathPlanner.validateAndFixPath(segment.waypoints);
                }

                prevSegmentEnd = segmentEnd;
            }

            // FINAL VERIFICATION: Check and FIX any segments that still violate clearance
            console.log('=== FINAL VERIFICATION: Checking all segments ===');
            let violationCount = 0;
            prevSegmentEnd = { x: fieldElements.start.x, y: fieldElements.start.y };

            for (const segment of generatedRoute) {
                if (segment.type === 'start') {
                    prevSegmentEnd = { x: segment.x, y: segment.y };
                    continue;
                }

                const segmentEnd = { x: segment.x, y: segment.y };

                if (segment.waypoints && segment.waypoints.length >= 2) {
                    let hasViolation = false;
                    for (let i = 1; i < segment.waypoints.length; i++) {
                        const from = segment.waypoints[i - 1];
                        const to = segment.waypoints[i];
                        if (!pathPlanner.isSegmentClearOfObstacles(from, to, 200)) {
                            console.error(`VIOLATION in segment ${segment.label || segment.type}: waypoint ${i-1} to ${i}`);
                            hasViolation = true;
                            violationCount++;
                        }
                    }

                    // If this segment has violations, force regenerate using A*
                    if (hasViolation) {
                        console.warn(`Forcing A* regeneration for segment to ${segment.label || segment.type}...`);

                        // Try with progressively smaller inflation to find ANY valid path
                        let foundValidPath = false;
                        const originalInflation = pathPlanner.inflationRadius;

                        for (const inflation of [250, 200, 150, 100, 50]) {
                            pathPlanner.inflationRadius = inflation;
                            pathPlanner.buildGrid();

                            const freshPath = pathPlanner.findPath(prevSegmentEnd, segmentEnd);
                            if (freshPath && freshPath.length >= 2) {
                                // Verify the fresh path is actually clear (use minimum 100mm clearance)
                                let freshPathClear = true;
                                for (let i = 1; i < freshPath.length; i++) {
                                    if (!pathPlanner.isSegmentClearOfObstacles(freshPath[i-1], freshPath[i], 100)) {
                                        freshPathClear = false;
                                        break;
                                    }
                                }
                                if (freshPathClear) {
                                    segment.waypoints = freshPath;
                                    segment.hasObstacleCollision = false;
                                    console.log(`  Successfully regenerated clear path with ${freshPath.length} waypoints (inflation=${inflation}mm)`);
                                    foundValidPath = true;
                                    break;
                                }
                            }
                        }

                        // Restore original inflation
                        pathPlanner.inflationRadius = originalInflation;
                        pathPlanner.buildGrid();

                        if (!foundValidPath) {
                            console.error(`  CRITICAL: Could not find obstacle-free path to ${segment.label || segment.type}`);
                            segment.hasObstacleCollision = true;
                        }
                    }
                }

                prevSegmentEnd = segmentEnd;
            }

            if (violationCount > 0) {
                console.error(`=== FINAL VERIFICATION: ${violationCount} violations found, attempted regeneration ===`);
            } else {
                console.log('=== FINAL VERIFICATION PASSED: All segments are obstacle-free ===');
            }
            console.log('=== POST-PROCESSING COMPLETE ===');

            // Check for any remaining collision paths and add warning
            const collisionSegments = generatedRoute.filter(s => s.hasObstacleCollision);
            if (collisionSegments.length > 0) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="error">  ⚠ WARNING: ${collisionSegments.length} PATH(S) THROUGH OBSTACLES</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="comment">  The following segments could not avoid obstacles:</span>\n`;
                for (const seg of collisionSegments) {
                    html += `<span class="error">    • Path to ${seg.label || seg.type}</span>\n`;
                }
                html += `<span class="comment">\n  Try adjusting obstacle positions or gate locations.</span>\n`;
                html += `<span class="comment">  Collision paths are shown in RED on the field.</span>\n\n`;
            }

            // === HANDLE NO VALID ROUTE ===
            if (generatedRoute.noValidRoute) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="error">  ⚠ NO VALID ROUTE GENERATED</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n\n`;

                if (generatedRoute.diagnosticMessages && generatedRoute.diagnosticMessages.length > 0) {
                    for (const msg of generatedRoute.diagnosticMessages) {
                        html += `<span class="error">[${msg.type}]</span>\n`;
                        html += `  <span class="comment">${msg.message}</span>\n`;
                        if (msg.details) {
                            html += `  <span class="comment">${msg.details}</span>\n`;
                        }
                        html += `\n  <span class="value">Recommendation:</span>\n`;
                        html += `  <span class="comment">${msg.recommendation}</span>\n\n`;
                    }
                } else {
                    html += `<span class="comment">The current field configuration does not support a valid route</span>\n`;
                    html += `<span class="comment">at the selected risk appetite level.</span>\n\n`;
                }

                // Show rejected candidates if available
                if (generatedRoute.rejectedCandidates && generatedRoute.rejectedCandidates.length > 0) {
                    html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                    html += `<span class="header">  REJECTED_ROUTES</span>\n`;
                    html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

                    for (const c of generatedRoute.rejectedCandidates.slice(0, 5)) {
                        html += `  <span class="key">${c.strategy}:</span>\n`;
                        for (const reason of c.analysis.rejectionReasons) {
                            html += `    <span class="comment">• ${reason}</span>\n`;
                        }
                        html += `\n`;
                    }
                }

                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="header">  SUGGESTED_ACTIONS</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `  <span class="comment">1. Reduce risk appetite to allow simpler routes</span>\n`;
                html += `  <span class="comment">2. Remove or reposition obstacles blocking key paths</span>\n`;
                html += `  <span class="comment">3. Add more time to the target time budget</span>\n`;
                html += `  <span class="comment">4. Reduce the number of gates on the field</span>\n`;

                output.innerHTML = html;
                appState = 'route_ready';
                updateButtonStates();
                redraw();
                return;
            }

            // Generate output HTML from route
            let step = 1;
            let currentPos = { x: fieldElements.start.x, y: fieldElements.start.y };

            for (const segment of generatedRoute) {
                if (segment.type === 'start') {
                    html += `<span class="key">STEP_${String(step).padStart(2,'0')}:</span> <span class="string">INITIALIZE</span>\n`;
                    html += `  <span class="comment">pos:</span> <span class="number">(${Math.round(segment.x)}, ${Math.round(segment.y)})</span>\n`;
                    html += `  <span class="comment">action:</span> place robot, orient into field, await trigger\n\n`;
                    step++;
                    continue;
                }

                // Calculate segment distance
                let segmentDist = 0;
                if (segment.waypoints && segment.waypoints.length > 1) {
                    for (let i = 1; i < segment.waypoints.length; i++) {
                        segmentDist += distance(segment.waypoints[i - 1], segment.waypoints[i]);
                    }
                } else {
                    segmentDist = segment.dist || distance(currentPos, segment);
                }
                totalDistance += segmentDist;

                const dx = segment.x - currentPos.x;
                const dy = segment.y - currentPos.y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                const direction = getCardinalDirection(angle);

                if (segment.type === 'bottle_push') {
                    html += `<span class="key">STEP_${String(step).padStart(2,'0')}:</span> <span class="string">BOTTLE_PUSH</span>\n`;
                    html += `  <span class="comment">bottle:</span> <span class="value">${segment.label}</span>\n`;
                    html += `  <span class="comment">target_gate:</span> <span class="value">${segment.targetGate}</span>\n`;
                    html += `  <span class="comment">pos:</span> <span class="number">(${Math.round(segment.x)}, ${Math.round(segment.y)})</span>\n`;
                    html += `  <span class="comment">action:</span> push_bottle_into_gate()  <span class="comment">// -15pts bonus</span>\n\n`;
                } else if (segment.type === 'gate') {
                    html += `<span class="key">STEP_${String(step).padStart(2,'0')}:</span> <span class="string">GATE_${segment.label}</span>\n`;
                    html += `  <span class="comment">from:</span> <span class="number">(${Math.round(currentPos.x)}, ${Math.round(currentPos.y)})</span>\n`;
                    html += `  <span class="comment">to:</span>   <span class="number">(${Math.round(segment.x)}, ${Math.round(segment.y)})</span>\n`;
                    html += `  <span class="comment">path:</span> <span class="number">${segment.waypoints ? segment.waypoints.length : 2}</span> waypoints  <span class="comment">dist:</span> <span class="number">${Math.round(segmentDist)}mm</span>\n`;
                    html += `  <span class="comment">heading:</span> <span class="value">${direction}</span> <span class="number">(${Math.round(angle)}°)</span>\n`;
                    html += `  <span class="comment">action:</span> navigate_to_gate(<span class="string">"${segment.label}"</span>)  <span class="comment">// -15pts</span>\n\n`;
                } else if (segment.type === 'target') {
                    html += `<span class="key">STEP_${String(step).padStart(2,'0')}:</span> <span class="string">TARGET</span>\n`;
                    html += `  <span class="comment">from:</span> <span class="number">(${Math.round(currentPos.x)}, ${Math.round(currentPos.y)})</span>\n`;
                    html += `  <span class="comment">to:</span>   <span class="number">(${Math.round(segment.x)}, ${Math.round(segment.y)})</span>\n`;
                    html += `  <span class="comment">path:</span> <span class="number">${segment.waypoints ? segment.waypoints.length : 2}</span> waypoints  <span class="comment">dist:</span> <span class="number">${Math.round(segmentDist)}mm</span>\n`;
                    html += `  <span class="comment">action:</span> navigate_to_target(), stop()\n\n`;
                }

                currentPos = { x: segment.x, y: segment.y };
                step++;
            }

            // Calculate estimated time including turns
            const estSpeed = robotSpeed;

            // Collect all waypoints for time calculation
            const allWaypoints = [];
            for (const segment of generatedRoute) {
                if (segment.waypoints) {
                    allWaypoints.push(...segment.waypoints);
                }
            }

            // Calculate turn time (time spent turning, not driving)
            let totalTurnTime = 0;
            let currentHeading = null;
            for (let i = 1; i < allWaypoints.length; i++) {
                const prev = allWaypoints[i - 1];
                const curr = allWaypoints[i];
                const dx = curr.x - prev.x;
                const dy = curr.y - prev.y;
                if (dx !== 0 || dy !== 0) {
                    const heading = Math.atan2(dy, dx) * 180 / Math.PI;
                    if (currentHeading !== null) {
                        let turnAngle = Math.abs(heading - currentHeading);
                        if (turnAngle > 180) turnAngle = 360 - turnAngle;
                        totalTurnTime += turnAngle / turnRate;
                    }
                    currentHeading = heading;
                }
            }

            // Calculate time at current speed
            let estTime = (totalDistance / estSpeed) + totalTurnTime;

            // Calculate RECOMMENDED speed to meet target time
            // Available driving time = target time - turn time - buffer
            const timeBuffer = 2.0; // 2 second safety buffer
            const availableDriveTime = targetTime - totalTurnTime - timeBuffer;
            let recommendedSpeed = totalDistance / availableDriveTime;

            // Clamp recommended speed to reasonable range (50-200 mm/s)
            recommendedSpeed = Math.max(50, Math.min(200, recommendedSpeed));

            // Recalculate estimated time at recommended speed
            const estTimeAtRecommended = (totalDistance / recommendedSpeed) + totalTurnTime;

            // Count bottle pushes
            const bottlePushes = generatedRoute.filter(s => s.type === 'bottle_push').length;

            // Validate route clearances
            const clearanceValidation = validateRouteClearances(generatedRoute);
            if (!clearanceValidation.valid) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="header">  ⚠ CLEARANCE WARNINGS</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `  <span class="error">Found ${clearanceValidation.violations.length} clearance violation(s)</span>\n`;
                html += `  <span class="comment">Route may pass too close to obstacles.</span>\n`;
                html += `  <span class="comment">Consider regenerating field with fewer obstacles.</span>\n\n`;
            }

            // Get tournament analysis from route if available
            const routeAnalysis = generatedRoute.routeAnalysis || null;
            const obstacleAnalysis = generatedRoute.obstacleAnalysis || null;
            const selectedStrategy = generatedRoute.selectedStrategy || 'UNKNOWN';

            // Count turns
            let turnCount = 0;
            let prevHeading = null;
            for (let i = 1; i < allWaypoints.length; i++) {
                const prev = allWaypoints[i - 1];
                const curr = allWaypoints[i];
                const dx = curr.x - prev.x;
                const dy = curr.y - prev.y;
                if (dx !== 0 || dy !== 0) {
                    const heading = Math.atan2(dy, dx) * 180 / Math.PI;
                    if (prevHeading !== null) {
                        let turn = Math.abs(heading - prevHeading);
                        if (turn > 180) turn = 360 - turn;
                        if (turn > 15) turnCount++; // Count significant turns
                    }
                    prevHeading = heading;
                }
            }

            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  ROUTE_SUMMARY</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

            // Show gates visited vs required
            const gatesVisited = routeAnalysis ? routeAnalysis.gatesVisited : fieldElements.gates.length;
            const gatesRequired = minScoringRequired;
            const gatesOk = gatesVisited >= gatesRequired;
            html += `  <span class="key">gates_visited:</span>  <span class="${gatesOk ? 'value' : 'error'}">${gatesVisited}</span>/<span class="number">${fieldElements.gates.length}</span>`;
            if (gatesRequired > 0) {
                html += ` <span class="comment">(min: ${gatesRequired})</span>`;
            }
            html += `\n`;

            if (bottlePushes > 0) {
                html += `  <span class="key">bottle_pushes:</span> <span class="value">${bottlePushes}</span>\n`;
            }
            html += `  <span class="key">total_score:</span>   <span class="value">${gatesVisited * 10 + bottlePushes * 15}</span> pts\n`;
            html += `  <span class="key">est_time:</span>      <span class="number">${estTime.toFixed(1)}s</span> / <span class="number">${targetTime}s</span> (<span class="value">${((estTime / targetTime) * 100).toFixed(0)}%</span>)\n`;
            html += `  <span class="key">time_margin:</span>   <span class="${(targetTime - estTime) > 5 ? 'value' : 'error'}">${(targetTime - estTime).toFixed(1)}s</span>\n`;
            html += `  <span class="key">turns:</span>         <span class="number">${turnCount}</span>\n`;
            html += `  <span class="key">waypoints:</span>     <span class="number">${allWaypoints.length}</span>\n`;
            html += `  <span class="key">distance:</span>      <span class="number">${Math.round(totalDistance)}mm</span>\n`;

            // Detour ratio
            let directDist = 0;
            let lastPos = { x: fieldElements.start.x, y: fieldElements.start.y };
            for (const segment of generatedRoute) {
                if (segment.type !== 'start') {
                    directDist += distance(lastPos, { x: segment.x, y: segment.y });
                    lastPos = { x: segment.x, y: segment.y };
                }
            }
            const detourRatio = directDist > 0 ? totalDistance / directDist : 1.0;
            html += `  <span class="key">detour_ratio:</span>  <span class="${detourRatio > 1.4 ? 'error' : 'number'}">${detourRatio.toFixed(2)}</span>\n`;

            // Show topology if available
            if (routeAnalysis && routeAnalysis.topology) {
                const topoColor = routeAnalysis.topology === 'SCORING_LOOP' ? 'value' :
                                  routeAnalysis.topology === 'STRAIGHT_SHOT' ? 'error' : 'number';
                html += `  <span class="key">topology:</span>      <span class="${topoColor}">${routeAnalysis.topology}</span>\n`;
            }

            // Show selected strategy
            if (generatedRoute.selectedStrategy) {
                html += `  <span class="key">strategy:</span>      <span class="value">${generatedRoute.selectedStrategy}</span>\n`;
            }

            html += `\n`;

            // Obstacle Analysis Section
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  OBSTACLE_ANALYSIS</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

            if (obstacleAnalysis) {
                html += `  <span class="key">obstacles:</span>      <span class="number">${obstacleAnalysis.obstacleCount}</span>\n`;
                html += `  <span class="key">avg_detour:</span>     <span class="${obstacleAnalysis.avgDetourRatio >= 1.4 ? 'error' : 'number'}">${((obstacleAnalysis.avgDetourRatio - 1) * 100).toFixed(0)}%</span>\n`;
                html += `  <span class="key">max_detour:</span>     <span class="${obstacleAnalysis.maxDetourRatio >= 2.0 ? 'error' : 'number'}">${((obstacleAnalysis.maxDetourRatio - 1) * 100).toFixed(0)}%</span>\n`;
                html += `  <span class="key">blocked_paths:</span>  <span class="number">${obstacleAnalysis.blockedPaths}</span> / <span class="number">${obstacleAnalysis.totalPaths}</span>\n`;

                if (obstacleAnalysis.warnings.length > 0) {
                    html += `\n  <span class="error">WARNINGS:</span>\n`;
                    for (const warning of obstacleAnalysis.warnings) {
                        html += `    <span class="comment">• ${warning}</span>\n`;
                    }
                }
            } else {
                html += `  <span class="comment">No obstacle analysis available</span>\n`;
            }
            html += `\n`;

            // Strategy Recommendation
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  STRATEGY_RECOMMENDATION</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

            if (obstacleAnalysis && obstacleAnalysis.recommendation === 'REMOVE_OBSTACLES') {
                html += `  <span class="error">RECOMMENDED: REMOVE OBSTACLES</span>\n`;
                html += `  <span class="comment">Reason: ${obstacleAnalysis.recommendationReasons.join(', ')}</span>\n`;
                html += `\n`;
                html += `  <span class="comment">Obstacle removal penalty: ~10-20 pts</span>\n`;
                html += `  <span class="comment">Expected benefit: simpler route, better consistency</span>\n`;
                html += `  <span class="comment">Net gain: likely positive for this layout</span>\n`;
            } else if (obstacleAnalysis && obstacleAnalysis.recommendation === 'NO_OBSTACLES') {
                html += `  <span class="value">STATUS: NO OBSTACLES</span>\n`;
                html += `  <span class="comment">No obstacle decision needed</span>\n`;
            } else {
                html += `  <span class="value">RECOMMENDED: KEEP OBSTACLES</span>\n`;
                html += `  <span class="comment">Route is viable with current obstacle layout</span>\n`;
                html += `  <span class="comment">Detour impact is acceptable</span>\n`;
            }
            html += `\n`;

            // Strategy Engine v3 - Probability Analysis
            const strategyPortfolio = generatedRoute.strategyPortfolio || null;
            // riskAppetite already defined at top of function

            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  PROBABILITY_ANALYSIS</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

            if (routeAnalysis && routeAnalysis.singleRunProb !== undefined) {
                const riskLabel = riskAppetite <= 0.3 ? 'SAFE' : riskAppetite <= 0.6 ? 'BALANCED' : riskAppetite <= 0.8 ? 'AGGRESSIVE' : 'MAXIMUM';
                const minRequired = riskAppetite < 0.3 ? 0 : riskAppetite < 0.6 ? 1 : riskAppetite < 0.8 ? 2 : fieldElements.gates.length;
                html += `  <span class="key">risk_appetite:</span>    <span class="value">${riskAppetite.toFixed(2)}</span> (${riskLabel})\n`;
                html += `  <span class="key">min_scoring:</span>      <span class="number">${minRequired}</span>/<span class="number">${fieldElements.gates.length}</span> gates required\n`;
                html += `  <span class="key">classification:</span>   <span class="${routeAnalysis.classification === 'FRAGILE' ? 'error' : 'value'}">${routeAnalysis.classification}</span>\n`;
                if (routeAnalysis.topology) {
                    const topologyColor = routeAnalysis.topology === 'STRAIGHT_SHOT' ? 'error' :
                                          routeAnalysis.topology === 'SCORING_LOOP' ? 'value' : 'number';
                    html += `  <span class="key">topology:</span>         <span class="${topologyColor}">${routeAnalysis.topology}</span>\n`;
                }
                html += `  <span class="key">P(single_run):</span>    <span class="${routeAnalysis.singleRunProb >= 0.8 ? 'value' : routeAnalysis.singleRunProb >= 0.6 ? 'number' : 'error'}">${(routeAnalysis.singleRunProb * 100).toFixed(1)}%</span>\n`;
                html += `  <span class="key">P(2wins_in_3):</span>    <span class="${routeAnalysis.twoSuccessProb >= 0.7 ? 'value' : routeAnalysis.twoSuccessProb >= 0.5 ? 'number' : 'error'}">${(routeAnalysis.twoSuccessProb * 100).toFixed(1)}%</span>\n`;
                html += `  <span class="key">expected_score:</span>   <span class="value">${routeAnalysis.expectedScore.toFixed(1)}</span> pts\n`;
                html += `  <span class="key">gates_visited:</span>    <span class="${routeAnalysis.gatesVisited >= minRequired ? 'value' : 'error'}">${routeAnalysis.gatesVisited}</span>/<span class="number">${fieldElements.gates.length}</span>\n`;
                html += `  <span class="key">simplicity:</span>       <span class="number">${routeAnalysis.simplicity.toFixed(3)}</span>\n`;
                html += `  <span class="key">utility:</span>          <span class="number">${routeAnalysis.utility.toFixed(1)}</span>\n`;
            } else {
                html += `  <span class="comment">Enable optimization for probability analysis</span>\n`;
            }
            html += `\n`;

            // === DIAGNOSTIC WARNINGS ===
            if (generatedRoute.diagnosticMessages && generatedRoute.diagnosticMessages.length > 0) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="error">  ⚠ ROUTE_WARNINGS</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                for (const msg of generatedRoute.diagnosticMessages) {
                    html += `  <span class="error">[${msg.type}]</span> <span class="comment">${msg.message}</span>\n`;
                    if (msg.recommendation) {
                        html += `  <span class="key">→</span> <span class="comment">${msg.recommendation}</span>\n`;
                    }
                }
                html += `\n`;
            }

            // === ROUTE REJECTION INFO (if any candidates were rejected) ===
            if (routeAnalysis && routeAnalysis.rejectionReasons && routeAnalysis.rejectionReasons.length > 0) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="error">  ⚠ ROUTE_CONSTRAINTS_VIOLATED</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                for (const reason of routeAnalysis.rejectionReasons) {
                    html += `  <span class="error">•</span> <span class="comment">${reason}</span>\n`;
                }
                html += `\n`;
            }

            // Strategy Portfolio
            if (strategyPortfolio) {
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
                html += `<span class="header">  STRATEGY_PORTFOLIO</span>\n`;
                html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;

                const formatPortfolioRoute = (label, candidate, selectedStrategy) => {
                    if (!candidate) return '';
                    const a = candidate.analysis;
                    const selected = candidate.strategy === selectedStrategy ? ' <span class="value">◄ SELECTED</span>' : '';
                    const topo = a.topology ? `[${a.topology}]` : '';
                    return `  <span class="key">${label}:</span> <span class="number">${a.totalScore}</span>pts, ` +
                           `<span class="number">${a.gatesVisited}</span>gates, ` +
                           `P:<span class="value">${(a.twoSuccessProb * 100).toFixed(0)}%</span> ` +
                           `→ E[<span class="value">${(a.twoSuccessProb * a.totalScore).toFixed(0)}</span>] ` +
                           `<span class="comment">${topo}</span>${selected}\n`;
                };

                if (strategyPortfolio.ultraSafe) {
                    html += formatPortfolioRoute('Route_A (Safe)', strategyPortfolio.ultraSafe, generatedRoute.selectedStrategy);
                }
                if (strategyPortfolio.balanced) {
                    html += formatPortfolioRoute('Route_B (Balanced)', strategyPortfolio.balanced, generatedRoute.selectedStrategy);
                }
                if (strategyPortfolio.aggressive) {
                    html += formatPortfolioRoute('Route_C (Aggress.)', strategyPortfolio.aggressive, generatedRoute.selectedStrategy);
                }

                // Show which strategy was selected and why
                if (generatedRoute.selectedStrategy) {
                    html += `\n  <span class="comment">Selected strategy: </span><span class="value">${generatedRoute.selectedStrategy}</span>\n`;
                    if (generatedRoute.withObstacles === false) {
                        html += `  <span class="comment">Mode: </span><span class="error">OBSTACLES REMOVED (-15pts)</span>\n`;
                    }
                }

                // Obstacle comparison if available
                if (strategyPortfolio.comparison.withoutObstacles.length > 0) {
                    html += `\n  <span class="comment">--- OBSTACLE REMOVAL COMPARISON ---</span>\n`;
                    const withObs = strategyPortfolio.comparison.withObstacles[0]?.analysis;
                    const noObs = strategyPortfolio.comparison.withoutObstacles[0]?.analysis;
                    if (withObs && noObs) {
                        const timeSaved = withObs.estimatedTime - noObs.estimatedTime;
                        const turnsSaved = withObs.turnCount - noObs.turnCount;
                        const probGain = noObs.twoSuccessProb - withObs.twoSuccessProb;
                        html += `  <span class="key">time_saved:</span>       <span class="${timeSaved > 3 ? 'value' : 'number'}">${timeSaved.toFixed(1)}s</span>\n`;
                        html += `  <span class="key">turns_reduced:</span>    <span class="number">${turnsSaved}</span>\n`;
                        html += `  <span class="key">P(2wins)_change:</span>  <span class="${probGain >= 0.1 ? 'value' : 'number'}">${probGain >= 0 ? '+' : ''}${(probGain * 100).toFixed(1)}%</span>\n`;
                        html += `  <span class="key">with_obs_score:</span>   <span class="number">${withObs.totalScore}</span> pts (E[${(withObs.twoSuccessProb * withObs.totalScore).toFixed(0)}])\n`;
                        html += `  <span class="key">no_obs_score:</span>     <span class="number">${noObs.totalScore}</span> pts (E[${(noObs.twoSuccessProb * noObs.totalScore).toFixed(0)}])\n`;
                    }
                }
                html += `\n`;
            }

            // Speed/Time section
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  SPEED_RECOMMENDATION</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `  <span class="key">recommended_speed:</span> <span class="value">${Math.round(recommendedSpeed)}mm/s</span>\n`;
            html += `  <span class="key">est_time_at_rec:</span>  <span class="number">${estTimeAtRecommended.toFixed(1)}s</span>\n`;
            html += `  <span class="key">time_margin:</span>      <span class="value">${(targetTime - estTimeAtRecommended).toFixed(1)}s</span> under target\n`;
            html += `  <span class="comment">// Slow down to ${Math.round(recommendedSpeed)}mm/s to stay under ${targetTime}s</span>\n`;
            html += `\n`;

            // Scoring estimate
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `<span class="header">  SCORING_ESTIMATE</span>\n`;
            html += `<span class="header">═══════════════════════════════════════════════════════════════</span>\n`;
            html += `  <span class="key">base:</span>       <span class="number">200</span> pts\n`;
            html += `  <span class="key">gates:</span>      <span class="number">${fieldElements.gates.length}</span> × <span class="number">-15</span> = <span class="value">-${fieldElements.gates.length * 15}</span> pts\n`;
            if (bottlePushes > 0) {
                html += `  <span class="key">bottles:</span>    <span class="number">${bottlePushes}</span> × <span class="number">-15</span> = <span class="value">-${bottlePushes * 15}</span> pts\n`;
            } else {
                html += `  <span class="key">bottles:</span>    up to <span class="value">-${Math.min(fieldElements.bottles.length, fieldElements.gates.length) * 15}</span> pts\n`;
            }
            html += `  <span class="key">time:</span>       <span class="value">under @ ${Math.round(recommendedSpeed)}mm/s</span>\n`;
            html += `  <span class="key">distance:</span>   <span class="number">${(totalDistance / 10).toFixed(1)}cm × 2.0</span> = <span class="value">${(totalDistance / 5).toFixed(0)}</span> pts\n`;

            output.innerHTML = html;
            appState = 'route_ready';
            updateButtonStates();
            redraw(); // Redraw to show route
        }

        // Helper function for basic nearest-neighbor routing (fallback when optimization disabled)
        function generateNearestNeighborRoute() {
            const route = [];
            let currentPos = { x: fieldElements.start.x, y: fieldElements.start.y };
            const unvisitedGates = [...fieldElements.gates];

            // Start position
            route.push({ type: 'start', x: currentPos.x, y: currentPos.y, label: 'S', waypoints: [] });

            // Visit all gates using greedy nearest-neighbor
            while (unvisitedGates.length > 0) {
                let nearestIdx = 0;
                let nearestDist = Infinity;
                for (let i = 0; i < unvisitedGates.length; i++) {
                    const gate = unvisitedGates[i];
                    const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };
                    const dist = distance(currentPos, gateCenter);
                    if (dist < nearestDist) { nearestDist = dist; nearestIdx = i; }
                }

                const gate = unvisitedGates.splice(nearestIdx, 1)[0];
                const gateCenter = { x: gate.x + ZONE_SIZE / 2, y: gate.y + ZONE_SIZE / 2 };

                // MUST use pathfinding - never direct line
                let path = pathPlanner.findPath(currentPos, gateCenter);
                if (!path || path.length < 2) {
                    console.error(`No path to gate ${gate.label}, rebuilding grid...`);
                    pathPlanner.buildGrid();
                    path = pathPlanner.findPath(currentPos, gateCenter);
                }

                if (!path || path.length < 2) {
                    console.error(`CRITICAL: Cannot path to gate ${gate.label}`);
                    continue;
                }

                let pathDistance = 0;
                for (let i = 1; i < path.length; i++) {
                    pathDistance += distance(path[i - 1], path[i]);
                }

                route.push({
                    type: 'gate',
                    x: gateCenter.x,
                    y: gateCenter.y,
                    label: gate.label,
                    color: GATE_COLORS[gate.colorIndex],
                    dist: pathDistance,
                    waypoints: path
                });

                currentPos = gateCenter;
            }

            // Path to target - MUST use pathfinding
            const targetPos = { x: fieldElements.target.x, y: fieldElements.target.y };
            let targetPath = pathPlanner.findPath(currentPos, targetPos);
            if (!targetPath || targetPath.length < 2) {
                pathPlanner.buildGrid();
                targetPath = pathPlanner.findPath(currentPos, targetPos);
            }

            let targetDist = 0;
            if (targetPath && targetPath.length > 1) {
                for (let i = 1; i < targetPath.length; i++) {
                    targetDist += distance(targetPath[i - 1], targetPath[i]);
                }
            }

            route.push({
                type: 'target',
                x: fieldElements.target.x,
                y: fieldElements.target.y,
                label: 'T',
                dist: targetDist,
                waypoints: targetPath || [currentPos]
            });

            return route;
        }

        function getCardinalDirection(angle) {
            if (angle >= -22.5 && angle < 22.5) return 'E';
            if (angle >= 22.5 && angle < 67.5) return 'NE';
            if (angle >= 67.5 && angle < 112.5) return 'N';
            if (angle >= 112.5 && angle < 157.5) return 'NW';
            if (angle >= 157.5 || angle < -157.5) return 'W';
            if (angle >= -157.5 && angle < -112.5) return 'SW';
            if (angle >= -112.5 && angle < -67.5) return 'S';
            if (angle >= -67.5 && angle < -22.5) return 'SE';
            return '?';
        }

        // ==================== EXPORT ====================
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                document.getElementById('exportMenu').classList.remove('show');
            }
        });

        function downloadImage() {
            document.getElementById('exportMenu').classList.remove('show');
            const link = document.createElement('a');
            link.download = 'rt_fieldgen_field.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportJSON() {
            document.getElementById('exportMenu').classList.remove('show');
            const data = {
                meta: { generator: 'RT-FIELDGEN', version: '1.0', timestamp: new Date().toISOString() },
                field: { width_mm: FIELD_WIDTH, length_mm: FIELD_LENGTH, zone_size_mm: ZONE_SIZE },
                config: { level: document.getElementById('level').value, target_time_s: parseInt(document.getElementById('targetTime').value) },
                start: fieldElements.start ? { x: Math.round(fieldElements.start.x), y: Math.round(fieldElements.start.y), edge: fieldElements.start.edge } : null,
                target: fieldElements.target ? { x: Math.round(fieldElements.target.x), y: Math.round(fieldElements.target.y) } : null,
                gates: fieldElements.gates.map(g => ({ label: g.label, col: g.col, row: g.row, x: g.x, y: g.y })),
                obstacles: fieldElements.obstacles.map(o => ({ x: Math.round(o.x), y: Math.round(o.y), w: o.width, h: o.height, orientation: o.orientation })),
                bottles: fieldElements.bottles.map(b => ({ x: Math.round(b.x), y: Math.round(b.y) }))
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'rt_fieldgen_field.json';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportCSV() {
            document.getElementById('exportMenu').classList.remove('show');
            let csv = 'type,label,x,y,col,row,width,height,orientation,edge\n';

            if (fieldElements.start) {
                csv += `start,START,${Math.round(fieldElements.start.x)},${Math.round(fieldElements.start.y)},,,,,${fieldElements.start.edge}\n`;
            }
            if (fieldElements.target) {
                csv += `target,TARGET,${Math.round(fieldElements.target.x)},${Math.round(fieldElements.target.y)},,,,,,\n`;
            }
            fieldElements.gates.forEach(g => {
                csv += `gate,${g.label},${g.x},${g.y},${g.col},${g.row},,,,\n`;
            });
            fieldElements.obstacles.forEach((o, i) => {
                csv += `obstacle,OBS_${String(i+1).padStart(2,'0')},${Math.round(o.x)},${Math.round(o.y)},,${o.width},${o.height},${o.orientation},\n`;
            });
            fieldElements.bottles.forEach((b, i) => {
                csv += `bottle,BTL_${String(i+1).padStart(2,'0')},${Math.round(b.x)},${Math.round(b.y)},,,,,,\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = 'rt_fieldgen_field.csv';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportPython() {
            document.getElementById('exportMenu').classList.remove('show');
            let py = `# RT-FIELDGEN Export - ${new Date().toISOString()}\n\n`;
            py += `FIELD_CONFIG = {\n`;
            py += `    'field_width': ${FIELD_WIDTH},\n`;
            py += `    'field_length': ${FIELD_LENGTH},\n`;
            py += `    'zone_size': ${ZONE_SIZE},\n`;
            py += `    'level': '${document.getElementById('level').value}',\n`;
            py += `    'target_time': ${document.getElementById('targetTime').value},\n`;
            py += `}\n\n`;

            if (fieldElements.start) {
                py += `START = {'x': ${Math.round(fieldElements.start.x)}, 'y': ${Math.round(fieldElements.start.y)}, 'edge': '${fieldElements.start.edge}'}\n\n`;
            }
            if (fieldElements.target) {
                py += `TARGET = {'x': ${Math.round(fieldElements.target.x)}, 'y': ${Math.round(fieldElements.target.y)}}\n\n`;
            }

            py += `GATES = [\n`;
            fieldElements.gates.forEach(g => {
                py += `    {'label': '${g.label}', 'x': ${g.x}, 'y': ${g.y}, 'col': ${g.col}, 'row': ${g.row}},\n`;
            });
            py += `]\n\n`;

            py += `OBSTACLES = [\n`;
            fieldElements.obstacles.forEach(o => {
                py += `    {'x': ${Math.round(o.x)}, 'y': ${Math.round(o.y)}, 'w': ${o.width}, 'h': ${o.height}, 'orientation': '${o.orientation}'},\n`;
            });
            py += `]\n\n`;

            py += `BOTTLES = [\n`;
            fieldElements.bottles.forEach(b => {
                py += `    {'x': ${Math.round(b.x)}, 'y': ${Math.round(b.y)}},\n`;
            });
            py += `]\n`;

            const blob = new Blob([py], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'rt_fieldgen_field.py';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportRouteJSON() {
            document.getElementById('exportMenu').classList.remove('show');
            if (generatedRoute.length === 0) {
                alert('No route generated. Click CALC ROUTE first.');
                return;
            }

            const data = {
                meta: { generator: 'RT-FIELDGEN', version: '1.0', timestamp: new Date().toISOString(), type: 'route' },
                config: { level: document.getElementById('level').value, target_time_s: parseInt(document.getElementById('targetTime').value) },
                route: generatedRoute.map(wp => ({
                    type: wp.type,
                    label: wp.label,
                    x: Math.round(wp.x),
                    y: Math.round(wp.y),
                    distance: wp.dist ? Math.round(wp.dist) : 0,
                    step: wp.step || 0,
                    waypoints: wp.waypoints ? wp.waypoints.map(w => ({ x: Math.round(w.x), y: Math.round(w.y) })) : []
                })),
                summary: {
                    total_distance: generatedRoute.reduce((sum, wp) => sum + (wp.dist || 0), 0),
                    total_waypoints: generatedRoute.length,
                    gates_count: fieldElements.gates.length
                }
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'rt_fieldgen_route.json';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportComplete() {
            document.getElementById('exportMenu').classList.remove('show');
            const data = {
                meta: { generator: 'RT-FIELDGEN', version: '1.0', timestamp: new Date().toISOString(), type: 'complete' },
                field: { width_mm: FIELD_WIDTH, length_mm: FIELD_LENGTH, zone_size_mm: ZONE_SIZE },
                config: { level: document.getElementById('level').value, target_time_s: parseInt(document.getElementById('targetTime').value) },
                elements: {
                    start: fieldElements.start ? { x: Math.round(fieldElements.start.x), y: Math.round(fieldElements.start.y), edge: fieldElements.start.edge, direction: fieldElements.start.direction } : null,
                    target: fieldElements.target ? { x: Math.round(fieldElements.target.x), y: Math.round(fieldElements.target.y) } : null,
                    gates: fieldElements.gates.map(g => ({ label: g.label, col: g.col, row: g.row, x: g.x, y: g.y })),
                    obstacles: fieldElements.obstacles.map(o => ({ x: Math.round(o.x), y: Math.round(o.y), w: o.width, h: o.height, orientation: o.orientation })),
                    bottles: fieldElements.bottles.map(b => ({ x: Math.round(b.x), y: Math.round(b.y) }))
                },
                route: generatedRoute.length > 0 ? generatedRoute.map(wp => ({
                    type: wp.type,
                    label: wp.label,
                    x: Math.round(wp.x),
                    y: Math.round(wp.y),
                    distance: wp.dist ? Math.round(wp.dist) : 0,
                    waypoints: wp.waypoints ? wp.waypoints.map(w => ({ x: Math.round(w.x), y: Math.round(w.y) })) : []
                })) : null
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'rt_fieldgen_complete.json';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        // ==================== RISK DISPLAY UPDATE ====================
        function updateRiskDisplay(value) {
            const risk = value / 100;
            document.getElementById('riskValue').textContent = risk.toFixed(2);

            // Determine label
            let label, color;
            if (risk < 0.3) { label = 'SAFE'; color = 'var(--accent)'; }
            else if (risk < 0.6) { label = 'BALANCED'; color = 'var(--text-secondary)'; }
            else if (risk < 0.8) { label = 'AGGRESSIVE'; color = '#f0a500'; }
            else { label = 'MAXIMUM'; color = '#ff4444'; }

            document.getElementById('riskLabel').textContent = `(${label})`;
            document.getElementById('riskLabel').style.color = color;

            // Calculate min gates required
            const totalGates = fieldElements.gates.length || 4;
            let minGates;
            if (risk < 0.3) minGates = 0;
            else if (risk < 0.6) minGates = 1;
            else if (risk < 0.8) minGates = Math.min(2, totalGates);
            else minGates = totalGates;

            // Calculate score weight
            let scoreWeight;
            if (risk <= 0.6) {
                scoreWeight = 1.0 + risk * 0.5;
            } else {
                const excess = risk - 0.6;
                scoreWeight = 1.3 + 2.5 * excess * excess * 25;
            }

            // Build info string
            let info = `Min gates: ${minGates}/${totalGates} | Score weight: ${scoreWeight.toFixed(2)}x`;
            if (risk >= 0.7) info += ' | TRIVIAL BANNED';
            if (risk >= 0.8) info += ' | MUST SCORE ALL';

            document.getElementById('riskInfo').textContent = info;
            document.getElementById('riskInfo').style.color = risk >= 0.8 ? '#ff4444' : 'var(--text-tertiary)';
        }

        // ==================== BUTTON STATE MANAGEMENT ====================
        function updateButtonStates() {
            const hasField = fieldElements.start || fieldElements.target ||
                            fieldElements.gates.length > 0 || fieldElements.obstacles.length > 0;
            const hasRoute = generatedRoute.length > 0;
            const canCalcRoute = fieldElements.start && fieldElements.target && fieldElements.gates.length > 0;

            // Update button states
            const calcBtn = document.getElementById('calcRouteBtn');
            const exportBtn = document.getElementById('exportBtn');

            // Calc Route button
            calcBtn.disabled = !canCalcRoute;
            calcBtn.textContent = hasRoute ? 'RECALCULATE' : 'CALC ROUTE';
            calcBtn.classList.toggle('btn-success', canCalcRoute);

            // Update app state display
            if (!hasField) {
                appState = 'no_field';
            } else if (hasRoute) {
                appState = 'route_ready';
            } else {
                appState = 'field_ready';
            }

            updateStatus();
        }

        function copyRoute() {
            const output = document.getElementById('routeOutput');
            const text = output.innerText;
            navigator.clipboard.writeText(text).then(() => {
                document.getElementById('statusText').textContent = 'COPIED';
                setTimeout(() => updateStatus(), 1500);
            });
        }

        function clearField() {
            fieldElements = { start: null, target: null, gates: [], obstacles: [], bottles: [] };
            nextGateIndex = 0;
            selectedElement = null;
            generatedRoute = [];
            pathPlanner = null;
            appState = 'no_field';
            saveState();
            updateElementList();
            updatePropertiesPanel();
            updateMeasurements();
            validateField();
            updateButtonStates();
            redraw();
            document.getElementById('routeOutput').innerHTML = '<span class="comment">// field cleared</span>';
        }

        function toggleBottomPanel() {
            const panel = document.getElementById('bottomPanel');
            const icon = document.getElementById('panelToggleIcon');
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                panel.classList.add('expanded');
                icon.textContent = '▼';
            } else if (panel.classList.contains('expanded')) {
                panel.classList.remove('expanded');
                panel.classList.add('collapsed');
                icon.textContent = '▶';
            } else {
                panel.classList.add('expanded');
                icon.textContent = '▼';
            }
        }

        // ==================== SIMULATION FUNCTIONS ====================
        function initSimulation() {
            if (!fieldElements.start) {
                alert('Please place a START point before simulating');
                return false;
            }

            if (generatedRoute.length === 0) {
                alert('Please generate a route first (click CALC ROUTE)');
                return false;
            }

            // Initialize robot at start position
            simState.robot.x = fieldElements.start.x;
            simState.robot.y = fieldElements.start.y;
            simState.robot.heading = fieldElements.start.direction === 'N' ? 90 :
                                     fieldElements.start.direction === 'S' ? -90 :
                                     fieldElements.start.direction === 'E' ? 0 : 180;

            // Get speed and turn rate from inputs
            simState.robot.speed = parseFloat(document.getElementById('simSpeed').value) || 150;
            simState.robot.turnRate = parseFloat(document.getElementById('simTurnRate').value) || 90;
            simState.playbackSpeed = parseFloat(document.getElementById('simPlaybackSpeed').value) || 1;

            // Initialize ToF sensor simulator
            sensorSimulator = new ToFSensorSimulator();

            // Build waypoints from generated route
            buildWaypoints();

            simState.elapsedTime = 0;
            simState.totalDistance = 0;
            simState.trail = [{x: simState.robot.x, y: simState.robot.y}];
            simState.visitedGates.clear();
            simState.knockedBottles.clear();
            simState.waypointIndex = 0;
            simState.movementPhase = 'idle';
            simState.currentTarget = simState.waypoints.length > 0 ? simState.waypoints[0] : null;

            // Update initial sensor readings
            sensorSimulator.update(simState.robot.x, simState.robot.y, simState.robot.heading);

            updateSimDisplay();
            return true;
        }

        function buildWaypoints() {
            simState.waypoints = [];

            // Always follow the generated route with A* waypoints
            if (generatedRoute.length > 0) {
                for (const segment of generatedRoute) {
                    if (segment.type === 'start') continue;

                    // If segment has A* waypoints, add intermediate waypoints first
                    if (segment.waypoints && segment.waypoints.length > 1) {
                        // Add intermediate waypoints (skip first as it's the previous position)
                        for (let i = 1; i < segment.waypoints.length - 1; i++) {
                            simState.waypoints.push({
                                x: segment.waypoints[i].x,
                                y: segment.waypoints[i].y,
                                type: 'waypoint',
                                label: 'WP'
                            });
                        }
                    }

                    // Add the destination waypoint
                    simState.waypoints.push({
                        x: segment.x,
                        y: segment.y,
                        type: segment.type,
                        label: segment.label
                    });
                }
            }
        }

        function startSimulation() {
            if (!simState.running) {
                if (!initSimulation()) return;
            }

            simState.running = true;
            simState.paused = false;
            simState.lastTimestamp = performance.now();

            document.getElementById('simStartBtn').disabled = true;
            document.getElementById('simPauseBtn').disabled = false;

            requestAnimationFrame(simulationLoop);
        }

        function pauseSimulation() {
            simState.paused = !simState.paused;
            document.getElementById('simPauseBtn').textContent = simState.paused ? '▶ RESUME' : '⏸ PAUSE';

            if (!simState.paused) {
                simState.lastTimestamp = performance.now();
                requestAnimationFrame(simulationLoop);
            }
        }

        function resetSimulation() {
            simState.running = false;
            simState.paused = false;
            simState.elapsedTime = 0;
            simState.totalDistance = 0;
            simState.trail = [];
            simState.visitedGates.clear();
            simState.knockedBottles.clear();
            simState.waypoints = [];
            simState.waypointIndex = 0;
            simState.currentTarget = null;
            simState.movementPhase = 'idle';
            simState.targetHeading = 0;

            if (fieldElements.start) {
                simState.robot.x = fieldElements.start.x;
                simState.robot.y = fieldElements.start.y;
                // Set initial heading based on start direction
                simState.robot.heading = fieldElements.start.direction === 'N' ? 90 :
                                         fieldElements.start.direction === 'S' ? -90 :
                                         fieldElements.start.direction === 'E' ? 0 : 180;
            }

            document.getElementById('simStartBtn').disabled = false;
            document.getElementById('simPauseBtn').disabled = true;
            document.getElementById('simPauseBtn').textContent = '⏸ PAUSE';

            updateSimDisplay();
            redraw();
        }

        function simulationLoop(timestamp) {
            if (!simState.running || simState.paused) return;

            const deltaTime = (timestamp - simState.lastTimestamp) / 1000; // seconds
            simState.lastTimestamp = timestamp;

            // Apply playback speed
            const simDelta = deltaTime * simState.playbackSpeed;
            simState.elapsedTime += simDelta;

            // PID-style turn-then-drive behavior
            if (simState.currentTarget) {
                const dx = simState.currentTarget.x - simState.robot.x;
                const dy = simState.currentTarget.y - simState.robot.y;
                const distToTarget = Math.sqrt(dx * dx + dy * dy);

                // Calculate required heading to target
                const requiredHeading = Math.atan2(dy, dx) * 180 / Math.PI;

                // Calculate heading difference
                let headingDiff = requiredHeading - simState.robot.heading;
                while (headingDiff > 180) headingDiff -= 360;
                while (headingDiff < -180) headingDiff += 360;

                const HEADING_TOLERANCE = 2; // degrees - when we're "close enough"

                // State machine: turn first, then drive
                if (simState.movementPhase === 'idle' || simState.movementPhase === 'turning') {
                    // TURNING PHASE: rotate in place to face target
                    if (Math.abs(headingDiff) > HEADING_TOLERANCE) {
                        simState.movementPhase = 'turning';

                        // Turn at constant rate (simulating PID turnToHeading)
                        const maxTurn = simState.robot.turnRate * simDelta;
                        if (Math.abs(headingDiff) > maxTurn) {
                            simState.robot.heading += Math.sign(headingDiff) * maxTurn;
                        } else {
                            simState.robot.heading = requiredHeading;
                        }

                        // Normalize heading to -180 to 180
                        while (simState.robot.heading > 180) simState.robot.heading -= 360;
                        while (simState.robot.heading < -180) simState.robot.heading += 360;
                    } else {
                        // Finished turning, start driving
                        simState.movementPhase = 'driving';
                        simState.targetHeading = requiredHeading;
                    }
                }

                if (simState.movementPhase === 'driving') {
                    // DRIVING PHASE: drive straight at locked heading
                    // Check if we need to re-turn (target moved significantly)
                    if (Math.abs(headingDiff) > 15) {
                        simState.movementPhase = 'turning';
                    } else {
                        // Drive straight (simulating PID driveStraight with odom)
                        const moveSpeed = simState.robot.speed * simDelta;
                        const actualMove = Math.min(moveSpeed, distToTarget);

                        const moveX = Math.cos(simState.robot.heading * Math.PI / 180) * actualMove;
                        const moveY = Math.sin(simState.robot.heading * Math.PI / 180) * actualMove;

                        simState.robot.x += moveX;
                        simState.robot.y += moveY;
                        simState.totalDistance += actualMove;

                        // Add to trail
                        simState.trail.push({x: simState.robot.x, y: simState.robot.y});
                        if (simState.trail.length > 1000) simState.trail.shift();

                        // Check if reached target
                        if (distToTarget < 30) {
                            // Mark as visited based on type
                            if (simState.currentTarget.type === 'gate') {
                                simState.visitedGates.add(simState.currentTarget.label);
                            } else if (simState.currentTarget.type === 'bottle' || simState.currentTarget.type === 'bottle_push') {
                                simState.knockedBottles.add(simState.currentTarget.label);
                            }

                            // Move to next waypoint - reset to turning phase
                            simState.movementPhase = 'idle';
                            simState.waypointIndex++;
                            if (simState.waypointIndex < simState.waypoints.length) {
                                simState.currentTarget = simState.waypoints[simState.waypointIndex];
                            } else {
                                // Simulation complete
                                simState.running = false;
                                simState.currentTarget = null;
                                simState.movementPhase = 'idle';
                                document.getElementById('simStartBtn').disabled = false;
                                document.getElementById('simPauseBtn').disabled = true;
                            }
                        }
                    }
                }
            }

            // Update ToF sensors
            if (sensorSimulator) {
                sensorSimulator.update(simState.robot.x, simState.robot.y, simState.robot.heading);
            }

            updateSimDisplay();
            redraw();

            if (simState.running && !simState.paused) {
                requestAnimationFrame(simulationLoop);
            }
        }

        function updateSimDisplay() {
            document.getElementById('simElapsed').textContent = simState.elapsedTime.toFixed(1) + 's';
            document.getElementById('simDistance').textContent = Math.round(simState.totalDistance) + 'mm';
            document.getElementById('simGates').textContent = simState.visitedGates.size + '/' + fieldElements.gates.length;
            document.getElementById('simBottles').textContent = simState.knockedBottles.size + '/' + fieldElements.bottles.length;

            // Update sensor telemetry display
            if (sensorSimulator && currentMode === 'sim') {
                const readings = sensorSimulator.getFormattedReadings();
                for (const [id, reading] of Object.entries(readings)) {
                    const el = document.getElementById(`sensor_${id}`);
                    if (el) {
                        if (reading.valid) {
                            el.textContent = `${reading.distance}mm`;
                            el.className = 'sensor-value';
                            if (reading.distance < 200) {
                                el.classList.add('close');
                            } else if (reading.distance < 500) {
                                el.classList.add('medium');
                            } else {
                                el.classList.add('far');
                            }
                        } else {
                            el.textContent = reading.hitType === 'none' ? '>2000' : '<30';
                            el.className = 'sensor-value invalid';
                        }
                    }
                }
            }

            // Update status to show current phase
            const statusEl = document.getElementById('statusText');
            if (simState.running && !simState.paused) {
                if (simState.movementPhase === 'turning') {
                    statusEl.textContent = 'TURNING';
                } else if (simState.movementPhase === 'driving') {
                    statusEl.textContent = 'DRIVING';
                } else {
                    statusEl.textContent = 'RUNNING';
                }
            }
        }

        function drawSimulation(ctx) {
            if (currentMode !== 'sim') return;

            // Convert Y coordinate to canvas space (Y is flipped)
            const toCanvasY = (y) => (FIELD_LENGTH - y) * SCALE;

            // Draw trail
            if (document.getElementById('simShowTrail').checked && simState.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(simState.trail[0].x * SCALE, toCanvasY(simState.trail[0].y));
                for (let i = 1; i < simState.trail.length; i++) {
                    ctx.lineTo(simState.trail[i].x * SCALE, toCanvasY(simState.trail[i].y));
                }
                ctx.strokeStyle = 'rgba(115, 212, 122, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw robot
            const rx = simState.robot.x * SCALE;
            const ry = toCanvasY(simState.robot.y);
            const robotRadius = (ROBOT_SIZE / 2) * SCALE;

            // Robot body
            ctx.beginPath();
            ctx.arc(rx, ry, robotRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(92, 207, 230, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#5ccfe6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Heading arrow (flip Y for canvas coordinates)
            if (document.getElementById('simShowHeading').checked) {
                const headingRad = -simState.robot.heading * Math.PI / 180; // Negate for canvas Y flip
                const arrowLen = robotRadius * 0.8;
                const ax = rx + Math.cos(headingRad) * arrowLen;
                const ay = ry + Math.sin(headingRad) * arrowLen;

                ctx.beginPath();
                ctx.moveTo(rx, ry);
                ctx.lineTo(ax, ay);
                ctx.strokeStyle = '#ffcc66';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Arrow head
                const headSize = 8;
                ctx.beginPath();
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax - headSize * Math.cos(headingRad - 0.5), ay - headSize * Math.sin(headingRad - 0.5));
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax - headSize * Math.cos(headingRad + 0.5), ay - headSize * Math.sin(headingRad + 0.5));
                ctx.stroke();
            }

            // Sensor rays visualization
            if (document.getElementById('simShowSensors').checked && sensorSimulator) {
                for (const hit of sensorSimulator.raycastHits) {
                    const fromX = hit.from.x * SCALE;
                    const fromY = toCanvasY(hit.from.y);
                    const toX = hit.to.x * SCALE;
                    const toY = toCanvasY(hit.to.y);

                    // Draw ray line
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);

                    // Color based on hit type
                    if (hit.hitType === 'obstacle') {
                        ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)'; // Red for obstacles
                    } else if (hit.hitType === 'bottle') {
                        ctx.strokeStyle = 'rgba(106, 216, 240, 0.6)'; // Cyan for bottles
                    } else {
                        ctx.strokeStyle = 'rgba(255, 204, 102, 0.4)'; // Yellow for boundaries
                    }
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Draw hit point
                    ctx.beginPath();
                    ctx.arc(toX, toY, 3, 0, Math.PI * 2);
                    if (hit.hitType === 'obstacle') {
                        ctx.fillStyle = '#ff6b6b';
                    } else if (hit.hitType === 'bottle') {
                        ctx.fillStyle = '#6ad8f0';
                    } else {
                        ctx.fillStyle = '#ffcc66';
                    }
                    ctx.fill();
                }

                // Draw sensor positions as small dots
                for (const sensor of sensorSimulator.sensors) {
                    const reading = sensorSimulator.readings[sensor.id];
                    if (reading && reading.pose) {
                        const sx = reading.pose.x * SCALE;
                        const sy = toCanvasY(reading.pose.y);
                        ctx.beginPath();
                        ctx.arc(sx, sy, 2, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffcc66';
                        ctx.fill();
                    }
                }
            }

            // Current target indicator
            if (simState.currentTarget) {
                const tx = simState.currentTarget.x * SCALE;
                const ty = toCanvasY(simState.currentTarget.y);

                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.moveTo(rx, ry);
                ctx.lineTo(tx, ty);
                ctx.strokeStyle = 'rgba(255, 153, 64, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // ==================== PANEL TOGGLE FUNCTIONS ====================
        function toggleLeftPanel() {
            const container = document.getElementById('mainContainer');
            const btn = document.querySelector('.panel-toggle.left');
            leftPanelCollapsed = !leftPanelCollapsed;
            container.classList.toggle('left-collapsed', leftPanelCollapsed);
            btn.textContent = leftPanelCollapsed ? '▶' : '◀';
            setTimeout(resizeCanvas, 250);
        }

        function toggleRightPanel() {
            const container = document.getElementById('mainContainer');
            const btn = document.querySelector('.panel-toggle.right');
            rightPanelCollapsed = !rightPanelCollapsed;
            container.classList.toggle('right-collapsed', rightPanelCollapsed);
            btn.textContent = rightPanelCollapsed ? '◀' : '▶';
            setTimeout(resizeCanvas, 250);
        }

        function toggleFullscreen() {
            if (!leftPanelCollapsed) toggleLeftPanel();
            if (!rightPanelCollapsed) toggleRightPanel();
            const panel = document.getElementById('bottomPanel');
            if (!panel.classList.contains('collapsed')) {
                panel.classList.add('collapsed');
                document.getElementById('panelToggleIcon').textContent = '▶';
            }
        }

        // ==================== RESPONSIVE CANVAS ====================
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const canvas = document.getElementById('canvas');

            // Get available space
            const availableWidth = container.clientWidth - 50; // Padding
            const availableHeight = container.clientHeight - 100; // Padding + toolbar

            // Calculate max scale that fits
            const maxScaleW = availableWidth / FIELD_WIDTH;
            const maxScaleH = availableHeight / FIELD_LENGTH;
            SCALE = Math.min(maxScaleW, maxScaleH, 0.45); // Cap at 0.45 for reasonable size
            SCALE = Math.max(SCALE, 0.2); // Minimum 0.2

            // Set canvas size
            canvas.width = Math.round(FIELD_WIDTH * SCALE);
            canvas.height = Math.round(FIELD_LENGTH * SCALE);

            // Update scale indicator
            updateScaleIndicator();

            redraw();
        }

        function updateScaleIndicator() {
            const indicator = document.getElementById('scaleIndicator');
            if (indicator) {
                const scaleBar = indicator.querySelector('.scale-bar');
                const scaleText = indicator.querySelector('span');
                const barWidth = 500 * SCALE; // 500mm
                scaleBar.style.width = barWidth + 'px';
                scaleText.textContent = '500mm';
            }
        }

        // Event listeners for display options
        document.getElementById('showGrid').addEventListener('change', redraw);
        document.getElementById('showZoneLabels').addEventListener('change', redraw);
        document.getElementById('showClearance').addEventListener('change', redraw);
        document.getElementById('showRoute').addEventListener('change', redraw);

        // Window resize handler
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(resizeCanvas, 100);
        });

        // Floating toolbar tool selection
        document.querySelectorAll('.floating-toolbar .tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tool = btn.dataset.tool;
                setTool(tool);
                // Update both toolbars
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll(`.tool-btn[data-tool="${tool}"]`).forEach(b => b.classList.add('active'));
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in inputs
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
                return;
            }

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'z' && e.shiftKey) {
                    e.preventDefault();
                    redo();
                } else if (e.key === 'y') {
                    e.preventDefault();
                    redo();
                } else if (e.key === 'n' || e.key === 'N') {
                    e.preventDefault();
                    autoGenerate();
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    generateRoute();
                }
                return;
            }

            // Tool shortcuts
            if (e.key === 'v' || e.key === 'V') {
                setTool('select');
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tool-btn[data-tool="select"]').forEach(b => b.classList.add('active'));
            } else if (e.key === 'g' || e.key === 'G') {
                setTool('gate');
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tool-btn[data-tool="gate"]').forEach(b => b.classList.add('active'));
            } else if (e.key === 'o' || e.key === 'O') {
                setTool('obstacle');
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tool-btn[data-tool="obstacle"]').forEach(b => b.classList.add('active'));
            }

            // Delete selected element
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedElement) {
                    e.preventDefault();
                    deleteElement(selectedElement);
                }
            }
        });

        // Animation loop for pulsing effects
        let animationFrame;
        function animate() {
            if (fieldElements.target) {
                redraw();
            }
            animationFrame = requestAnimationFrame(animate);
        }

        // Initialize
        updateElementList();
        validateField();
        updateButtonStates();

        // Start with bottom panel collapsed for more field visibility
        document.getElementById('bottomPanel').classList.add('collapsed');
        document.getElementById('panelToggleIcon').textContent = '▶';

        // Initial canvas resize
        resizeCanvas();
        animate();

        // Auto-generate field and route on page load
        setTimeout(() => {
            autoGenerate();
        }, 100);
    </script>
</body>
</html>
